{
    __ENV[true] = 10;
    local fn aux() { return __ENV[1 < 2]; }
    assert(aux() == 10);
    __ENV[true] = nil;
}


local A,B = 0,{g=10};
local fn f(x) {
    local a = [];
    for (local i = 0; i < 1000; i=i+1) {
        local y = 0;
        {
            a[i] = fn() {
                B.g = B.g+1;
                y = y+x;
                return y+A;
            };
        }
    }
    local dummy = fn() { return a[A]; };
    gc();
    assert(dummy() == a[0]);
    assert(a[0]() == x);
    assert(a[2]() == x);
    gc();
    assert(B.g == 12);
    return a;
}

local a = f(10);
/// force a GC in this level
gc("check"); /// clear check flag
loop { /// loop until GC
    local a = tostr(A)..tostr(A)..tostr(A)..tostr(A); /// create garbage
    A = A+1;
    if (gc("check")) break;
}
assert(a[0]() == 20+A);
assert(a[0]() == 30+A);
assert(a[1]() == 10+A);
gc();
assert(a[1]() == 20+A);
assert(a[1]() == 30+A);
assert(a[2]() == 20+A);
assert(a[7]() == 10+A);
assert(B.g == 19);


/// testing equality
a = [];

for (local i=0; i<5; i=i+1) {
    a[i] = fn(x) {
        return i + a + __ENV;
    };
}
assert(a[2] != a[3] and a[3] != a[4]);

{
    local a = fn(x) { return math.sin(__ENV[x]); };
    local fn f() {
        return a;
    }
    assert(f() == f());
}


/// testing closures with 'for' init clause local variable
a = [];
for (local i=0; i<10; i=i+1) {
    a[i] = fn() { return i; };
    if (i == 3) break;
}
assert(a[4] == undef);
assert(a[0]() == 3);
assert(a[1]() == 3);
assert(a[2]() == 3);
assert(a[3]() == 3);

a = [];
local t = ["a", "b"];
local lt = len(t);

for (local i=0; i<lt; i=i+1) {
    local j=i;
    local k = t[i];
    a[i] = {set = fn(x) { k=x; },
            get = fn() { return j, k; }};
    if (i == 1) break;
}
a[0].set(10);
local r,s = a[1].get();
assert(r == 1 and s == "b");
r,s = a[0].get();
assert(r == 0 and s == 10);
a[1].set("a");
r,s = a[1].get();
assert(r == 1 and s == "a");


///-- testing closures with 'for' control variable x break
///local f
///for i=1,3 do
///  f = function () return i end
///  break
///end
///assert(f() == 1)
///
///for k = 1, #t do
///  local v = t[k]
///  f = function () return k, v end
///  break
///end
///assert(({f()})[1] == 1)
///assert(({f()})[2] == "a")
///
///
///-- testing closure x break x return x errors
///
///local b
///function f(x)
///  local first = 1
///  while 1 do
///    if x == 3 and not first then return end
///    local a = 'xuxu'
///    b = function (op, y)
///          if op == 'set' then
///            a = x+y
///          else
///            return a
///          end
///        end
///    if x == 1 then do break end
///    elseif x == 2 then return
///    else if x ~= 3 then error() end
///    end
///    first = nil
///  end
///end
///
///for i=1,3 do
///  f(i)
///  assert(b('get') == 'xuxu')
///  b('set', 10); assert(b('get') == 10+i)
///  b = nil
///end
///
///pcall(f, 4);
///assert(b('get') == 'xuxu')
///b('set', 10); assert(b('get') == 14)
///
///
///local y, w
///-- testing multi-level closure
///function f(x)
///  return function (y)
///    return function (z) return w+x+y+z end
///  end
///end
///
///y = f(10)
///w = 1.345
///assert(y(20)(30) == 60+w)
///
///
///-- testing closures x break
///do
///  local X, Y
///  local a = math.sin(0)
///
///  while a do
///    local b = 10
///    X = function () return b end   -- closure with upvalue
///    if a then break end
///  end
///  
///  do
///    local b = 20
///    Y = function () return b end   -- closure with upvalue
///  end
///
///  -- upvalues must be different
///  assert(X() == 10 and Y() == 20)
///end
///
///  
///-- testing closures x repeat-until
///
///local a = {}
///local i = 1
///repeat
///  local x = i
///  a[i] = function () i = x+1; return x end
///until i > 10 or a[i]() ~= x
///assert(i == 11 and a[1]() == 1 and a[3]() == 3 and i == 4)
///
///
///-- testing closures created in 'then' and 'else' parts of 'if's
///a = {}
///for i = 1, 10 do
///  if i % 3 == 0 then
///    local y = 0
///    a[i] = function (x) local t = y; y = x; return t end
///  elseif i % 3 == 1 then
///    goto L1
///    error'not here'
///  ::L1::
///    local y = 1
///    a[i] = function (x) local t = y; y = x; return t end
///  elseif i % 3 == 2 then
///    local t
///    goto l4
///    ::l4a:: a[i] = t; goto l4b
///    error("should never be here!")
///    ::l4::
///    local y = 2
///    t = function (x) local t = y; y = x; return t end
///    goto l4a
///    error("should never be here!")
///    ::l4b::
///  end
///end
///
///for i = 1, 10 do
///  assert(a[i](i * 10) == i % 3 and a[i]() == i * 10)
///end
///
///print'+'
///
///
///-- test for correctly closing upvalues in tail calls of vararg functions
///local function t ()
///  local function c(a,b) assert(a=="test" and b=="OK") end
///  local function v(f, ...) c("test", f() ~= 1 and "FAILED" or "OK") end
///  local x = 1
///  return v(function() return x end)
///end
///t()
