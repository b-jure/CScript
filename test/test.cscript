#!../cscript


/*
** Table containing test options.
** "warnings" - if true, print warnings the test throws.
** "noprint" - if true, replace 'print' and 'printf' with CScript functions
**             that print to temporary file (not portable).
** "memory" - if true, print memory after test is finished executing.
** "errors" - if true, display error message in case test fails.
** "timed" - if true, time the test execution and display it
** "tests_script" - filename of the script that generates tests table.
*/
__opts = __G.__opts or {
    warnings = false,
    noprint = true,
    memory = false,
    errors = true,
    timed = false,
    tests_script = "tests.cscript",
};


/*
** {=====================================================================
** Test script internals
** ======================================================================
*/

local version = "CScript 1.0";
if __VERSION != version { /* test script and core version mismatch? */
    io.stderr.write("This test suite is for ", version, ", not for ",
                     __VERSION, "\nExiting...");
    return; /* done */
}


/* global table for caching tests table */
__tests = nil;


/* save command-line arguments and program name */
__CLIARGS = cliargs;
__ARGS = args;
__PROG = "../cscript";


/* false if not running heavy tests */
__heavy = __G.__heavy or true;
/* false if runnning non-portable tests */
__port = __G.__port or !(__POSIX or __WINDOWS);
/* false if not reporting messages of tests not performed */
__skipmsg = __G.__skipmsg or true;


/* tests should import debug library when needed */
debug = nil;


/* upvalues for timing execution */
local initclock, lastclock;

/* store function as locals as tests might change global variables */
local print,printf,execute,fmt,assert,popen,find,runfile,typeof,error,clock,ipairs =
      print,printf,os.execute,string.fmt,assert,io.popen,reg.find,runfile,typeof,
      error,os.clock,ipairs;


if __opts.noprint and !__port {
    __C = { /* store old functions */
        print = __G.print,
        printf = __G.printf,
    };

    /* file for redirecting 'stdout' and 'stderr' when running a test */
    local out = assert(os.tmpname());
    __C.out = out;

    /* replace 'print' while testing */
    __G.print = fn(...) {
        local args = [...];
        local oldout = io.output();
        io.output(out);
        foreach i,arg in ipairs(args) {
            if i > 0
                io.write("\t");
            io.write(tostr(arg));
        }
        io.write("\n");
        io.output(oldout);
    };

    /* replace 'printf' while testing */
    __G.printf = fn(fmt, ...) {
        local str = "";
        local args = [...];
        local oldout = io.output();
        local i = 0;
        local j = string.find(fmt, "%");
        io.output(out);
        while (j and j < len(fmt)) {
            str = str .. string.substr(fmt, i, j - 1);
            if string.byte(fmt, j+1) == '%' {
                str = str .. "%";
                i = j + 1;
            } else {
                if list.len(args) <= 0
                    error("missing format value");
                local arg = tostr(list.remove(args, 0));
                str = str .. arg;
                i = j + 1 + len(arg);
            }
            fmt = string.substr(fmt, j+1);
            j = string.find(fmt, "%");
        }
        str = str .. "\n";
        io.write(str);
        io.output(oldout);
    };
}


if !__opts.warnings { /* no warnings? */
    __C.warn = __G.warn;
    __G.warn = fn(...) { return; };
}


/*
** Colorize text if 'stdout' is terminal.
** @s - string
** @c - string
*/
local fn termcolor(s,c) {
    if (!__port and execute("[ -t 1 ]"))
        return (c .. s .. "\e[0m") or s;
    return s;
}

local fn RED(s) { return termcolor(s, "\e[31m"); }
local fn GREEN(s) { return termcolor(s, "\e[32m"); }
local fn YELLOW(s) { return termcolor(s, "\e[33m"); }


/*
** Generate test string that depends on test result 'stat'.
** @test - string
** @stat - any
*/
local fn testfmt(test, stat) {
    local C = stat and GREEN or RED;
    local res = stat and "PASS" or "FAIL";
    return fmt("%s  %4s  %s %-55s", C("["), C(res), C("]"), YELLOW(test));
}


/*
** Builds command string for listing files/directories that works
** in both a posix and windows environment.
** @what - string
** @path - ?string
*/
local fn lscmd(what, path) {
    local cmd;
    assert(__POSIX or __WINDOWS);
    if (what == "d") { /* list directories? */
        if (__POSIX) { /* posix environment? */
            cmd = "ls -p "; /* use 'ls' */
            if (path) cmd = cmd .. path .. " ";
            cmd = cmd .. "| grep /"; /* and 'grep' */
        } else { /* otherwise windows environment */
            cmd = "dir /b /a:d"; /* use 'dir' */
            if (path) cmd = cmd .. path;
        }
    } else { /* otherwise list non-hidden files */
        assert(what == "f");
        if (__POSIX) {
            cmd = "ls -p ";
            if (path) cmd = cmd .. path .. " ";
            cmd = cmd .. "| grep -v /"; /* and 'grep' */
        } else {
            cmd = "dir /b /a:-d-h ";
            if (path) cmd = cmd .. path;
        }
    }
    return cmd;
}


/*
** Finds all testsuites and their tests in the current directory.
** First, the current directory is listed, each directory listed is
** considered to be a testsuite, and each file ending with '.cscript'
** in that directory is considered as a test belonging to that testsuite.
** If we are not running in posix or windows environment, use hard-coded
** testsuites described in 'tests.cscript'. Returned table contains
** testsuite names as keys and values are lists containing test filepaths.
** @filename - ?string
*/
local fn get_tests(filename) {
    local tests = {};
    if (!filename and !__port) { /* discover directories and tests? */
        local f = assert(popen(lscmd("d")), "can't list directories");
        foreach dir in f.lines() {
            if dir == "libs/" continue; /* ignore 'libs' (used for testing) */
            local tsuite = string.substr(dir, 0, -2); /* no '/' or '\\' */
            local ltests = []; /* list of testsuite tests */
            local n = 0; /* number of tests */
            f = assert(popen(lscmd("f", dir)), "can't list files");
            foreach file in f.lines() {
                if (!find(file, "%.cscript$"))
                    continue; /* skip files without '.cscript' suffix */
                ltests[n] = dir .. file; /* store test path */
                n = n + 1; /* inc. test count */
            }
            tests[tsuite] = ltests; /* store the testsuite */
        }
    } else { /* otherwise try get 'tests' table from a file */
        filename = filename or __opts.tests_script;
        tests = runfile(filename);
        if typeof(tests) != "table"
            error(filename .. " script must return a table");
    }
    __tests = tests; /* cache it into global tests table */
    return tests;
}


/*
** Lists all testsuites in 'tests' and the tests they contain.
** If 'tests' is not provided or is nil, then global '__tests' is checked,
** lastly the 'tests' table is re-generated.
** @tests - ?table
*/
local fn list_tests(tests) {
    tests = testtable(tests);
    foreach tsuite, tlist in pairs(tests) {
        print(tsuite .. ":");
        foreach _, test in ipairs(tlist)
            print("\t" .. test);
    }
}


/*
** Returns formatted elapsed time depending on the time 'c'.
** @c - number
*/
local fn gettime(c) {
    local s = fmt("%-8g (+%-g)", c - initclock, c - lastclock);
    lastclock = c;
    return s;
}


/* use K for 1000 and M for 1000000 (not 2^10 -- 2^20) */
local fn memfmt(m) {
    local fn round(m) {
        m = m + 0.04999;
        return fmt("%.1f", m); /// keep one decimal digit
    }
    if m < 1000
        return m;
    else {
        m = m / 1000;
        if m < 1000
            return tostr(round(m)).."K";
        else
            return tostr(round(m/1000)).."M";
    }
}


local max = 0;
local fn showmem() {
    local m = gc("count") * 1024;
    max = (m > max) and m or max;
    printf("mem_current: %  mem_max: %", YELLOW(memfmt(m)), RED(memfmt(max)));
};


/*
** Runs individual test and outputs the result to 'io.stdout'.
** @filepath - string
*/
local fn run_test(filepath) {
    if (__opts.memory)
        showmem();
    local stat, msg = pcall(runfile, filepath);
    local c = clock();
    printf("%  %", testfmt(filepath, stat), __opts.timed and gettime(c) or "");
    if (__opts.errors and !stat)
        print(msg);
}

/// utf8, syntax, io, math

/*
** @tsuite - string
** @what - string
*/
local fn testsuite_headerfmt(tsuite, what) {
    print(YELLOW("> " .. what .. "(") .. tsuite .. YELLOW(")"));
}


/*
** Runs all the tests located in 'tlist' for testsuite 'tsuite'.
** @tsuite - string
** @tlist - list
*/
local fn run_tests(tsuite, tlist) {
    testsuite_headerfmt(tsuite, "BEGIN");
    if (__opts.timed) { /* timming the execution? */
        initclock = clock();
        lastclock = initclock;
    }
    foreach _, filepath in ipairs(tlist)
        run_test(filepath);
    testsuite_headerfmt(tsuite, "END");
}


/*
** Return 'tests' if non-nil, or tries to fetch global '__tests" or
** it re-generates tests from the script '__opts.tests_script'.
** @tests - ?table
*/
local fn teststable(tests) {
    return tests or __tests or get_tests();
}


/*
** Runs specific testsuites provided as extra arguments.
** These must map to testsuites located in 'tests' table.
** If 'tests' is not provided, '__tests' global is checked,
** and if global is nil the 'tests' table is re-generated.
** @tests - ?table
*/
local fn run_testsuites(tests, ...) {
    local filter = [...];
    tests = teststable(tests);
    foreach i,name in ipairs(filter) {
        assert(typeof(filter[i]) == "string"); /* these are arguments */
        local tlist = tests[name];
        if (tlist)
            run_tests(name, tlist);
        else
            error("invalid testsuite '" .. name .. "'");
    }
}


/*
** Runs all testsuites located in 'tests' table.
** If 'tests' is not provided, then the global '__tests' is checked,
** and if global is nil the 'tests' table is re-generated.
** @tests - ?table
*/
local fn run_all_testsuites(tests) {
    tests = teststable(tests);
    foreach tsuite, tlist in pairs(tests)
        run_tests(tsuite, tlist);
}

/* }===================================================================== */

/*
** {====================================================================
** Command-line
** =====================================================================
*/

if (__ARGS.len > 1)
    run_testsuites(nil, list.flatten(__ARGS, 1));
else
    run_all_testsuites();

if __C.out /* have temporary file? */
    os.remove(__C.out); /* remove it */

/* }==================================================================== */
