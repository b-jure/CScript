#!../cscript


/*
** Test options.
**
** "termcodes" - if true (and 'stdout' is terminal), output ansii codes to
**               color and set different modes to text in terminal, this
**               also enables additional goodies, for example showing the
**               current test that is executing (not portable).
** "warnings" - if true, print warnings the test throws.
** "noprint" - if true, replace 'print' and 'printf' with CScript functions
**             that print to temporary file (not portable).
** "memory" - if true, print memory before test is executed.
** "errors" - if true, display error message in case test fails.
** "timed" - if true, time the test execution and display it
** "reprint_failed" - if true, after all tests are finished, re-prints failed
**                    tests (and their errors if "errors" is true).
** "stop_on_fail" - if true, stop testing after first failed test.
** "run_isolated" - if true, run each test in different process by executing
**                  standalone interpreter with test as its only argument,
**                  this is not portable and execution timing won't be as
**                  reliable information to look at, additionally all warnings
**                  and errors won't be reachable, only the exit status.
**                  Finally the skip messages won't get registered, however
**                  this provides complete isolation for precise testing.
** "testsuites_to_skip" - list of testsuite names, which are skipped.
** "tests_script" - filename of the script that generates tests table, can
**                  be nil, in which case, script will try to discover the
**                  testsuites and their tests (not portable).
*/
__opts = __G.__opts or {
    termcodes = true,
    warnings = false,
    noprint = true,
    memory = false,
    errors = true,
    timed = true,
    reprint_failed = true,
    stop_on_fail = false,
    run_isolated = false,
    testsuites_to_skip = [];
    tests_script = "testsuites.cscript",
};


/*
** {=====================================================================
** Additional settings
** ======================================================================
*/

/* false if not running heavy tests */
__heavy = __G.__heavy or true;
/* false if runnning non-portable tests or assumming posix/windows environment */
__port = __G.__port or !(__POSIX or __WINDOWS);
/* false if not reporting messages of tests not performed */
__skipmsg = __G.__skipmsg or true;

/* }===================================================================== */


/*
** {=====================================================================
** Test script internals
** ======================================================================
*/

local version = "CScript 1.0";
if __VERSION != version { /* test script and core version mismatch? */
    io.stderr.write("This test suite is for ", version, ", not for ",
                     __VERSION, "\nExiting...");
    return; /* done */
}


/* global table for caching tests table */
__tests = nil;


/* save command-line arguments and program name */
__CLIARGS = cliargs;
__ARGS = args;
__PROG = "../cscript";


/* storage for timing execution */
local initclock, lastclock;

/* table for storing failed tests */
local failed_tests = {};
/* list for storing messages about (parts of) skipped tests */
local skip_msgs = [];

/* save standard files */
local stdout, stderr, stdin = io.stdout, io.stderr, io.stdin;

/* store these as locals as tests might change them if they are not ran in isolation */
local traceback,print,printf,execute = debug.traceback,print,printf,os.execute;
local fmt,assert,popen,write,flush = string.fmt,assert,io.popen,io.write,io.flush;
local find,runfile,typeof,error,ipairs = reg.find,runfile,typeof,error,ipairs;
local output,sfind,substr,tostr = io.output,string.find,string.substr,tostr;
local len,llen,remove,byte,clock = len,list.len,list.remove,string.byte,os.clock;
local tmpname,pairs,gc,osremove,flatten = os.tmpname,pairs,gc,os.remove,list.flatten;
local exit,getinfo = os.exit,debug.getinfo;


/* tests should import debug library when needed */
debug = nil;


/* storage for print functions and temporary file (otherwise empty) */
__C = {};


if __opts.noprint and !__port {
    __C = { /* store old functions */
        print = __G.print,
        printf = __G.printf,
    };

    /* file for redirecting 'stdout' and 'stderr' when running a test */
    local out = assert(tmpname());
    __C.out = out;

    /* replace 'print' while testing */
    __G.print = fn(...) {
        local args = [...];
        local oldout = output();
        output(out);
        foreach i,arg in ipairs(args) {
            if i > 0
                write("\t");
            write(tostr(arg));
        }
        write("\n");
        output(oldout);
    };

    /* replace 'printf' while testing */
    __G.printf = fn(fmt, ...) {
        local str = "";
        local args = [...];
        local oldout = output();
        local i = 0;
        local j = sfind(fmt, "%");
        output(out);
        while (j and j < len(fmt)) {
            str = str .. substr(fmt, i, j - 1);
            if byte(fmt, j+1) == '%' {
                str = str .. "%";
                i = j + 1;
            } else {
                if llen(args) <= 0
                    error("missing format value");
                local arg = tostr(remove(args, 0));
                str = str .. arg;
                i = j + 1 + len(arg);
            }
            fmt = substr(fmt, j+1);
            j = sfind(fmt, "%");
        }
        str = str .. "\n";
        write(str);
        output(oldout);
    };
}


if !__opts.warnings { /* no warnings? */
    __C.warn = __G.warn;
    __G.warn = fn(...) { return; };
}


/*
** Apply terminal code 'c' if 'stdout' is terminal.
** @s - string
** @c - string
*/
local fn termcode(c, s) {
    s = s or "";
    if (!__port and __opts.termcodes and execute("[ -t 1 ]"))
        return (c .. s .. "\e[0m") or s;
    return s;
}

local ESC = fn (seq) { return "\e" .. seq; };

/* colors */
local fn RED(s) { return termcode(ESC("[31m"), s); }
local fn GREEN(s) { return termcode(ESC("[32m"), s); }
local fn YELLOW(s) { return termcode(ESC("[33m"), s); }
local fn MAGENTA(s) { return termcode(ESC("[35m"), s); }
local fn CYAN(s) { return termcode(ESC("[36m"), s); }

/* modes */
local fn STRIKE(s) { return termcode(ESC("[9m"), s); }

/* cursor */
local fn SAVEPOS() { return termcode(ESC("7")); }
local fn LOADPOS() { return termcode(ESC("8")); }

/* erase */
local fn ERASELINE() { return termcode(ESC("[2K")); }


if __skipmsg {

    /*
    ** Stores the message 'msg' into 'skip_msgs'.
    ** @msg - string
    */
    fn Message(msg) {
        local t = getinfo(2, "s");
        skip_msgs[skip_msgs.len] = msg .. " in '" .. YELLOW(t.source) .. "'";
    }

}


/*
** Generate test string that depends on test result 'stat'.
** @test - string
** @stat - any
*/
local fn testfmt(test, stat) {
    local C = stat and GREEN or RED;
    local res = stat and "PASS" or "FAIL";
    return fmt("%s  %4s  %s %-55s", C("["), C(res), C("]"), YELLOW(test));
}


/*
** Builds command string for listing files/directories that works
** in both a posix and windows environment.
** @what - string
** @path - ?string
*/
local fn lscmd(what, path) {
    local cmd;
    assert(__POSIX or __WINDOWS);
    if (what == "d") { /* list directories? */
        if (__POSIX) { /* posix environment? */
            cmd = "ls -p "; /* use 'ls' */
            if (path) cmd = cmd .. path .. " ";
            cmd = cmd .. "| grep /"; /* and 'grep' */
        } else { /* otherwise windows environment */
            cmd = "dir /b /a:d"; /* use 'dir' */
            if (path) cmd = cmd .. path;
        }
    } else { /* otherwise list non-hidden files */
        assert(what == "f");
        if (__POSIX) {
            cmd = "ls -p ";
            if (path) cmd = cmd .. path .. " ";
            cmd = cmd .. "| grep -v /"; /* and 'grep' */
        } else {
            cmd = "dir /b /a:-d-h ";
            if (path) cmd = cmd .. path;
        }
    }
    return cmd;
}


/*
** Finds all testsuites and their tests in the current directory.
** First, the current directory is listed, each directory listed is
** considered to be a testsuite, and each file ending with '.cscript'
** in that directory is considered as a test belonging to that testsuite.
** If we are not running in posix or windows environment, use hard-coded
** testsuites defined in '__opts.tests_script' file. Returned table contains
** testsuite names as keys and values are lists containing test filepaths.
** @filename - ?string
*/
local fn get_tests(filename) {
    local tests = {};
    if (!filename and !__port) { /* discover directories and tests? */
        local f = assert(popen(lscmd("d")), "can't list directories");
        foreach dir in f.lines() {
            if byte(dir, 0) == '_' /* file starts with '_'? */
                continue; /* ignore it */
            local tsuite = substr(dir, 0, -2); /* no '/' or '\\' */
            local ltests = []; /* list of testsuite tests */
            local n = 0; /* number of tests */
            f = assert(popen(lscmd("f", dir)), "can't list files");
            foreach file in f.lines() {
                if (!find(file, "%.cscript$"))
                    continue; /* skip files without '.cscript' suffix */
                ltests[n] = dir .. file; /* store test path */
                n = n + 1; /* inc. test count */
            }
            tests[tsuite] = ltests; /* store the testsuite */
        }
    } else { /* otherwise try get 'tests' table from a file */
        filename = filename or __opts.tests_script;
        tests = runfile(filename);
        if typeof(tests) != "table"
            error("'" .. filename .. "' script must return a table");
    }
    __tests = tests; /* cache it into global tests table */
    return tests;
}


/*
** Lists all testsuites in 'tests' and the tests they contain.
** If 'tests' is not provided or is nil, then global '__tests' is checked,
** lastly the 'tests' table is re-generated.
** @tests - ?table
*/
local fn list_tests(tests) {
    tests = testtable(tests);
    foreach tsuite, tlist in pairs(tests) {
        print(tsuite .. ":");
        foreach _, test in ipairs(tlist)
            print("\t" .. test);
    }
}


/*
** Returns formatted elapsed time depending on the time 'c'.
** @c - number
*/
local fn gettime(c) {
    local s = fmt("%-8g (+%-g)", c - initclock, c - lastclock);
    lastclock = c;
    return s;
}


/*
** Formats memory usage in bytes to use K for 1000 and M for 1000000
** (not 2^10 -- 2^20).
** @m - number
*/
local fn memfmt(m) {
    local fn round(m) {
        m = m + 0.04999;
        return fmt("%.1f", m); /// keep one decimal digit
    }
    if m < 1000
        return m;
    else {
        m = m / 1000;
        if m < 1000
            return tostr(round(m)).."K";
        else
            return tostr(round(m/1000)).."M";
    }
}


/*
** Displays current memory usage and the last maximum memory usage.
** Formatting is done according to 'memfmt'.
*/
local max = 0;
local fn showmem() {
    local m = gc("count") * 1024;
    max = (m > max) and m or max;
    printf("           mem_current: %  mem_max: %",
           YELLOW(memfmt(m)), RED(memfmt(max)));
};


/*
** Runs individual test and outputs the result to 'stdout'.
** @filepath - string
*/
local fn run_test(filepath) {
    if (__opts.memory)
        showmem();
    local termcodes = !__port and __opts.termcodes and execute("[ -t 1 ]");
    local isorun = !__port and __opts.run_isolated;
    if (termcodes) {
        output(stdout);
        write(fmt("%sCurrently executing '%s'...", SAVEPOS(), YELLOW(filepath)));
        flush();
    }
    local stat, msg, code;
    if (isorun) {
        local devnull = __POSIX and "> /dev/null 2>&1" or "> nul 2>&1";
        stat, msg, code = execute(__PROG .. " " .. filepath .. devnull);
    } else
        stat, msg = xpcall(runfile, traceback, filepath);
    local c = clock();
    if (termcodes) {
        output(stdout);
        write(LOADPOS() .. ERASELINE());
        flush();
    }
    printf("%  %", testfmt(filepath, stat), __opts.timed and gettime(c) or "");
    if (!stat) {
        if (isorun and msg and code)
            msg = msg .. " (code " .. tostr(code) .. ")";
        failed_tests[filepath] = msg;
        if (__opts.errors)
            print(msg);
        if (__opts.stop_on_fail) {
            if (__C.out) osremove(__C.out);
            exit(0, true);
        }
    }
}


/*
** @tsuite - string
** @what - string
*/
local fn testsuite_headerfmt(tsuite, what) {
    local mode, cl = fn(x){return x;}, MAGENTA;
    if what == "END" {
        mode = STRIKE;
        cl = CYAN;
    }
    print(cl("> " .. what .. "(") .. mode(tsuite) .. cl(")"));
}


/*
** Checks if test list entry 'filepath' is a string.
** @tsuite - string
** @filepath - string
*/
local fn check_tlist_entry(tsuite, filepath) {
    if (typeof(filepath) != "string")
        error("expected filepath in test list (in testsuite '"..tsuite.."'), "
                .. "instead got " .. typeof(filepath));
}


/*
** Runs all the tests located in 'tlist' for testsuite 'tsuite'.
** @tsuite - string
** @tlist - list
*/
local fn run_tests(tsuite, tlist) {
    testsuite_headerfmt(tsuite, "BEGIN");
    if (__opts.timed) { /* timming the execution? */
        initclock = clock();
        lastclock = initclock;
    }
    foreach _, filepath in ipairs(tlist) {
        check_tlist_entry(tsuite, filepath);
        run_test(filepath);
    }
    testsuite_headerfmt(tsuite, "END");
}


/*
** Return 'tests' if non-nil, or tries to fetch global '__tests" or
** it re-generates tests from the script '__opts.tests_script'.
** @tests - ?table
*/
local fn teststable(tests) {
    return tests or __tests or get_tests();
}


/*
** Checks if testsuite should be skipped.
** @testsuite - string
*/
local fn shouldskip(testsuite) {
    if __opts.testsuites_to_skip {
        foreach i,name in ipairs(__opts.testsuites_to_skip) {
            if name == testsuite
                return true;
        }
    }
    return false;
}


/*
** Runs specific testsuites provided as extra arguments.
** These must map to testsuites located in 'tests' table.
** If 'tests' is not provided, '__tests' global is checked,
** and if global is nil the 'tests' table is re-generated.
** @tests - ?table
*/
local fn run_testsuites(tests, ...) {
    local filter = [...];
    tests = teststable(tests);
    foreach i,name in ipairs(filter) {
        if typeof(filter[i]) != "string"
            error("expect testsuite name");
        if shouldskip(name)
            continue; /* skip */
        local tlist = tests[name];
        if (tlist)
            run_tests(name, tlist);
        else
            error("invalid testsuite '" .. name .. "'");
    }
}


/*
** Runs all testsuites located in 'tests' table.
** If 'tests' is not provided, then the global '__tests' is checked,
** and if global is nil the 'tests' table is re-generated.
** @tests - ?table
*/
local fn run_all_testsuites(tests) {
    tests = teststable(tests);
    foreach name,tlist in pairs(tests) {
        assert(typeof(name) == "string"); /* must be testsuite name */
        if shouldskip(name)
            continue; /* skip */
        run_tests(name, tlist);
    }
}

/* }===================================================================== */


/*
** {====================================================================
** Main
** =====================================================================
*/

if (__ARGS.len > 1)
    run_testsuites(nil, flatten(__ARGS, 1));
else
    run_all_testsuites();

if __C.out /* have temporary file? */
    osremove(__C.out); /* remove it */

if __skipmsg and skip_msgs.len > 0 {
    print("Skip messages:");
    foreach _,msg in ipairs(skip_msgs)
        print("> " .. msg);
}

if __opts.reprint_failed {
    local n = len(failed_tests);
    if (n > 0) {
        printf("% failed test(s):", RED(tostr(n)));
        foreach test,msg in pairs(failed_tests)
            print(RED(test) .. (__opts.errors and ":\n"..msg or ""));
    }
}

/* }==================================================================== */
