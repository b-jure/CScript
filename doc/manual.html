<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width"/>
        <title>CScript 1.0 Reference Manual</title>
        <link rel="stylesheet" type="text/css" href="cscript.css">
        <link rel="stylesheet" type="text/css" href="index.css">
    </head>
    <p>
        <h1>CScript 1.0 Reference Manual</h1>
        <small>
            <p>
            Copyright &copy; 2020&ndash;2024 Lua.org, PUC-Rio;
            2024&ndash;2025 Jure BagiÄ‡.
            </p>
        </small>
        <div class="menubar">
            <a href="contents.html#contents">contents</a>
            &middot;
            <a href="contents.html#index">index</a>
        </div>




        <h1>1 &ndash; <a name="1">Introduction</a></h1>
        <p>
        CScript is a lightweight embeddable scripting language.
        C in CScript refers to the C programming language as it mimics its
        syntax (as much as possible).
        It's syntax supports various types of programming styles and it does
        not enforce any type/style upon the user (it has all the tools and the
        user chooses the tool for the job).
        <br/><br/>
        CScript is dynamically typed, it runs by interpreting bytecode with
        a stack-based virtual machine, and it's memory is automatically
        managed by the incremental garbage collection.
        <br/><br/>
        CScript is implemented as a library fully written in C, and to be
        compiled with any standard C/C++ compiler implementing C99 standard.
        CScript distribution includes a host program called
        <code>cscript</code>, which is the interpreter that uses CScript
        library.
        CScript is intended to be primarily used as lightweight embeddable
        scripting language but also as a stand-alone language that is easy
        to learn as it shares most of its syntax with the C programming
        language and <a href="https://www.lua.org/">Lua</a>.
        <br/><br/>
        CScript is free software, and is provided with no guarantees,
        as stated in its license.
        <br/><br/>
        This manual is subject to changes, as the language itself changes.
        However the reference manual is always valid for the same version of
        CScript distribution. If you spot the mistake or you think the manual
        is lacking in various places, please let me know
        (<a href="https://github.com/b-jure/cscript">link</a> to the official
        git[hub] repository).
        </p>




        <h1>2 &ndash; <a name="2">Basic Concepts</a></h1>
        <p>
        This section describes the basic concepts of the language.
        </p>


        <h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>
        <p>
        CScript is a dynamically types language.
        This means that variables do not have types; only values do.
        There are no type definitions in the language instead all values
        carry their own type.
        <br/><br/>
        All values in CScript are first-class values, meaning all values
        can be stored in variables (as is expected), passed as arguments
        to other functions and returned as results.
        <br/><br/>
        There are eleven basic types in CScript:
        <em>nil</em>, <em>boolean</em>, <em>number</em>, <em>string</em>, 
        <em>function</em>, <em>userdata</em>, <em>thread</em>, <em>table</em>, 
        <em>list</em>, <em>class</em> and <em>instance</em>.
        <br/><br/>
        <!-- nil -->
        The type <em>nil</em> has one single value, <b>nil</b>, and is
        intended to represent absence of value.
        <br/><br/>
        <!-- boolean -->
        The type <em>boolean</em> has two values, <b>true</b> and <b>false</b>.
        Both <b>nil</b> and <b>false</b> make a condition false; they are
        collectively called <em>false values</em>
        (for example in C, we would consider <b>0</b> value as the
        <em>false value</em>).
        Any other value makes a condition true.
        So what is the difference between the <b>false</b> and <b>nil</b>?
        Here is a simple example, if we were to index a table with <b>nil</b>
        it would raise a runtime error; as said, use <b>nil</b> to indicate
        absence of value.
        <br/><br/>
        <!-- number -->
        The type <em>number</em> represents both integer and real
        (floating-point) numbers, using two subtypes: <em>integer</em> and
        <em>float</em> (as is indicated in the C&nbsp;API header).
        <br/>
        Standard CScript uses 64-bit integers and double-precision (64-bit)
        floats. Configuration header can be tinkered to allow 32-bit integers
        and/or single-precision (32-bit) floats, but this but would probably
        require internal patches (see <code>csconf.h</code> if interested).
        <br/>
        Any overflow when manipulating integer values <em>wrap around</em>,
        according to the usual rules of two-complement arithmetics.
        This holds both for negative (signed) and positive (unsigned) integers.
        <br/>
        The conversion between the two subtypes mimics C standard.
        For example, if we were to do a mathematical operation between the two
        numbers, one of them is <em>integer</em> and the other is
        <em>float</em>, before the operation <em>integer</em> would be
        converted to a <em>float</em>.
        Additionally before the operation if the both numbers are of type
        <em>float</em> but both have <em>integer</em> representation, then
        they would be converted to <em>integers</em> before the operation.
        However operations such as division and exponentiation always convert
        their operands to <em>float</em> subtype (the exception being the
        integer division '<code>//</code>').
        <br/><br/>
        <!-- string -->
        The type <em>string</em> represents immutable sequence of bytes.
        Strings can contain any 8-bit value, including embedded zeros
        ('<code>\0</code>').
        Internally CScript is encoding-agnostic; it makes no assumptions
        about the contents of a string.
        The length of any string in CScript must fit in a CScript integer.
        <br/><br/>
        <!-- function -->
        The type <em>function</em> can be a function written in CScript or
        C, both of which can be manipulated and called.
        <br/><br/>
        <!-- userdata -->
        The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data
        to be stored in a variable.
        A userdata value represents a block of raw memory.
        There are two kinds of userdata:
        <em>full userdata</em>, which is an object with a block of memory
        managed by CScript, and <em>light userdata</em>,
        which is simply a C&nbsp;pointer value.
        Userdata has no predefined operations in CScript except assignment
        and identity test (<code>==</code>).
        By using <em>metalists</em>, the programmer can define operations
        for full userdata values (see <a href="#2.4">&sect;2.4</a>).
        Userdata values cannot be created or modified in CScript, only
        through the C&nbsp;API.
        This guarantees the integrity of data owned by the host program
        and C&nbsp;libraries.
        <br/><br/>
        <!-- table -->
        The type <em>table</em> implements associative arrays,
        that is, arrays that can have as indices not only numbers,
        but any CScript value except <b>nil</b> and NaN
        (<em>Not a Number</em> is a special floating-point value
        used by the IEEE 754 standard to represent undefined numerical
        results, such as <code>0/0</code>).
        <br/>
        Tables can be contain values of all types (except <b>nil</b>).
        Any key associated to the value <b>nil</b> is not considered part of
        the table. Conversely, any key that is not part of a table has
        an associated value <b>nil</b>.
        <br/>
        Tables can be indexed two different ways, given the key
        <code>name</code> we index the table <code>t</code> either as
        <code>t.name</code> or <code>t["name"]</code>.
        The array-like indexing is useful when we want to index the table
        with the value of the variable.
        <br/><br/>
        <!-- list -->
        The type <em>list</em> is a linear collection of values each
        identified by an <b>index</b>. Each <b>index</b> is an integer
        value starting from 0 which is used to index the <em>list</em> in
        order to retrieve the value (variable values can also be used in
        place of literal integers). Negative integer indices are not allowed.
        <br/><br/>
        <!-- class -->
        The type <em>class</em> is useful abstraction for object-oriented
        programming.
        Class can contain <em>methods</em> which are defined upon class
        creation and can not be changed thereafter.
        <em>class</em> can inherit from another class, the name of the
        <em>class</em> from which we inherit is called a <em>superclass</em>.
        When inheriting all of the <em>superclass methods</em> are copied over
        to the <em>class</em> being created.
        <br/>
        Similar to <em>full userdata</em>, classes can also make use of
        <em>metalists</em> to define operations on their instances.
        <br/><br/>
        <!-- instance -->
        The type <em>instance</em> is similar to <em>table</em>,
        meaning they can be indexed in the same way as a table and therefore
        can hold values (a state), these values are called
        <em>instance fields</em>.
        Each <em>instance</em> is constructed from a <em>class</em>.
        The <em>class</em> methods of the <em>instance</em> can't be changed
        but can be shadowed by creating a non-<b>nil</b> <em>field</em> under
        the same index value.
        <br/><br/>
        <!-- thread -->
        The type <em>thread</em> represents independent threads of execution.
        CScript threads are not related to operating-system threads.
        <br/><br/>
        The library function <a href=#typeof><code>typeof</code></a> returns a
        string describing the type of a given value.
        </p>


        <h2>2.2 &ndash; <a name="2.2">Global Table</a></h2>
        <p>
        As we will discuss further in <a href="#3.2">&sect;3.2</a> and
        <a href="#3.3.3">&sect;3.3.3</a>, any reference to a free name
        (that is, a name not bound to any declaration) <code>var</code>
        is considered to be a global variable and it's value is set into
        the global table.
        This value is kept aat a special index in the C registry
        (see <a href="#4.3">&sect;4.3</a>).
        Moreover, every chunk is compiled in the scope of global table.
        This table can be accessed via <a href="#4">API</a> or the global
        variable <a href="#__G"><code>__G</code></a>.
        Note that <a href="#__G"><code>__G</code></a> is never used
        internally, so changing its value will affect only your own code.
        </p>


        <h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>
        <p>
        Several operations in CScript can <em>raise</em> an error.
        An error interrupts the normal flow of the program,
        which can continue by <em>catching</em> the error.
        <br/><br/>
        CScript code can explicitly raise an error by calling the
        <a href="#error"><code>error</code></a> function.
        (This function never returns.)
        <br/><br/>
        To catch errors in CScript, you can do a <em>protected call</em>,
        using <a href="#pcall"><code>pcall</code></a>
        (or <a href="#xpcall"><code>xpcall</code></a>).
        The function <a href="#pcall"><code>pcall</code></a> calls a
        given function in <em>protected mode</em>.
        Any error while running the function stops its execution,
        and control returns immediately to <code>pcall</code>,
        which returns a status code.
        <br/><br/>
        Because CScript is an embedded extension language, CScript code
        starts running by a call from C&nbsp;code in the host program.
        (When you use CScript standalone, the <code>cscript</code>
        application is the host program.)
        Usually, this call is protected; so, when an otherwise unprotected
        error occurs during the compilation or execution of a CScript chunk,
        control returns to the host, which can take appropriate measures,
        such as printing an error message.
        <br/><br/>
        Whenever there is an error, an <em>error object</em> is propagated
        with information about the error.
        CScript itself only generates errors whose error object is a string,
        but programs can generate errors with any value as the error object.
        It is up to the CScript program or its host to handle such error
        objects.
        An error object is often called an <em>error message</em>,
        even though it does not have to be a string.
        <br/><br/>
        When you use <a href="#xpcall"><code>xpcall</code></a>
        (or <a href="#cs_pcall"><code>cs_pcall</code></a>, in C)
        you can give a <em>message handler</em> to be called in case of
        errors.
        This function is called with the original error object and returns
        a new error object.
        It is called before the error unwinds the stack, so that it can
        gather more information about the error, for instance by inspecting
        the stack and creating a stack traceback.
        This message handler is still protected by the protected call;
        so, an error inside the message handler will call the message handler
        again.
        If this loop goes on for too long, CScript breaks it and returns an
        appropriate message.
        The message handler is called only for regular runtime errors.
        It is not called for memory-allocation errors
        nor for errors while running finalizers or other message handlers.
        <br/><br/>
        CScript also offers a system of <em>warnings</em>
        (see <a href="#warn"><code>warn</code></a>).
        Unlike errors, warnings do not interfere in any way with program
        execution.
        They typically only generate a message to the user, although this
        behavior can be adapted from C
        (see <a href="#cs_setwarnf"><code>cs_setwarnf</code></a>).
        </p>


        <h2>2.4 &ndash; <a name="2.4">Metalists aand Metamethods</a></h2>
        <p>
        Every value in CScript can have a <em>metalist</em>.
        This <em>metalist</em> is an ordinary CScript list that defines
        the behaviour of the original value under certain events.
        You can change several aspects of the behaviour of a value by
        setting specific indices in its metalist.
        For instance, when a non-numeric values are the operands of an
        addition, CScript checks for a function at the index 
        <code>__add</code> of the value's metalist.
        If it finds one, CScript calls this function to perform the addition.
        <br/><br/>
        The index for each event in a metalist is a regular global integer
        value prefixed by two underscores;
        the corresponding value is called a <em>metavalue</em>.
        For most events, the metavalue must be a function,
        which is then called a <em>metamethod</em>.
        In the previous example, the index is the global variable
        <code>__add</code> and the metamethod is the function that
        performs the addition.
        Unless stated otherwise, a metamethod can in fact be any callable
        value, which is either a function, a class or a value with a
        <code>__call</code> metamethod.
        <br/><br/>
        You can query the metalist of any value using the
        <a href="#getmetalist"><code>getmetalist</code></a> function.
        CScript queries metamethods in metalists by indexing the list
        with predefined global values.
        <br/>
        Example:

        <pre>
    class Human { 
        __init() {
            self.name = "Human";
            return self;
        }
    }
    local ml = getmetalist(Human);  /* get 'Human' class metalist */
    local mm = ml[__init];  /* get __init metamethod */</pre>

        You can replace the metalist of a class using the
        <a href="#setmetalist"><code>setmetalist</code></a> function.
        You cannot change the metalist of other types from CScript code.
        <br/>
        Example:

        <pre>
    class Human {}
    local ml = [];  /* create list */
    ml[__init] = fn(self) {  /* set function under index __init */
        self.name = "Human";
        return self;
    };
    setmetalist(Human, ml);  /* set 'Human' class metalist */</pre>

        Classes and full userdata have individual metalists,
        although multiple classes and userdata can share their metalists.
        <br/><br/>
        A detailed list of operations controlled by metalist is given next.
        By convention, all metamethod names used by CScript are composed by
        two underscores followed by lowercase Latin letters.
        <ul>
            <li>
                <b><code>__add</code>: </b>
                the addition (<code>+</code>) operation.
                If any operand for an addition is not a number,
                CScript will try to call a metamethod.
                It first checks that the types of the operands match.
                Then if the operands are instances, it checks if they are
                the instances of the same class, and finally it checks for
                the presence of <code>__add</code> in that class.
                In case operands are full userdata, then it only checks for
                the presence of <code>__add</code>.
                If the metamethod is found, it will call it with the two
                operands as arguments (order of operands is left intact).
                It returns a single result, otherwise, if no metamethod is
                found, or the conditions mentioned above do not hold, CScript
                raises an error.
            </li>
            <li>
                <b><code>__sub</code>: </b>
                the subtraction (<code>-</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mul</code>: </b>
                the multiplication (<code>*</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__div</code>: </b>
                the float division (<code>/</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__idiv</code>: </b>
                the integer division (<code>//</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mod</code>: </b>
                the modulo (<code>%</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__pow</code>: </b>
                the exponentiation (<code>**</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__unm</code>: </b>
                the negation (unary <code>-</code>) operation.
                Behavior similar to the addition operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__band</code>: </b>
                the bitwise AND (<code>&amp;</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod if any operand is neither
                an integer nor a float coercible to an integer
                (see <a href="#3.4.3">&sect;3.4.3</a>).
            </li>
            <li>
                <b><code>__bor</code>: </b>
                the bitwise OR (<code>|</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bxor</code>: </b>
                the bitwise exclusive OR (binary <code>^</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bnot</code>: </b>
                the bitwise NOT (unary <code>~</code>) operation.
                Behavior similar to the bitwise AND operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__shl</code>: </b>
                the bitwise left shift (<code>&lt;&lt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__shr</code>: </b>
                the bitwise right shift (<code>&gt;&gt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__concat</code>: </b>
                the concatenation (<code>..</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod if either operand is not
                a string.
            </li>
            <li>
                <b><code>__eq</code>: </b>
                the equal (<code>==</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod only when the values being
                compared are either both instances or both full userdata
                and they are not primitively equal.
                The result of the call is always converted to a boolean.
            </li>
            <li>
                <b><code>__lt</code>: </b>
                the less than (<code>&lt;</code>) operation.
                Behavior similar to the addition operation,
                except that CScript will try a metamethod only when the
                values being compared are neither both numbers nor both
                strings.
                Moreover, the result of the call is always converted to
                a boolean.
            </li>
            <li>
                <b><code>__le</code>: </b>
                the less equal (<code>&lt;=</code>) operation.
                Behavior similar to the less than operation.
            </li>
            <li>
                <b><code>__getidx</code>: </b>
                The indexing access operation <code>v[key]</code>.
                This event happens when value <code>v</code> is an instance
                or full userdata that implements this metamethod.
                <br/><br/>
                This function is called with <code>v</code> and
                <code>key</code> as arguments, and returns a single result.
            </li>
            <li>
                <b><code>__setidx</code>: </b>
                The indexing assignment <code>v[key] = value</code>.
                Like the <code>__getidx</code> event, this event happens
                when value <code>v</code> is an instance or full userdata
                that implements this metamethod.
                <br/><br/>
                This function is called with <code>v</code>, <code>key</code>
                and <code>value</code> as arguments, and returns no results.
            </li>
            <li>
                <b><code>__call</code>: </b>
                The call operation <code>func(args)</code>.
                This event happens when CScript tries to call a value that
                is neither a function nor class.
                The metamethod is looked up in <code>func</code>.
                If present, the metamethod is called with <code>func</code>
                as its first argument, followed by the arguments of the
                original call (<code>args</code>).
                All results of the call are the results of the operation.
                This is the only metamethod that allows multiple results.
            </li>
            <li>
                <b><code>__init</code>: </b>
                This is special metamethod only used when calling class
                values. This event occurs when class value is called,
                such as <code>MyClass()</code> (where <code>MyClass</code>
                is a class value).
                If present, instance of the class being called is passed
                as the argument to this function.
                This function returns a single result.
                Usually this is used as the way to initialize the instance
                (as the name suggests).
                Keep in mind that <code>__init</code> can still be set for
                full userdata, but it will never trigger, so setting it is
                useless.
            </li>
        </ul>
        In addition to the previous list, the interpreter also implements
        the following events:
        <code>__gc</code> (see <a href="#2.5.2">&sect;2.5.2</a>) and
        <code>__close</code> (see <a href="#3.3.8">&sect;3.3.8</a>)
        </p>


        <h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>
        <p>
        CScript performs automatic memory management.
        This means that you do not have to worry about allocating memory
        for new objects or freeing it when the objects are no longer needed.
        CScript manages memory automatically by running a
        <em>garbage collector</em> to collect all <em>dead</em> objects.
        All memory used by CScript is subject to automatic management:
        strings, tables, lists, userdata, functions, threads, classes,
        instances, internal structures, etc.
        <br/><br/>
        An object is considered <em>dead</em> as soon as the collector
        can be sure the object will not be accessed again in the normal
        execution of the program.
        ("Normal execution" here excludes finalizers, which can resurrect
        dead objects (see <a href="#2.5.3">&sect;2.5.3</a>).)
        Note that the time when the collector can be sure that an object
        is dead may not coincide with the programmer's expectations.
        The only guarantees are that CScript will not collect an object
        that may still be accessed in the normal execution of the program,
        and it will eventually collect an object that is inaccessible from
        CScript.
        (Here, <em>inaccessible from CScript</em> means that neither a
        variable nor another live object refer to the object.)
        Because CScript has no knowledge about C&nbsp;code, it never
        collects objects accessible through the registry
        (see <a href="#4.3">&sect;4.3</a>), which includes the global table
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        The garbage collector (GC) in CScript is incremental.
        <br/><br/>
        Default GC parameters are adequate for most uses.
        However, programs that waste a large proportion of their time
        allocating and freeing memory can benefit from other settings.
        Keep in mind that the GC behavior is non-portable both across
        platforms and across different CScript releases; therefore,
        optimal settings are also non-portable.
        <br/><br/>
        You can change the GC parameters by calling
        <a href="#cs_gc"><code>cs_gc</code></a> in&nbsp;C or
        <a href="#gc"><code>gc</code></a> in CScript.
        You can also use these functions to control the collector directly
        (e.g., to stop and restart it).
        </p>


        <h3>2.5.1 &ndash; <a name="2.5.1">Incremental Garbage Collection</a></h3>
        <p>
        In incremental mode, each GC cycle performs a mark-and-sweep
        collection in small steps interleaved with the program's execution.
        In this mode, the collector uses three numbers to control its
        garbage-collection cycles:
        the <em>garbage-collector pause</em>,
        the <em>garbage-collector step multiplier</em>,
        and the <em>garbage-collector step size</em>.
        <br/><br/>
        The garbage-collector pause controls how long the collector waits
        before starting a new cycle.
        The collector starts a new cycle when the use of memory hits
        <em>n%</em> of the use after the previous collection.
        Larger values make the collector less aggressive.
        Values equal to or less than 100 mean the collector will not wait
        to start a new cycle.
        A value of 200 means that the collector waits for the total memory
        in use to double before starting a new cycle.
        The default value is 200; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step multiplier controls the speed of the
        collector relative to memory allocation, that is, how many elements
        it marks or sweeps for each kilobyte of memory allocated.
        Larger values make the collector more aggressive but also increase
        the size of each incremental step.
        You should not use values less than 100, because they make the
        collector too slow and can result in the collector never finishing
        a cycle.
        The default value is 100; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step size controls the size of each incremental
        step, specifically how many bytes the interpreter allocates before
        performing a step.
        This parameter is logarithmic:
        A value of <em>n</em> means the interpreter will allocate
        <em>2<sup>n</sup></em> bytes between steps and perform equivalent
        work during the step.
        A large value (e.g., 60) makes the collector a stop-the-world
        (non-incremental) collector.
        The default value is 13, which means steps of approximately
        8&nbsp;Kbytes.


        <h3>2.5.2 &ndash; <a name="2.5.2">Garbage-Collection Metamethods</a></h3>
        <p>
        You can set garbage-collector metamethods for classes and, using the
        C&nbsp;API, for full userdata (see <a href="#2.4">&sect;2.4</a>).
        These metamethods, called <em>finalizers</em>, are called when
        the garbage collector detects that the corresponding instance or
        userdata is dead.
        Finalizers allow you to coordinate CScript's garbage collection
        with external resource management such as closing files, network
        or database connections, or freeing your own memory.
        <br/><br/>
        For an object (instance or userdata) to be finalized when collected,
        you must <em>mark</em> it for finalization.
        You mark an object for finalization when you set its metalist and
        metalist has <code>__gc</code> metamethod.
        Note that if you set a metalist without setting <code>__gc</code>
        index and later set that index in the metalist, the object will
        not be marked for finalization.
        <br/><br/>
        When a marked object becomes dead, it is not collected immediately
        by the garbage collector.
        Instead, CScript puts it in a (linked)list.
        After the collection, CScript goes through that list.
        For each object in the list, it checks the object's
        <code>__gc</code> metamethod:
        If it is present, CScript calls it with the object as its single
        argument.
        <br/><br/>
        At the end of each garbage-collection cycle, the finalizers are
        called in the reverse order that the objects were marked for
        finalization, among those collected in that cycle;
        that is, the first finalizer to be called is the one associated
        with the object marked last in the program.
        The execution of each finalizer may occur at any point during
        the execution of the regular code.
        <br/><br/>
        Because the object being collected must still be used by the finalizer,
        that object (and other objects accessible only through it) must be
        <em>resurrected</em> by CScript.
        Usually, this resurrection is transient, and the object memory is
        freed in the next garbage-collection cycle.
        However, if the finalizer stores the object in some global place
        (e.g., a global variable), then the resurrection is permanent.
        Moreover, if the finalizer marks a finalizing object for finalization
        again, its finalizer will be called again in the next cycle where
        the object is dead.
        In any case, the object memory is freed only in a GC cycle where
        the object is dead and not marked for finalization.
        <br/><br/>
        When you close a state
        (see <a href="#cs_close"><code>cs_close</code></a>), CScript calls
        the finalizers of all objects marked for finalization,
        following the reverse order that they were marked.
        If any finalizer marks objects for collection during that phase,
        these marks have no effect.
        <br/><br/>
        Finalizers cannot run the garbage collector.
        Because they can run in unpredictable times, it is good practice
        to restrict each finalizer to the minimum necessary to properly
        release its associated resource.
        <br/><br/>
        Any error while running a finalizer generates a warning;
        the error is not propagated.
        </p>




        <h1>3 &ndash; <a name="3">The Language</h1>
        <p>
        This section describes the lexis, the syntax, and the semantics
        of CScript.
        In other words, this section describes which tokens are valid,
        how they can be combined, and what their combinations mean.
        <br/><br/>
        Language constructs will be explained using the usual extended
        BNF notation, in which
        {<em>a</em>}&nbsp;means&nbsp;0 or more <em>a</em>'s, and
        [<em>a</em>]&nbsp;means an optional <em>a</em>.
        Non-terminals are shown like non-terminal, keywords are shown
        like <b>kword</b>, and other terminal symbols are shown like
        &lsquo;<b>=</b>&rsquo;.
        The complete syntax of CScript can be found in
        <a href="#9">&sect;9</a> at the end of this manual.
        </p>


        <h2>3.1 &ndash; <a name="3.1">Lexical Conventions</a></h2>
        <p>
        CScript is a free-form language.
        It ignores spaces and comments between lexical elements (tokens),
        except as delimiters between two tokens.
        In source code, CScript recognizes as spaces the standard ASCII
        whitespace characters space, form feed, newline, carriage return,
        horizontal tab, and vertical tab.
        The language tries its best to mimic C syntax, hence the "C" in
        "CScript".
        <br/><br/>
        <em>Names</em> (also called <em>identifiers</em>) in CScript can be
        any string of Latin letters, Arabic-Indic digits, and underscores,
        not beginning with a digit and not being a reserved word.
        Identifiers are used to name variables, tablea fields and instance
        fields.
        <br/><br/>
        The following <em>keywords</em> are reserved and cannot be used as
        names:

        <pre>
    and       or        break     continue  if        else
    false     true      for       foreach   in        while
    loop      fn        switch    case      default   class
    inherits  local     nil       super     return</pre>

        CScript is a case-sensitive language:
        <code>and</code> is a reserved word, but <code>And</code> and
        <code>AND</code> are two different, valid names.
        As a convention, programs should avoid creating names that start
        with two underscores followed by one or more uppercase letters
        (such as <a href="#VERSION"><code>__VERSION</code></a>).
        <br/><br/>
        The following strings denote other tokens:

        <pre>
    +     -     *     /     //    %     ^     !
    &amp;     ~     |     &lt;&lt;    &gt;&gt;    **
    ==    !=    &lt;=    &gt;=    &lt;     &gt;     =
    (     )     {     }     [     ]
    ;     ,     .     ..    ...</pre>

        A <em>short literal string</em> can be delimited by matching single
        or double quotes, and can contain the following C-like escape
        sequences:
        '<code>\a</code>' (bell),
        '<code>\b</code>' (backspace),
        '<code>\f</code>' (form feed),
        '<code>\n</code>' (newline),
        '<code>\r</code>' (carriage return),
        '<code>\t</code>' (horizontal tab),
        '<code>\v</code>' (vertical tab),
        '<code>\\</code>' (backslash),
        '<code>\"</code>' (quotation mark [double quote]),
        and '<code>\'</code>' (apostrophe [single quote]).
        A backslash followed by a line break results in a newline in the
        string.
        A short literal string cannot contain unescaped line breaks
        nor escapes not forming a valid escape sequence.
        <br/><br/>
        We can specify any byte in a short literal string, including
        embedded zeros, by its numeric value.
        This can be done with the escape sequence <code>\x<em>XX</em></code>,
        where <em>XX</em> is a sequence of exactly two hexadecimal digits,
        or with the escape sequence <code>\<em>ddd</em></code>,
        where <em>ddd</em> is a sequence of up to three decimal digits.
        (Note that if a decimal escape sequence is to be followed by a digit,
        it must be expressed using exactly three digits.)
        <br/><br/>
        The UTF-8 encoding of a Unicode character can be inserted in a
        literal string with the escape sequence <code>\u{<em>XXX</em>}</code>
        (with mandatory enclosing braces), where <em>XXX</em> is a sequence
        of one or more hexadecimal digits representing the character code
        point.
        This code point can be any value less than <em>2<sup>31</sup></em>.
        (CScript uses the original UTF-8 specification here, which is not
        restricted to valid Unicode code points.)
        Additionally you can specify UTF-8 encoding with
        <code>\u[<em>XXX</em>]</code>, which is identical to the previous
        example but this will additionally check if the sequence is a
        valid Unicode code point and throw syntax error otherwise.
        <br/><br/>
        As an example, in a system using ASCII
        (in which '<code>a</code>' is coded as&nbsp;97, newline is coded
        as&nbsp;10, and '<code>1</code>' is coded as&nbsp;49), the two
        literal strings below denote the same string:

        <pre>
     a = "alo\n123\""
     a = "\97lo\10\04923\""</pre>

        Any byte in a literal string not explicitly affected by the
        previous rules represents itself.
        However, CScript opens files for parsing in text mode, and the
        system's file functions may have problems with some control
        characters.
        So, it is safer to represent binary data as a quoted literal with
        explicit escape sequences for the non-text characters.
        <br/><br/>
        A <em>numeric constant</em> (or <em>numeral</em>) can be written
        with an optional fractional part and an optional decimal exponent,
        marked by a letter '<code>e</code>' or '<code>E</code>'.
        CScript also accepts hexadecimal constants, which start with
        <code>0x</code> or <code>0X</code>, and octal constants, which
        start with <code>0</code>.
        A <em>constant</em> <code>inf</code> or <code>infinity</code>
        represent positive infinity (putting '<code>-</code>' in front denotes
        negative infinity).
        Additionally all <em>numeric constants</em> can have '<code>_</code>'
        in between digits, this acts as a separator, however this separator is
        not allowed in fractional part.
        Hexadecimal constants also accept an optional fractional part
        plus an optional binary exponent, marked by a letter
        '<code>p</code>' or '<code>P</code>' and written in decimal.
        (For instance, <code>0x1.fp10</code> denotes 1984,
        which is <em>0x1f / 16</em> multiplied by <em>2<sup>10</sup></em>.)
        Hexadecimal constants that have the fractional part, must also have
        the binary exponent.
        If you wish to declare a hexadecimal float constant, but do not
        need the binary exponent, you can just set the binary exponent to
        <code>p0</code> or <code>P0</code>
        (which is <em>2<sup>0</sup> == 1</em>).
        <br/><br/>
        A numeric constant with a radix point or an exponent denotes a float;
        otherwise, if its value fits in an integer or it is a hexadecimal or
        octal constant, it denotes an integer.
        Hexadecimal numerals with neither a radix point nor an exponent
        always denote an integer value.
        If the <em>numeric constant</em> overflows or underflows, CScript
        throws an error.
        <br/><br/>
        Examples of valid integer constants are

        <pre>
    3   345   0xff   0xBEBADA   015   000</pre>

        Examples of valid float constants are

        <pre>
    3.0      3.1416      .153      14.16e-2      0.31416E1      34e1
    0x.1Ep0  0xA23p-4    0X1.921FB54442D18P+1
    inf      infinity</pre>

        A <em>short comment</em> starts with a pound sign (<code>#</code>)
        and runs until the end of the line.
        A <em>long comment</em> starts with a forward slash and
        asterisk sign (<code>/*</code>) and is delimited by asterisk sign and
        forward slash (<code>*/</code>).
        These <em>comments</em> are valid anywhere outside of a string.


        <h2>3.2 &ndash; <a name="3.2">Variables</a></h2>
        <p>
        Variables are places that store values.
        There are three kinds of variables in CScript:
        global variables, local variables, table keys and instance fields.
        <br/><br/>
        A single name can denote a global variable or a local variable
        (or a function's formal parameter, which is a particular kind
        of local variable):

        <pre>
    var ::= Name</pre>

        Name denotes identifiers (see <a href="#3.1">&sect;3.1</a>).
        <br/><br/>
        Any variable name is assumed to be global unless explicitly declared
        as a local (see <a href="#3.3.7">&sect;3.3.7</a>).
        Local variables are <em>lexically scoped</em>:
        local variables can be freely accessed by functions
        defined inside their scope (see <a href="#3.5">&sect;3.5</a>).
        <br/><br/>
        Before the first assignment to a variable, its value is <b>nil</b>.
        <br/><br/>
        Square brackets are used to index a table, list or instance:

        <pre>
    var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;</pre>

        The meaning of accesses to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The syntax <code>var.Name</code> is just syntactic sugar for
        <code>var["Name"]</code>:

        <pre>
    var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name</pre>
        </p>


        <h2>3.3 &ndash; <a name="3.3">Statements</a></h2>
        <p>
        CScript supports almost identical set of statements as found in C.
        This set includes blocks, assignments, control structures,
        function calls and variable declarations.
        </p>


        <h3>3.3.1 &ndash; <a name="3.3.1">Blocks</a></h3>
        <p>
        A block is a list of statements with its own scope enclosed in between
        curly braces.
        These statements are executed sequentially:

        <pre>
    block ::= &lsquo;<b>{</b>&rsquo; {stm} &lsquo;<b>}</b>&rsquo;</pre>
        </p>


        <h3>3.3.2 &ndash; <a name="3.3.2">Chunks</a></h3>
        <p>
        The unit of compilation of CScript is called a <em>chunk</em>.
        Syntactically, a chunk is simply a block without curly braces:

        <pre>
    chunk ::= {stm}</pre>

        CScript handles a chunk as the body of an anonymous function
        with a variable number of arguments
        (see <a href="#3.4.11">&sect;3.4.11</a>).
        As such, chunks can define local variables, receive arguments,
        and return values.
        Moreover, such anonymous function is compiled as in the global scope
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        A chunk can be stored in a file or in a string inside the host program.
        To execute a chunk, CScript first <em>loads</em> it, precompiling the
        chunk's code into instructions for a virtual machine, and then CScript
        executes the compiled code with an interpreter for the virtual machine.
        </p>


        <h3>3.3.3 &ndash; <a name="3.3.3">Assignment</a></h3>
        <p>
        CScript allows multiple assignments.
        Therefore, the syntax for assignment defines a list of variables
        on the left side and a list of expressions on the right side.
        The elements in both lists are separated by commas and terminated
        by a semicolon:

        <pre>
    stm ::= varlist &lsquo;<b>=</b>&rsquo; explist &lsquo;<b>;</b>&rsquo;
    varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
    explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}</pre>

        Expressions are discussed in <a href="#3.4">&sect;3.4</a>.
        <br/><br/>
        Before the assignment,
        the list of values is <em>adjusted</em> to the length of
        the list of variables (see <a href="#3.4.12">&sect;3.4.12</a>).
        <br/><br/>
        If a variable is both assigned and read inside a multiple assignment,
        CScript ensures that all reads get the value of the variable
        before the assignment.
        Thus the code

        <pre>
    i = 3
    i, a[i] = i+1, 20</pre>

        sets <code>a[3]</code> to 20, without affecting <code>a[4]</code>
        because the <code>i</code> in <code>a[i]</code> is evaluated (to 3)
        before it is assigned&nbsp;4.
        Similarly, the line

        <pre>
     x, y = y, x</pre>

        exchanges the values of <code>x</code> and <code>y</code>,
        and

        <pre>
     x, y, z = y, z, x</pre>

        cyclically permutes the values of <code>x</code>, <code>y</code>
        and <code>z</code>.
        <br/><br/>
        Note that this guarantee covers only accesses syntactically inside
        the assignment statement.
        If a function or a metamethod called during the assignment
        changes the value of a variable, CScript gives no guarantees about
        the order of that access.
        <br/><br/>
        The meaning of assignments to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        </p>


        <h3>3.3.4 &ndash; <a name="3.3.4">Control Structures</a></h3>
        <p>
        The control structures
        <b>if</b>, <b>while</b>, <b>for</b> and <b>loop</b> have the usual
        meaning and familiar syntax:

        <pre>
    stm ::= <b>while</b> &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; stm
    stm ::= <b>for</b> &lsquo;<b>(</b>&rsquo; {localstm | exprstm} &lsquo;<b>;</b>&rsquo; {exp} &lsquo;<b>;</b>&rsquo; {exprstm} &lsquo;<b>)</b>&rsquo; stm
    stm ::= <b>loop</b> stm
    stm ::= <b>if</b> &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; stm {<b>else</b> stm}</pre>

        CScript also has a <b>foreach</b> statement
        (see <a href="#3.3.5">&sect;3.3.5</a>).
        <br/><br/>
        The condition expression of a control structure can return any value.
        Both <b>false</b> and <b>nil</b> test false.
        All values different from <b>nil</b> and <b>false</b> test true.
        In particular, the number 0 and the empty string also test true.
        <br/><br/>
        The <b>break</b> statement terminates the execution of a
        <b>while</b>, <b>repeat</b>, or <b>for</b> loop,
        skipping to the next statement after the loop:

        <pre>
    stm ::= <b>break</b> &lsquo;<b>;</b>&rsquo;</pre>

        A <b>break</b> ends the innermost enclosing loop.
        <br/><br/>
        The <b>continue</b> statement is used to skip the current iteration
        and proceed to the next iteration of the loop:

        <pre>
    stm ::= <b>continue</b> &lsquo;<b>;</b>&rsquo;</pre>

        When a <b>continue</b> statement is encountered, the remaining
        statements in the loop body are skipped, and control is transferred
        to the loop's next iteration.
        <br/><br/>
        The <b>return</b> statement is used to return values from a function
        or a chunk (which is handled as an anonymous function).
        Functions can return more than one value, so the syntax for the
        <b>return</b> statement is

        <pre>
    stm ::= <b>return</b> [explist] &lsquo;<b>;</b>&rsquo;</pre>

        The <b>return</b> statement can only be written as the last statement
        of a block or a chunk.
        If it is necessary to <b>return</b> in the middle of a block,
        then an explicit inner block can be used: <code>{ return; }</code>,
        because now <b>return</b> is the last statement in its (inner) block.
        </p>


        <h3>3.3.5 &ndash; <a name="3.3.5">Foreach Statement</a></h3>
        <p>
        The <b>foreach</b> statement is a generic loop.
        This statement works over functions, called <em>iterators</em>.
        On each iteration, the iterator function is called to produce a new
        value, stopping when this new value is <b>nil</b>.
        The generic <b>foreach</b> loop has the following syntax:

        <pre>
    stm ::= <b>foreach</b> namelist <b>in</b> explist stm
    namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}</pre>

        A <b>foreach</b> statement like

        <pre>
    foreach <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> <em>body</em></pre>

        works as follows.
        <br/><br/>
        The names <em>var_i</em> declare loop variables local to the loop body.
        The first of these variables is the <em>control variable</em>.
        <br/><br/>
        The loop starts by evaluating <em>explist</em> to produce four values:
        an <em>iterator function</em>, a <em>state</em>, an initial value for
        the control variable, and a <em>closing value</em>.
        <br/><br/>
        Then, at each iteration, CScript calls the iterator function with
        two arguments: the state and the control variable.
        The results from this call are then assigned to the loop variables,
        following the rules of multiple assignments
        (see <a href="#3.3.3">&sect;3.3.3</a>).
        If the control variable becomes <b>nil</b>, the loop terminates.
        Otherwise, the body is executed and the loop goes to the next
        iteration.
        <br/><br/>
        The closing value behaves like a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>), which can be used to release
        resources when the loop ends.
        Otherwise, it does not interfere with the loop.
        <br/><br/>
        You should not change the value of the control variable
        during the loop.
        </p>


        <h3>3.3.6 &ndash; <a name="3.3.6">Function Calls as Statements</a></h3>
        <p>
        To allow possible side-effects,
        function calls can be executed as statements:

        <pre>
    stm ::= functioncall</pre>

        In this case, all returned values are thrown away.
        Function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>.
        </p>


        <h3>3.3.7 &ndash; <a name="3.3.7">Local Declarations</a></h3>
        <p>
        Local variables can be declared anywhere inside a block.
        The declaration can include an initialization:

        <pre>
    stm ::= <b>local</b> attnamelist [&lsquo;<b>=</b>&rsquo; explist] &lsquo;<b>;</b>&rsquo;
    attnamelist ::=  Name attrib {&lsquo;<b>,</b>&rsquo; Name attrib}</pre>

        If present, an initial assignment has the same semantics
        of a multiple assignment (see <a href="#3.3.3">&sect;3.3.3</a>).
        Otherwise, all variables are initialized with <b>nil</b>.
        <br/><br/>
        Each variable name may be postfixed by an attribute
        (a name between angle brackets):

        <pre>
    attrib ::= [&lsquo;<b>&lt;</b>&rsquo; Name &lsquo;<b>&gt;</b>&rsquo;]</pre>

        There are two possible attributes:
        <code>final</code>, which declares immutable variable, that is,
        a variable that cannot be assigned to after its initialization;
        and <code>close</code>, which declares a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        A list of variables can contain at most one to-be-closed variable.
        <br/><br/>
        A chunk is also a block (see <a href="#3.3.2">&sect;3.3.2</a>),
        and so local variables can be declared in a chunk outside any
        explicit block.
        <br/><br/>
        The visibility rules for local variables are explained in
        <a href="#3.5">&sect;3.5</a>.
        </p>


        <h3>3.3.8 &ndash; <a name="3.3.8">To-be-closed Variables</a></h3>
        <p>
        A to-be-closed variable behaves like an immutable local variable,
        except that its value is <em>closed</em> whenever the variable
        goes out of scope, including normal block termination,
        exiting its block by <b>break</b>/<b>continue</b>/<b>return</b>,
        or exiting by an error.
        <br/><br/>
        Here, to <em>close</em> a value means to call its
        <code>__close</code> metamethod.
        When calling the metamethod, the value itself is passed as the
        first argument and the error object that caused the exit (if any)
        is passed as a second argument;
        if there was no error, the second argument is <b>nil</b>.
        <br/><br/>
        The value assigned to a to-be-closed variable must have a
        <code>__close</code> metamethod or be a false value.
        (<b>nil</b> and <b>false</b> are ignored as to-be-closed values.)
        <br/><br/>
        If several to-be-closed variables go out of scope at the same event,
        they are closed in the reverse order that they were declared.
        <br/><br/>
        If there is any error while running a closing method, that error is
        handled like an error in the regular code where the variable was
        defined.
        After an error, the other pending closing methods will still be called.
        </p>


        <h2>3.4 &ndash; <a name="3.4">Expressions</a></h2>
        <p>
        The basic expressions in CScript are the following:

        <pre>
    exp ::= prefixexp
    exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
    exp ::= Numeral
    exp ::= LiteralString
    exp ::= functiondef
    exp ::= classdef
    exp ::= tableconstructor
    exp ::= listconstructor
    exp ::= &lsquo;<b>...</b>&rsquo;
    exp ::= exp binop exp
    exp ::= unop exp
    prefixexp ::= var | super | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;</pre>

        Numerals and literal strings are explained in
        <a href="#3.1">&sect;3.1</a>;
        variables are explained in <a href="#3.2">&sect;3.2</a>;
        function definitions are explained in
        <a href="#3.4.10">&sect;3.4.10</a>;
        function calls are explained in <a href="#3.4.9">&sect;3.4.9</a>;
        table and list constructors are explained in
        <a href="#3.4.8">&sect;3.4.8</a>.
        Vararg expressions, denoted by three dots ('<code>...</code>'),
        can only be used when directly inside a variadic function;
        they are explained in <a href="#3.4.11">&sect;3.4.11</a>.
        Class definitions and expressions with <code>super</code> keyword
        are explained in <a href="#3.4.12">&sect;3.4.12</a>.
        <br/><br/>
        Binary operators comprise arithmetic operators
        (see <a href="#3.4.1">&sect;3.4.1</a>), bitwise operators
        (see <a href="#3.4.2">&sect;3.4.2</a>), relational operators
        (see <a href="#3.4.4">&sect;3.4.4</a>), logical operators
        (see <a href="#3.4.5">&sect;3.4.5</a>), and the concatenation operator
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        Unary operators comprise the unary minus
        (see <a href="#3.4.1">&sect;3.4.1</a>), the unary bitwise NOT
        (see <a href="#3.4.2">&sect;3.4.2</a>) and the unary logical not
        (see <a href="#3.4.5">&sect;3.4.5</a>).
        </p>


        <h3>3.4.1 &ndash; <a name="3.4.1">Arithmetic Operators</a></h3>
        <p>
        CScript supports the following arithmetic operators:
        <ul>
            <li><b><code>+</code>: </b>addition</li>
            <li><b><code>-</code>: </b>subtraction</li>
            <li><b><code>*</code>: </b>multiplication</li>
            <li><b><code>/</code>: </b>float division</li>
            <li><b><code>//</code>: </b>integer division</li>
            <li><b><code>%</code>: </b>modulo</li>
            <li><b><code>**</code>: </b>exponentiation</li>
            <li><b><code>-</code>: </b>unary minus</li>
        </ul>
        With the exception of exponentiation and float division,
        the arithmetic operators work as follows:
        If both operands are integers, the operation is performed over
        integers and the result is an integer.
        Otherwise, if both operands are numbers, then they are converted to
        floats, the operation is performed following the machine's rules
        for floating-point arithmetic (usually the IEEE 754 standard),
        and the result is a float.
        <br/><br/>
        Exponentiation and float division (<code>/</code>) always convert
        their operands to floats and the result is always a float.
        Exponentiation uses the ISO&nbsp;C function <code>pow</code>,
        so that it works for non-integer exponents too.
        <br/><br/>
        Modulo is defined as the remainder of a division that rounds
        the quotient towards minus infinity (floor division).
        <br/><br/>
        In case of overflows in integer arithmetic, all operations
        <em>wrap around</em>.
        </p>


        <h3>3.4.2 &ndash; <a name="3.4.2">Bitwise Operators</a></h3>
        <p>
        CScript supports the following bitwise operators:
        <ul>
            <li><b><code>&amp;</code>: </b>bitwise AND</li>
            <li><b><code>|</code>: </b>bitwise OR</li>
            <li><b><code>^</code>: </b>bitwise exclusive OR (xor)</li>
            <li><b><code>&gt;&gt;</code>: </b>right shift</li>
            <li><b><code>&lt;&lt;</code>: </b>left shift</li>
            <li><b><code>~</code>: </b>unary bitwise NOT</li>
        </ul>
        All bitwise operations convert its operands to integers
        (see <a href="#3.4.3">&sect;3.4.3</a>), operate on all bits of
        those integers, and result in an integer.
        <br/><br/>
        Both right and left shifts fill the vacant bits with zeros.
        Negative displacements shift to the other direction;
        displacements with absolute values equal to or higher than
        the number of bits in an integer result in zero
        (as all bits are shifted out).
        </p>


        <h3>3.4.3 &ndash; <a name="3.4.3">Coercions and Conversions</a></h3>
        <p>
        CScript provides some automatic conversions between some
        types and representations at run time.
        Bitwise operators always convert float operands to integers.
        Exponentiation and float division always convert integer operands
        to floats.
        All other arithmetic operations applied to mixed numbers
        (integers and floats) convert the integer operand to a float.
        The C API also converts both integers to floats and
        floats to integers, as needed.
        <br/><br/>
        In a conversion from integer to float, if the integer value has an
        exact representation as a float, that is the result.
        Otherwise, the conversion gets the nearest higher or the nearest
        lower representable value.
        This kind of conversion never fails.
        <br/><br/>
        The conversion from float to integer checks whether the float has
        an exact representation as an integer
        (that is, the float has an integral value and it is in the range
        of integer representation).
        If it does, that representation is the result.
        Otherwise, the conversion fails.
        </p>


        <h3>3.4.4 &ndash; <a name="3.4.4">Relational Operators</a></h3>
        <p>
        CScript supports the following relational operators:
        <ul>
            <li><b><code>==</code>: </b>equality</li>
            <li><b><code>!=</code>: </b>inequality</li>
            <li><b><code>&lt;</code>: </b>less than</li>
            <li><b><code>&gt;</code>: </b>greater than</li>
            <li><b><code>&lt;=</code>: </b>less or equal</li>
            <li><b><code>&gt;=</code>: </b>greater or equal</li>
        </ul>
        These operators always result in <b>false</b> or <b>true</b>.
        <br/><br/>
        Equality (<code>==</code>) first compares the type of its operands.
        If the types are different, then the result is <b>false</b>.
        Otherwise, the values of the operands are compared.
        Strings are equal if they have the same byte content.
        Numbers are equal if they denote the same mathematical value.
        <br/><br/>
        Tables, lists, classes, instances, userdata, and threads are
        compared by reference:
        two objects are considered equal only if they are the same object.
        Every time you create a new object
        (a table, a list, a class, a instance, a userdata or a thread),
        this new object is different from any previously existing object.
        A function is always equal to itself.
        Functions with any detectable difference
        (different behavior, different definition) are always different.
        Functions created at different times but with no detectable
        differences may be classified as equal or not
        (depending on internal caching details).
        <br/><br/>
        You can change the way that CScript compares instances and
        full&nbsp;userdata by using the <code>__eq</code> metamethod
        (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The operator <code>!=</code> is exactly the negation of equality
        (<code>==</code>).
        <br/><br/>
        The order operators work as follows.
        If both arguments are numbers,
        then they are compared according to their mathematical values,
        regardless of their subtypes.
        Otherwise, if both arguments are strings,
        then their values are compared according to the current locale.
        Otherwise, CScript tries to call the <code>__lt</code> or the
        <code>__le</code> metamethod (see <a href="#2.4">&sect;2.4</a>).
        A comparison <code>a &gt; b</code> is translated to
        <code>b &lt; a</code> and <code>a &gt;= b</code> is translated to
        <code>b &lt;= a</code>.
        <br/><br/>
        Following the IEEE 754 standard, the special value NaN is considered
        neither less than, nor equal to, nor greater than any value,
        including itself.
        </p>


        <h3>3.4.5 &ndash; <a name="3.4.5">Logical Operators</a></h3>
        <p>
        The logical operators in CScript are <b>and</b>, <b>or</b> and
        <b>!</b>.
        Like the control structures (see <a href="#3.3.4">&sect;3.3.4</a>),
        all logical operators consider both <b>false</b> and <b>nil</b> as
        false and anything else as true.
        <br/><br/>
        The negation operator <b>!</b> always returns <b>false</b> or
        <b>true</b>.
        The conjunction operator <b>and</b> returns its first argument
        if this value is <b>false</b> or <b>nil</b>;
        otherwise, <b>and</b> returns its second argument.
        The disjunction operator <b>or</b> returns its first argument
        if this value is different from <b>nil</b> and <b>false</b>;
        otherwise, <b>or</b> returns its second argument.
        Both <b>and</b> and <b>or</b> use short-circuit evaluation;
        that is, the second operand is evaluated only if necessary.
        Here are some examples:

        <pre>
    10 or 20            --&gt; 10
    10 or error()       --&gt; 10
    nil or "a"          --&gt; "a"
    nil and 10          --&gt; nil
    false and error()   --&gt; false
    false and nil       --&gt; false
    false or nil        --&gt; nil
    10 and 20           --&gt; 20</pre>
        </p>


        <h3>3.4.6 &ndash; <a name="3.4.6">Concatenation</a></h3>
        <p>
        The string concatenation operator in CScript is
        denoted by two dots ('<code>..</code>').
        If any of the operands are not strings then the <code>__concat</code>
        metamethod is called (see <a href="#2.4">&sect;2.4</a>).
        </p>


        <h3>3.4.7 &ndash; <a name="3.4.7">Precedence</a></h3>
        <p>
        Operator precedence in CScript follows the table below,
        from lower to higher priority (it mimics operator precedence in C):

        <pre>
    or
    and
    |
    ^
    &amp;
    ==   !=
    &lt;    &lt;=   &gt;    &gt;=
    &lt;&lt;   &gt;&gt;
    ..
    +    -
    *    /    //    %
    unary operators (-    ~    !)
    **</pre>

        As usual, you can use parentheses to change the precedences of an
        expression.
        The concatenation ('<code>..</code>') and exponentiation
        ('<code>**</code>') operators are right associative.
        All other binary operators are left associative.
        </p>


        <h3>3.4.8 &ndash; <a name="3.4.8">Table and List Constructors</a></h3><p>
        Table and list constructors are expressions that create tables and
        lists.
        Every time a constructor is evaluated, a new list or table is created.
        A constructor can be used to create an empty table/list or to create
        an list/table and initialize some of its fields/elements.
        The general syntax for table constructors is

        <pre>
    tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
    fieldlist ::= field {fieldsep field} [fieldsep]
    field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp
    fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;</pre>

        Each field of the form <code>[exp1] = exp2</code> adds to the new
        table an entry with key <code>exp1</code> and value <code>exp2</code>.
        A field of the form <code>name = exp</code> is equivalent to
        <code>["name"] = exp</code>.
        For example,

        <pre>
    a = { [f(1)] = g; x = 5, ["y"] = 6; [30] = 23 };</pre>

        is equivalent to

        <pre>
    local t = {};
    t[f(1)] = g;
    t.x = 5;        // t["x"] = 5;
    t["y"] = 6;
    t[30] = 23;
    a = t;</pre>

        The general syntax for list constructors is:

        <pre>
    listconstructor ::= &lsquo;<b>[</b>&rsquo; [elementlist] &lsquo;<b>]</b>&rsquo;
    elementlist ::= exp {&lsquo;<b>,</b>&rsquo; exp} [&lsquo;<b>,</b>&rsquo;]</pre>

        Each expression in the elements list is equivalent to
        <code>[i] = exp</code>, where <code>i</code> are consecutive integers
        starting with 0.
        For example,

        <pre>
    a = [ 15, "okay", nil, true ];</pre>

        is equivalent to

        <pre>
    local aux = [];
    aux[0] = 15;
    aux[1] = "okay";
    aux[2] = nil;
    aux[3] = true;
    a = aux;
        </pre>

        The order of the assignments in any of the constructors is undefined.
        (This order would be relevant only when there are repeated keys being set.)
        <br/><br/>
        The field or element list can have an optional trailing separator,
        as a convenience for machine-generated code.
        </p>


        <h3>3.4.9 &ndash; <a name="3.4.9">Function Calls</a></h3>
        <p>
        A function call in CScript has the following syntax:

        <pre>
    functioncall ::= prefixexp &lsquo;<b>(</b>&rsquo; args &lsquo;<b>)</b>&rsquo;</pre>

        In a function call, first prefixexp and args are evaluated.
        <br/><br/>
        If the value of prefixexp has type <em>function</em>, then this
        function is called with the given arguments.
        <br/><br/>
        If the value of prefixexp has type <em>class</em>, then
        if <code>__init</code> metamethod of that class is present,
        it is called: its first and only argument is the instance of the class.
        If <code>__init</code> is not present, then calling a class directly
        returns the instance of that class (see <a href="#2.4">&sect;2.4</a>).
        In both cases all the provided arguments are discarded as they are
        not used, and a single result is returned, the instance.
        <br/><br/>
        Finally if prefixexp is not a <em>class</em> and a <em>function</em>,
        and <code>__call</code> metamethod is present, it is called:
        its first argument is the value of prefixexp, followed by the original
        call arguments (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        Arguments have the following syntax:

        <pre>
        args ::= [explist]</pre>

        All argument expressions are evaluated before the call.
        </p>


        <h3>3.4.10 &ndash; <a name="3.4.10">Function Definitions</a></h3>
        <p>
        The syntax for function definition is

        <pre>
        functiondef ::= <b>fn</b> funcbody
        funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; &lsquo;<b>{</b>&rsquo; block &lsquo;<b>}</b>&rsquo;</pre>

        The following syntactic sugar simplifies function definitions:

        <pre>
        stm ::= <b>fn</b> funcname funcbody
        stm ::= <b>local</b> <b>fn</b> Name funcbody
        funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name}</pre>

        The statement

        <pre>
    fn f() { <em>body</em> }</pre>

        translates to

        <pre>
     f = fn() { <em>body</em> };</pre>

        The statement

        <pre>
     fn t.a.b.c.f() { <em>body</em> }</pre>

        translates to

        <pre>
     t.a.b.c.f = fn() { <em>body</em> };</pre>

        The statement

        <pre>
     local fn f() { <em>body</em> }</pre>

        translates to

        <pre>
     local f; f = fn() { <em>body</em> };</pre>

        not to

        <pre>
     local f = fn() { <em>body</em> };</pre>

        (This only makes a difference when the body of the function
        contains references to <code>f</code>.)
        <br/><br/>
        A function definition is an executable expression, whose value has
        type <em>function</em>.
        When CScript precompiles a chunk, all its function bodies are
        precompiled too, but they are not created yet.
        Then, whenever CScript executes the function definition,
        the function is <em>instantiated</em> (or <em>closed</em>).
        This function instance, or <em>closure</em>, is the final value of
        the expression.
        <br/><br/>
        Parameters act as local variables that are initialized with the
        argument values:

        <pre>
    parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;</pre>

        When a CScript function is called, it adjusts its list of arguments to
        the length of its list of parameters
        (see <a href="#3.4.11">&sect;3.4.11</a>), unless the function is a
        <em>variadic function</em>, which is indicated by three dots
        ('<code>...</code>') at the end of its parameter list.
        A variadic function does not adjust its argument list;
        instead, it collects all extra arguments and supplies them
        to the function through a <em>vararg expression</em>,
        which is also written as three dots.
        The value of this expression is a list of all actual extra arguments,
        similar to a function with multiple results
        (see <a href="#3.4.11">&sect;3.4.11</a>).
        <br/><br/>
        As an example, consider the following definitions:

        <pre>
    fn f(a, b) {}
    fn g(a, b, ...) {}
    fn r() { return 1, 2, 3; }</pre>

        Then, we have the following mapping from arguments to parameters and
        to the vararg expression:

        <pre>
     CALL             PARAMETERS

     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2

     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3</pre>

        Results are returned using the <b>return</b> statement
        (see <a href="#3.3.4">&sect;3.3.4</a>).
        If control reaches the end of a function without encountering a
        <b>return</b> statement, then the function returns with no results.
        <br/><br/>
        CScript guarantees the number of values that a function may return
        is <em>2<sup>24</sup> - 1</em>.
        </p>


        <h3>3.4.11 &ndash; <a name="3.4.11">Lists of expressions, multiple results, and adjustment</a></h3>
        <p>
        Both function calls and vararg expressions can result in multiple
        values.
        These expressions are called <em>multires expressions</em>.
        <br/><br/>
        When a multires expression is used as the last element
        of a list of expressions, all results from the expression are
        added to the list of values produced by the list of expressions.
        Note that a single expression in a place that expects a list of
        expressions is the last expression in that (singleton) list.
        <br/><br/>
        These are the places where CScript expects a list of expressions:
        <ul>
            <li>
                A <b>return</b> statement,
                for instance <code>return e1, e2, e3;</code>
                (see <a href="#3.3.4">&sect;3.3.4</a>).
            </li>
            <li>
                An list constructor,
                for instance <code>[e1, e2, e3]</code>
                (see <a href="#3.4.8">&sect;3.4.8</a>).
            </li>
            <li>
                The arguments of a function call,
                for instance <code>foo(e1, e2, e3)</code>
                (see <a href="#3.4.9">&sect;3.4.9</a>).
            </li>
            <li>
                A multiple assignment,
                for instance <code>a, b, c = e1, e2, e3;</code>
                (see <a href="#3.3.3">&sect;3.3.3</a>).
            </li>
            <li>
                A local declaration,
                for instance <code>local a, b, c = e1, e2, e3;</code>
                (see <a href="#3.3.7">&sect;3.3.7</a>).
            </li>
            <li>
                The initial values in a generic <b>foreach</b> loop,
                for instance <code>foreach k in e1, e2, e3 { ... }</code>
                (see <a href="#3.3.5">&sect;3.3.5</a>).
            </li>
        </ul>
        In the last four cases, the list of values from the list of
        expressions must be <em>adjusted</em> to a specific length:
        the number of parameters in a call to a non-variadic function
        (see <a href="#3.4.10">&sect;3.4.10</a>), the number of variables
        in a multiple assignment or a local declaration, and exactly four
        values for a generic <b>foreach</b> loop.
        The <em>adjustment</em> follows these rules:
        If there are more values than needed,
        the extra values are thrown away;
        if there are fewer values than needed,
        the list is extended with <b>nil</b>'s.
        When the list of expressions ends with a multires expression,
        all results from that expression enter the list of values
        before the adjustment.
        <br/><br/>
        When a multires expression is used in a list of expressions without
        being the last element, or in a place where the syntax expects a
        single expression, CScript adjusts the result list of that expression
        to one element.
        As a particular case, the syntax expects a single expression inside
        a parenthesized expression; therefore, adding parentheses around a
        multires expression forces it to produce exactly one result.
        <br/><br/>
        We rarely need to use a vararg expression in a place where the
        syntax expects a single expression.
        (Usually it is simpler to add a regular parameter before the
        variadic part and use that parameter.)
        When there is such a need, we recommend assigning the vararg
        expression to a single variable and using that variable in its place.
        <br/><br/>
        Here are some examples of uses of mutlres expressions.
        In all cases, when the construction needs
        "the n-th result" and there is no such result,
        it uses a <b>nil</b>.

        <pre>
    print(x, f())      -- prints x and all results from f().
    print(x, (f()))    -- prints x and the first result from f().
    print(f(), x)      -- prints the first result from f() and x.
    print(1 + f())     -- prints 1 added to the first result from f().
    local x = ...      -- x gets the first vararg argument.
    x,y = ...          -- x gets the first vararg argument,
                       -- y gets the second vararg argument.
    x,y,z = w, f()     -- x gets w, y gets the first result from f(),
                       -- z gets the second result from f().
    x,y,z = f()        -- x gets the first result from f(),
                       -- y gets the second result from f(),
                       -- z gets the third result from f().
    x,y,z = f(), g()   -- x gets the first result from f(),
                       -- y gets the first result from g(),
                       -- z gets the second result from g().
    x,y,z = (f())      -- x gets the first result from f(), y and z get nil.
    return f();        -- returns all results from f().
    return x, ...;     -- returns x and all received vararg arguments.
    return x,y,f();    -- returns x, y, and all results from f().
    [f()]              -- creates list with all results from f().
    [...]              -- creates list with all vararg arguments.
    [f(), 5]           -- creates list with the first result from f() and 5.</pre>
        </p>


        <h3>3.4.12 &ndash; <a name="3.4.12">Class Definitions and Instances</a></h3>
        <p>
        The syntax for class definition is

        <pre>
    classdef ::= <b>class</b> classbody
    classbody ::= [<b>inherits</b> supername] &lsquo;<b>{</b>&rsquo; {functiondef} &lsquo;<b>}</b>&rsquo;
    supername ::= Name {&lsquo;<b>.</b>&rsquo; Name}</pre>

        The following syntactic sugar simplifies class definitions:

        <pre>
    stm ::= <b>class</b> classname classbody
    stm ::= <b>local</b> <b>class</b> Name classbody 
    classname ::= Name {&lsquo;<b>.</b>&rsquo; Name}</pre>

        The statement

        <pre>
    class x {}</pre>

        translates to

        <pre>
    x = class {};</pre>

        The statement

        <pre>
    class x.y {}</pre>

        translates to

        <pre>
    x.y = class {};</pre>

        The statement

        <pre>
    local class x {}</pre>

        translates to

        <pre>
    local x;
    x = class {};</pre>

        not to

        <pre>
    local x = class {};</pre>

        (This is to enable usage of <code>self</code> local in the class
        methods.)
        <br/>
        The next chunk of code illustrates how inheritance works:

        <pre>
    class Vec2 {
        fn __init(x, y) {
            self.x = (x or 0);
            self.y = (y or 0);
            return self;
        }
        fn __add(rhs) {
            return getclass(self)(self.x + rhs.x, self.y + rhs.y);
        }
        fn name() {
            return "Vec2";
        }
    };
    local class x inherits Vec2 {
        fn name() {
            return "x{" .. super.name() .. "}";
        }
    }
    local vec = x(2, 3) + x(3, 3);
    assert(vec.x == 5 and vec.y == 6);
    assert(vec.name() == "x{Vec2}");</pre>

        Class methods always have the instance as the first argument.
        This argument is named <code>self</code> and it is hidden but
        accessible.
        Additionally if the class inherits from another class, then the local
        variable named <code>super</code> (which is also a keyword) is
        accessible for each method.
        This variable can access the superclass methods, but you can't
        use <code>super</code> in order to assign to the superclass.
        For example

        <pre>
    local class Empty {
        fn level() {
            return 0.0;
        }
    }
    local class HalfFull inherits Empty {
        fn level() {
            super.level = fn() { return 69; };
            return super.level() + 0.5;
        }
    }</pre>

        This would invoke an error, as you are trying to assign different
        value to <code>level</code> <em>property</em> of the superclass.
        We call it property instead of field, as classes do not have fields,
        only instances do.
        <br/><br/>
        Each time we call a class, we create a new instance of that class,
        unless class has <code>__init</code> which might return something
        else other than the instance (see <a href="#2.4">&sect;2.4</a>).
        Instances can call the methods class defines and can set/get
        <em>fields</em>. <em>fields</em> are similar to <em>keys</em> in a
        table. Instances are the combination of immutable class interface
        (<em>methods</em>) and a mutable state (<em>fields</em>).
        <br/>
        A field can shadow a method:

        <pre>
    local class Kek {
        fn lol() { return "kek"; }
    }
    local player = Kek();
    assert(typeof(player.lol) == "function");
    player.lol = "lol";
    assert(typeof(player.lol) == "string");
    assert(player.lol == "lol");</pre>

        In example above, when we index <code>player</code> such as
        <code>player.lol</code>, we get back the method called
        <em>bound method</em> (more on that shortly).
        However after we assign <code>player.lol</code> to a non-<b>nil</b>
        value we shadow the class <em>method</em> with the newly assigned
        value.
        (To access the <em>method</em> again, assign the field to <b>nil</b>.)
        <br/><br/>
        Methods returned by indexing the instance are called
        <em>bound methods</em>, as they are bound to the instance they
        belong to.
        This is necessary in order for the method to properly access its
        instance via <code>self</code> local variable.
        Each time you index a instance with a key that corresponds to the
        class method of the instance, you will create a <em>bound method</em>.
        This is not something you should actively think about, as these
        methods are indistinguishable from regular functions/methods as far
        as the user is concerned.
        </p>


        <h2>3.5 &ndash; <a name="3.5">Visibility Rules</a></h2>
        <p>
        CScript is a lexically scoped language.
        The scope of a local variable begins at the first statement after
        its declaration and lasts until the last non-empty statement
        of the innermost block that includes the declaration.
        Consider the following example:

        <pre>
    x = 10;                 // global variable
    {                       // new block
        local x = x;        // new 'x', with value 10
        print(x);           # --&gt; 10
        x = x+1;
        {                   // another block
            local x = x+1;  // another 'x'
            print(x);       # --&gt; 12
        }  
        print(x);           # --&gt; 11
    }  
    print(x);               # --&gt; 10  (the global one) </pre>

        Notice that, in a declaration like <code>local x = x;</code>,
        the new <code>x</code> being declared is not in scope yet,
        and so the second <code>x</code> refers to the outside variable.
        As a side note, in C the usage of outer <code>x</code> in the
        definition of new local variable <code>x</code> is not possible,
        and instead you would be using the uninitialized value of the
        <code>x</code> you are defining.
        <br/><br/>
        Because of the lexical scoping rules, local variables can be freely
        accessed by functions defined inside their scope.
        A local variable used by an inner function is called an
        <em>upvalue</em> (or <em>external local variable</em>, or simply
        <em>external variable</em>) inside the inner function.
        <br/><br/>
        Notice that each execution of a <b>local</b> statement defines new
        local variables.
        Consider the following example:

        <pre>
    a = [];
    local x = 20;
    for (local i = 1; i &lt; 11; i = i + 1) {
        local y = 0;
        a[i] = fn() { y = y + 1; return x + y; }
    }</pre>

        The loop creates ten closures
        (that is, ten instances of the anonymous function).
        Each of these closures uses a different <code>y</code> variable,
        while all of them share the same <code>x</code>.
        <br/><br/>
        Redefinition of the local variable is defined as defining a local
        variable with the same name as already defined local variable in the
        same scope.
        Redefinition of the local variables is <b>not allowed</b>.
        Consider the following example on what not to do:

        <pre>
    local x = 5;
    local x = 6;        // error: redefinition of local variable 'x'</pre>
        </p>


        <h1>4 &ndash; <a name="4">The Application Programming Interface</h1>
        <p>
        This section describes the C&nbsp;API for CScript, that is,
        the set of C&nbsp;functions available to the host program to
        communicate with CScript.
        All API functions and related types and constants are declared in
        the header file <a name="cscript.h"><code>cscript.h</code></a>.
        </br></br>
        Even when we use the term "function", any facility in the API may be
        provided as a macro instead.
        Except where stated otherwise, all such macros use each of their
        arguments exactly once (except for the first argument, which is always
        a CScript state), and so do not generate any hidden side-effects.
        </br></br>
        As in most C&nbsp;libraries, the CScript API functions do not check
        their arguments for validity or consistency.
        However, you can change this behavior by compiling CScript with the
        macro <a name="CS_USE_APICHECK"><code>CS_USE_APICHECK</code></a> defined.
        </br></br>
        The CScript library is fully reentrant: it has no global variables.
        It keeps all information it needs in a dynamic structure, called
        the <em>CScript state</em>.
        </br></br>
        Each CScript state has one or more threads, which correspond to
        independent, cooperative lines of execution.
        The type <a href="#cs_State"><code>cs_State</code></a> (despite its
        name) refers to a thread.
        (Indirectly, through the thread, it also refers to the CScript state
        associated to the thread.)
        </br></br>
        A pointer to a thread must be passed as the first argument to every
        function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates
        a CScript state from scratch and returns a pointer to the
        <em>main thread</em> in the new state.
        </p>


        <h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>
        <p>
        CScript uses a <em>virtual stack</em> to pass values to and from C.
        Each element in this stack represents a CScript value (<b>nil</b>,
        number, string, etc.).
        Functions in the API can access this stack through the CScript state
        parameter that they receive.
        <br/><br/>
        Whenever CScript calls C, the called function gets a new stack,
        which is independent of previous stacks and of stacks of
        C&nbsp;functions that are still active.
        This stack initially contains any arguments to the C&nbsp;function
        and it is where the C&nbsp;function can store temporary CScript
        values and must push its results to be returned to the caller
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        For convenience, most query operations in the API do not follow a
        strict stack discipline.
        Instead, they can refer to any element in the stack by using an
        <em>index</em>:
        A positive index represents an absolute stack position, starting
        at&nbsp;0 as the bottom of the stack;
        a negative index represents an offset relative to the top of the stack.
        More specifically, if the stack has <em>n</em> elements, then
        index&nbsp;0 represents the first element
        (that is, the element that was pushed onto the stack first)
        and index&nbsp;<em>n-1</em> represents the last element;
        index&nbsp;-1 also represents the last element
        (that is, the element at the&nbsp;top)
        and index <em>-n</em> represents the first element.
        </p>


        <h3>4.1.1 &ndash; <a name="4.1.1">Stack Size</a></h3>
        <p>
        When you interact with the CScript API, you are responsible for
        ensuring consistency.
        In particular,
        <em>you are responsible for controlling stack overflow</em>.
        When you call any API function, you must ensure the stack has enough
        room to accommodate the results.
        <br/><br/>
        There is one exception to the above rule:
        When you call a CScript function without a fixed number of results
        (see <a href="#cs_call"><code>cs_call</code></a>),
        CScript ensures that the stack has enough space for all results.
        However, it does not ensure any extra space.
        So, before pushing anything on the stack after such a call
        you should use <a href="#cs_checkstack"><code>cs_checkstack</code></a>.
        <br/><br/>
        Whenever CScript calls C, it ensures that the stack has space for at
        least <a name="CS_MINSTACK"><code>CS_MINSTACK</code></a> extra elements;
        that is, you can safely push up to <code>CS_MINSTACK</code> values into it.
        <code>CS_MINSTACK</code> is defined as 20, so that usually you do
        not have to worry about stack space unless your code has loops pushing
        elements onto the stack.
        Whenever necessary, you can use the function
        <a href="#cs_checkstack"><code>cs_checkstack</code></a> to ensure
        that the stack has enough space for pushing new elements.
        </p>


        <h3>4.1.2 &ndash; <a name="4.1.2">Valid and Acceptable Indices</a></h3>
        <p>
        Any function in the API that receives stack indices works only with
        <em>valid indices</em> or <em>acceptable indices</em>.
        <br/><br/>
        A <em>valid index</em> is an index that refers to a position that
        stores a modifiable CScript value.
        It comprises stack indices between&nbsp;0 and the stack top
        (<code>0 &le; abs(index) &lt; top</code>) plus <em>pseudo-indices</em>,
        which represent some positions that are accessible to C&nbsp;code
        but that are not in the stack.
        Pseudo-indices are used to access the registry (see <a href="#4.3">&sect;4.3</a>)
        and the upvalues of a C&nbsp;function (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Functions that do not need a specific mutable position, but only a
        value (e.g., query functions), can be called with acceptable indices.
        An <em>acceptable index</em> can be any valid index, but it also can
        be any positive index after the stack top within the space allocated
        for the stack, that is, indices up to the stack size (not inclusive).
        Indices to upvalues (see <a href="#4.2">&sect;4.2</a>) greater than
        the real number of upvalues in the current C&nbsp;function are also
        acceptable (but invalid).
        Except when noted otherwise, functions in the API work with acceptable
        indices.
        <br/><br/>
        Acceptable indices serve to avoid extra tests against the stack top
        when querying the stack.
        For instance, a C&nbsp;function can query its third argument without
        the need to check whether there is a third argument, that is, without
        the need to check whether 2 is a valid index.
        <br/><br/>
        For functions that can be called with acceptable indices, any
        non-valid index is treated as if it contains a value of a virtual
        type <a name="CS_TNONE"><code>CS_TNONE</code></a>, which behaves
        like a nil value.
        </p>


        <h3>4.1.3 &ndash; <a name="4.1.3">Pointers to strings</a></h3>
        <p>
        Several functions in the API return pointers (<code>const char*</code>)
        to CScript strings in the stack.
        (See <a href="#cs_pushfstring"><code>cs_push_fstring</code></a>,
        <a href="#cs_push_lstring"><code>cs_push_lstring</code></a>,
        <a href="#cs_push_string"><code>cs_push_string</code></a>,
        and <a href="#cs_to_lstring"><code>cs_to_lstring</code></a>.
        See also <a href="#csL_check_lstring"><code>csL_check_lstring</code></a>,
        <a href="#csL_check_string"><code>csL_check_string</code></a>,
        and <a href="#csL_to_lstring"><code>csL_to_lstring</code></a> in the
        auxiliary library.)
        <br/><br/>
        In general, CScript's garbage collection can free or move internal
        memory and then invalidate pointers to internal strings.
        To allow a safe use of these pointers, the API guarantees that any
        pointer to a string in a stack index is valid while the string value
        at that index is not removed from the stack.
        (It can be moved to another index, though.)
        When the index is a pseudo-index (referring to an upvalue), the
        pointer is valid while the corresponding call is active and the
        corresponding upvalue is not modified.
        <br/><br/>
        Some functions in the debug interface also return pointers to strings,
        namely <a href="#cs_getlocal"><code>cs_getlocal</code></a>,
        <a href="#cs_getupvalue"><code>cs_getupvalue</code></a>,
        <a href="#cs_setlocal"><code>cs_setlocal</code></a>,
        and <a href="#cs_setupvalue"><code>cs_setupvalue</code></a>.
        For these functions, the pointer is guaranteed to be valid while the
        caller function is active and the given closure (if one was given)
        is in the stack.
        <br/><br/>
        Except for these guarantees, the garbage collector is free to
        invalidate any pointer to internal strings.
        </p>


        <h2>4.2 &ndash; <a name="4.2">C Closures</a></h2>
        <p>
        When a C&nbsp;function is created, it is possible to associate
        some values with it, thus creating a <em>C&nbsp;closure</em>
        (see <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a>);
        these values are called <em>upvalues</em> and are accessible to the
        function whenever it is called.
        <br/><br/>
        Whenever a C&nbsp;function is called, its upvalues are located at
        specific pseudo-indices.
        These pseudo-indices are produced by the macro
        <a href="#cs_upvalueindex"><code>cs_upvalueindex</code></a>.
        The first upvalue associated with a function is at index
        <code>cs_upvalueindex(1)</code>, and so on.
        Any access to <code>cs_upvalueindex(<em>n</em>)</code>,
        where <em>n</em> is greater than the number of upvalues of the
        current function, produces an acceptable but invalid index.
        <br/><br/>
        A C&nbsp;closure can also change the values of its corresponding
        upvalues.
        </p>


        <h2>4.3 &ndash; <a name="4.3">Registry</a></h2>
        <p>
        CScript provides a <em>registry</em>, a predefined list that can be
        used by any C&nbsp;code to store whatever CScript values it needs to
        store.
        The registry list is always accessible at pseudo-index
        <a name="CS_REGISTRYINDEX"><code>CS_REGISTRYINDEX</code></a>.
        The indices in the <em>registry</em> are used by the reference
        mechanism (see <a href="#csL_ref"><code>csL_ref</code></a>) and by
        some predefined values.
        Therefore, indices in the registry must not be used for other
        purposes, meaning you should not manually set elements into the
        <em>registry</em>, instead you would use the reference mechanism.
        <br/><br/>
        When you create a new CScript state, its registry comes with some
        predefined values.
        These predefined values are indexed with indices defined as constants
        in <code>cscript.h</code>.
        The following constants are defined:
        <ul>
            <li>
                <b><a name="CS_RINDEX_MAINTHREAD"><code>CS_RINDEX_MAINTHREAD</code></a>:</b>
                At this index the registry has the main thread of the state.
                (The main thread is the one created together with the state.)
            </li>
            <li>
                <b><a name="CS_RINDEX_GLOBALS"><code>CS_RINDEX_GLOBALS</code></a>:</b>
                At this index the registry has the global table.
            </li>
            <li>
                <b><a name="CS_RINDEX_REGTABLE"><code>CS_RINDEX_REGTABLE</code></a>:</b>
                At this index the registry has the registry table.
                This table is usually used to store C libraries and values
                in order to protect that C code from CScript code.
                This serves as a query table for C libraries from your own
                C library, and therefore leaves the <em>registry</em> slots
                free for the reference mechanism.
                (Lua does the exact same thing, but since CScript distinguishes
                tables from lists, as such the registry must be complemented
                with its own registry table.)
            </li>
        </ul>
        The registry table is used for C&nbsp;libraries, and any C&nbsp;library
        can store data into this table, but it must take care to chose keys
        that are different from those used by other libraries, to avoid
        collisions.
        Typically, you should use as key a string containing your library name,
        or a light userdata with the address of a C&nbsp;object in your code,
        or any CScript object created by your code.
        As with variable names, string keys starting with an two consecutive
        underscore followed by uppercase letters are reserved for CScript.
        </p>


        <h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>
        <p>
        Internally, CScript uses the C <code>longjmp</code> facility to handle
        errors.
        When CScript faces any error, such as a memory allocation error or a
        type error, it <em>raises</em> an error; that is, it does a long jump.
        A <em>protected environment</em> uses <code>setjmp</code>
        to set a recovery point; any error jumps to the most recent active
        recovery point.
        <br/><br/>
        Inside a C&nbsp;function you can raise an error explicitly
        by calling <a href="#cs_error"><code>cs_error</code></a>.
        <br/><br/>
        Most functions in the API can raise an error, for instance due to
        a memory allocation error.
        The documentation for each function indicates whether it can raise
        errors.
        <br/><br/>
        If an error happens outside any protected environment, CScript calls
        a <em>panic function</em>
        (see <a href="#cs_atpanic"><code>cs_atpanic</code></a>)
        and then calls <code>abort</code>, thus exiting the host application.
        Your panic function can avoid this exit by never returning
        (e.g., doing a long jump to your own recovery point outside CScript).
        <br/><br/>
        The panic function, as its name implies, is a mechanism of last resort.
        Programs should avoid it.
        As a general rule, when a C&nbsp;function is called by CScript with a
        CScript state, it can do whatever it wants on that CScript state,
        as it should be already protected.
        However, when C code operates on other CScript states
        (e.g., a CScript-state argument to the function, a CScript state
        stored in the registry, or the result of
        <a href="#cs_newthread"><code>cs_newthread</code></a>),
        it should use them only in API calls that cannot raise errors.
        <br/><br/>
        The panic function runs as if it were a message handler
        (see <a href="#2.3">&sect;2.3</a>); in particular, the error object
        is on the top of the stack.
        However, there is no guarantee about stack space.
        To push anything on the stack, the panic function must first check
        the available space (see <a href="#4.1.1">&sect;4.1.1</a>).
        </p>


        <h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>
        <p>
        Several functions that report errors in the API use the following
        status codes to indicate different kinds of errors or other conditions:
        <ul>
            <li>
                <b><a name="CS_OK"><code>CS_OK</code></a> (0):</b>
                no errors.
            </li>
            <li>
                <b><a name="CS_ERRRUN"><code>CS_ERRRUNTIME</code></a>:</b>
                a runtime error.
            </li>
            <li>
                <b><a name="CS_ERRMEM"><code>CS_ERRMEM</code></a>: </b>
                memory allocation error.
                For such errors, CScript does not call the message handler.
            </li>
            <li>
                <b><a name="CS_ERRERR"><code>CS_ERRERROR</code></a>: </b>
                error while running the message handler.
            </li>
            <li>
                <b><a name="CS_ERRSYNTAX"><code>CS_ERRSYNTAX</code></a>:</b>
                syntax error during precompilation.</li>
            <li>
                <b><a name="CS_ERRFILE"><code>CS_ERRFILE</code></a>:</b>
                a file-related error;
                e.g., it cannot open or read the file.
            </li>
        </ul><p>
        These constants are defined in the header file <code>cscript.h</code>.
        </p>


        <h2>4.5 &ndash; <a name="4.5">Functions and Types</a></h2>
        <p>
        Here we list all functions and types from the C&nbsp;API.
        Each function has an indicator like this:
        <span class="apii">[-o, +p, <em>x</em>]</span>
        <br/><br/>
        The first field, <code>o</code>, is how many elements the function
        pops from the stack.
        The second field, <code>p</code>, is how many elements the function
        pushes onto the stack.
        (Any function always pushes its results after popping its arguments.)
        A field in the form <code>x|y</code> means the function can push
        (or pop) <code>x</code> or <code>y</code> elements, depending on
        the situation; an interrogation mark '<code>?</code>' means that
        we cannot know how many elements the function pops/pushes by looking
        only at its arguments.
        (For instance, they may depend on what is in the stack.)
        The third field, <code>x</code>, tells whether the function may raise errors:
        '<code>-</code>' means the function never raises any error;
        '<code>m</code>' means the function may raise only out-of-memory errors;
        '<code>v</code>' means the function may raise the errors explained in the text;
        '<code>e</code>' means the function can run arbitrary CScript code,
        either directly or through metamethods, and therefore may raise any
        errors.
        </p>

        <!-- cs_State -->
        <hr><h3><a name="cs_State"><code>cs_State</code></a></h3>
        <pre>typedef struct cs_State cs_State;</pre>
        <p>
        An opaque structure that points to a thread and indirectly
        (through the thread) to the whole state of a CScript interpreter.
        The CScript library is fully reentrant: it has no global variables.
        All information about a state is accessible through this structure.
        <br/><br/>
        A pointer to this structure must be passed as the first argument to
        every function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates a
        CScript state from scratch.
        </p>

        <!-- cs_Integer -->
        <hr><h3><a name="cs_Integer"><code>cs_Integer</code></a></h3>
        <pre>typedef ... cs_Integer;</pre>
        <p>
        The type of integers in CScript.
        <br/><br/>
        By default this type is <code>long long</code>,
        (usually a 64-bit two-complement integer),
        (See <code>CS_INT_TYPE</code> in <code>csconf.h</code>.)
        <br/><br/>
        CScript also defines the constants
        <a name="CS_INTEGER_MIN"><code>CS_INTEGER_MIN</code></a> and
        <a name="CS_INTEGER_MAX"><code>CS_INTEGER_MAX</code></a>,
        with the minimum and the maximum values that fit in this type.
        </p>

        <!-- cs_Unsigned -->
        <hr><h3><a name="cs_Unsigned"><code>cs_Unsigned</code></a></h3>
        <pre>typedef ... cs_Unsigned;</pre>
        <p>
        The unsigned version of <a href="#cs_Integer"><code>cs_Integer</code></a>.
        </p>

        <!-- cs_Number -->
        <hr><h3><a name="cs_Number"><code>cs_Number</code></a></h3>
        <pre>typedef ... cs_Number;</pre>
        <p>
        The type of floats in CScript.
        <br/><br/>
        By default this type is double, but that can be changed to a single
        float or a long double.
        (See <code>CS_FLOAT_TYPE</code> in <code>csconf.h</code>.)
        </p>

        <!-- cs_CFunction -->
        <hr><h3><a name="cs_CFunction"><code>cs_CFunction</code></a></h3>
        <pre>typedef int (*cs_CFunction) (cs_State *C);</pre>
        <p>
        Type for C&nbsp;functions.
        <br/><br/>
        In order to communicate properly with CScript, a C&nbsp;function
        must use the following protocol, which defines the way parameters and
        results are passed: a C&nbsp;function receives its arguments from
        CScript in its stack in direct order (the first argument is pushed first).
        So, when the function starts, <code>cs_getntop(C)</code> returns the
        number of arguments received by the function.
        The first argument (if any) is at index 0 and its last argument is at
        index <code>cs_gettop(C)</code>.
        To return values to CScript, a C&nbsp;function just pushes them onto
        the stack, in direct order (the first result is pushed first), and
        returns in C the number of results.
        Any other value in the stack below the results will be properly
        discarded by CScript.
        Like a CScript function, a C&nbsp;function called by CScript can also
        return many results.
        <br/><br/>
        As an example, the following function receives a variable number
        of numeric arguments and returns their average and their sum:
        <pre>
    static int foo (cs_State *C) {
        int n = cs_gettop(C);   /* index of last argument (or cs_getntop(C)-1) */
        cs_Number sum = 0.0;
        int i;
        for (i = 0; i &lt;= n; i++) {
            if (!cs_is_number(C, i)) {
                cs_push_literal(C, "incorrect argument");
                cs_error(C);
            }
            sum += cs_to_number(C, i);
        }
        cs_push_number(C, sum/n);       /* first result */
        cs_push_number(C, sum);         /* second result */
        return 2;                   /* number of results */
    }</pre>
        </p>

        <!-- cs_Alloc -->
        <hr><h3><a name="cs_Alloc"><code>cs_Alloc</code></a></h3>
        <pre>typedef void *(*cs_Alloc) (void *ptr,
                           size_t osz,
                           size_t nsz,
                           void *ud);</pre>
        <p>
        The type of the memory-allocation function used by CScript states.
        The allocator function must provide a functionality similar to
        <code>realloc</code>, but not exactly the same.
        Its arguments are <code>ud</code>, last argument that is an opaque
        pointer passed to <a href="#cs_newstate"><code>cs_newstate</code></a>;
        <code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
        <code>osz</code>, the original size of the block or some code about
        what is being allocated (such as a <a href="#cs_type">type</a> tag);
        and <code>nsz</code>, the new size of the block.
        <br/><br/>
        When <code>ptr</code> is not <code>NULL</code>, <code>osz</code> is
        the size of the block pointed by <code>ptr</code>, that is, the size
        given when it was allocated or reallocated.
        <br/><br/>
        When <code>ptr</code> is <code>NULL</code>, <code>osz</code> encodes
        the kind of object that CScript is allocating.
        <code>osz</code> is any of
        <a href="#CS_TUSERDATA"><code>CS_TUSERDATA</code></a>,
        <a href="#CS_TSTRING"><code>CS_TSTRING</code></a>,
        <a href="#CS_TLIST"><code>CS_TLIST</code></a>,
        <a href="#CS_TTABLE"><code>CS_TTABLE</code></a>,
        <a href="#CS_TFUNCTION"><code>CS_TFUNCTION</code></a>,
        <a href="#CS_TCLASS"><code>CS_TCLASS</code></a>,
        <a href="#CS_TINSTANCE"><code>CS_TINSTANCE</code></a>, or
        <a href="#CS_TTHREAD"><code>CS_TTHREAD</code></a> when
        (and only when) CScript is creating a new object of that type.
        When <code>osz</code> is some other value, CScript is allocating
        memory for something else.
        <br/><br/>
        CScript assumes the following behavior from the allocator function:
        <br/><br/>
        When <code>nsz</code> is zero, the allocator must behave like
        <code>free</code> and then return <code>NULL</code>.
        <br/><br/>
        When <code>nsz</code> is not zero, the allocator must behave like
        <code>realloc</code>.
        In particular, the allocator returns <code>NULL</code> if and only if
        it cannot fulfill the request.
        <br/><br/>
        Here is a simple implementation for the allocator function.
        It is used in the auxiliary library by
        <a href="#csL_newstate"><code>csL_newstate</code></a>.
        <pre>
    static void *allocator (void *ptr, size_t osz, size_t nsz, void *ud) {
        (void)ud;  (void)osz;  /* not used */
        if (nsz == 0) {
            free(ptr);
            return NULL;
        } else
            return realloc(ptr, nsz);
    }</pre>
        Note that ISO&nbsp;C ensures that <code>free(NULL)</code> has no
        effect and that <code>realloc(NULL,size)</code> is equivalent to
        <code>malloc(size)</code>.
        </p>

        <!-- cs_Reader -->
        <hr><h3><a name="cs_Reader"><code>cs_Reader</code></a></h3>
        <pre>typedef const char *(*cs_Reader) (cs_State *C,
                                  void *data,
                                  size_t *size);</pre>
        <p>
        The reader function used by <a href="#cs_load"><code>cs_load</code></a>.
        Every time <a href="#cs_load"><code>cs_load</code></a> needs another
        piece of the chunk, it calls the reader, passing along its
        <code>data</code> parameter.
        The reader must return a pointer to a block of memory with a new piece
        of the chunk and set <code>size</code> to the block size.
        The block must exist until the reader function is called again.
        To signal the end of the chunk, the reader must return
        <code>NULL</code> or set <code>size</code> to zero.
        The reader function may return pieces of any size greater than zero.
        </p>

        <!-- cs_WarnFunction -->
        <hr><h3><a name="cs_WarnFunction"><code>cs_WarnFunction</code></a></h3>
        <pre>typedef void (*cs_WarnFunction) (void *ud, const char *msg, int tocont);</pre>
        <p>
        The type of warning functions, called by CScript to emit warnings.
        The first parameter is an opaque pointer set by
        <a href="#cs_setwarnf"><code>cs_setwarnf</code></a>.
        The second parameter is the warning message.
        The third parameter is a boolean that indicates whether the message is
        to be continued by the message in the next call.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about
        warnings.
        </p>

        <!-- cs_Entry -->
        <hr><h3><a name="cs_Entry"><code>cs_Entry</code></a></h3>
        <pre>
    typedef struct cs_Entry {
        const char *name;
        cs_CFunction func;
    } cs_Entry;</pre>
        <p>
        Type for arrays of functions or methods to be set by
        <a href="#cs_push_class"><code>cs_push_class</code></a> family of
        functions or <a href="#csL_set_funcs"><code>csL_set_funcs</code></a>.
        Function name is <code>name</code> and <code>func</code> is a
        pointer to the function.
        Any array of <a href="#csL_Entry"><code>csL_Entry</code></a> must end
        with a sentinel entry in which both <code>name</code> and
        <code>func</code> are <code>NULL</code>.
        </p>

        <!-- cs_DebugInfo -->
        <hr><h3><a name="cs_DebugInfo"><code>cs_DebugInfo</code></a></h3>
        <pre>
    typedef struct cs_Debug {
        const char *name;           /* (n) */
        const char *namewhat;       /* (n) */
        const char *what;           /* (s) */
        const char *source;         /* (s) */
        size_t srclen;              /* (s) */
        int currline;               /* (l) */
        int defline;                /* (s) */
        int lastdefline;            /* (s) */
        int nupvals;                /* (u) number of upvalues */
        int nparams;                /* (u) number of parameters */
        char isvararg;              /* (u) */
        char shortsrc[CS_MAXSRC];   /* (s) */
        /* private part */
        <em>other fields</em>
    } cs_Debug;</pre>
        <p>
        A structure used to carry different pieces of information about a
        function or an activation record.
        <a href="#cs_getstack"><code>cs_getstack</code></a> fills only the
        private part of this structure, for later use.
        To fill the other fields of
        <a href="#cs_Debug"><code>cs_Debug</code></a> with useful information,
        you must call <a href="#cs_getinfo"><code>cs_getinfo</code></a> with
        an appropriate parameter. (Specifically, to get a field, you must add
        the letter between parentheses in the field's comment to the parameter
        <code>what</code> of <a href="#cs_getinfo"><code>cs_getinfo</code></a>.)
        <br/><br/>
        The fields of <a href="#cs_Debug"><code>cs_Debug</code></a> have the
        following meaning:
        <ul>
            <li>
                <b><code>source</code>: </b>
                the source of the chunk that created the function.
            </li>
            <li>
                <b><code>srclen</code>: </b>
                The length of the string <code>source</code>.
            </li>
            <li>
                <b><code>shortsrc</code>: </b>
                a "printable" version of <code>source</code>, to be used in
                error messages.
            </li>
            <li>
                <b><code>defline</code>: </b>
                the line number where the definition of the function starts.
            </li>
            <li>
                <b><code>lastdefline</code>: </b>
                the line number where the definition of the function ends.
            </li>
            <li>
                <b><code>what</code>: </b>
                the string <code>"CScript"</code> if the function is a CScript
                function, <code>"C"</code> if it is a C&nbsp;function,
                <code>"main"</code> if it is the main part of a chunk.
            </li>
            <li>
                <b><code>currline</code>: </b>
                the current line where the given function is executing.
            </li>
            <li>
                <b><code>name</code>: </b>
                a reasonable name for the given function.
                Because functions in CScript are first-class values, they do
                not have a fixed name: some functions can be the value of
                multiple global variables, while others can be stored only
                in a table field.
                The <code>cs_getinfo</code> function checks how the function
                was called to find a suitable name.
                If it cannot find a name, then <code>name</code> is set to
                <code>NULL</code>.
            </li>
            <li>
                <b><code>namewhat</code>: </b>
                explains the <code>name</code> field.
                The value of <code>namewhat</code> can be
                <code>"global"</code>, <code>"local"</code>,
                <code>"method"</code>, <code>"field"</code>,
                <code>"upvalue"</code>, or <code>""</code> (the empty string),
                according to how the function was called. (CScript uses the
                empty string when no other option seems to apply.)
                <br/>
                <b>NOTE:</b> only <code>"method"</code> works for now, this
                is until symbolic execution is implemented internally.
            </li>
            <li>
                <b><code>nupvals</code>: </b>
                the number of upvalues of the function.
            </li>
            <li>
                <b><code>nparams</code>: </b>
                the number of parameters of the function
                (always 0&nbsp;for C&nbsp;functions).
            </li>
            <li>
                <b><code>isvararg</code>: </b>
                true if the function is a variadic function
                (always true for C&nbsp;functions).
            </li>
        </ul>
        </p>

        <!-- cs_MM -->
        <hr><h3><a name="cs_MM"><code>cs_MM</code></a></h3>
        <pre>
    typedef enum cs_MM {
        CS_MM_GETIDX = 0,
        CS_MM_SETIDX,
        CS_MM_GC,
        CS_MM_CLOSE,
        CS_MM_CALL,
        CS_MM_CONCAT,
        CS_MM_ADD, 
        CS_MM_SUB,
        CS_MM_MUL,
        CS_MM_DIV,
        CS_MM_IDIV,
        CS_MM_MOD,
        CS_MM_POW,
        CS_MM_BSHL,
        CS_MM_BSHR,
        CS_MM_BAND,
        CS_MM_BOR,
        CS_MM_BXOR,
        CS_MM_UNM,
        CS_MM_BNOT,
        CS_MM_EQ,
        CS_MM_LT,
        CS_MM_LE,
        CS_MM_N, /* number of mm */
    } cs_MM;</pre>
        <p>
        These values correspond to each <a href="#Metamethods">metamethod</a>.
        They are indices into metalist</code></a>.
        Total number of metamethods is denoted by <code>CS_MM_N</code>.
        <br/><br/>
        For more information on metamethods see <a href="#2.4">&sect;2.4</a>.
        </p>

        <!-- cs_newstate -->
        <hr><h3><a name="cs_newstate"><code>cs_newstate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_newstate (cs_Alloc f, void *ud, unsigned int seed);</pre>
        <p>
        Creates a new independent state and returns its main thread.
        Returns <code>NULL</code> if it cannot create the state
        (due to lack of memory).
        The argument <code>f</code> is the allocator function;
        CScript will do all memory allocation for this state through this
        function (see <a href="#cs_Alloc"><code>cs_Alloc</code></a>).
        The second argument, <code>ud</code>, is an opaque pointer that
        CScript passes to the allocator in every call.
        The thrid argument <code>seed</code>, is a seed for the hashing
        of the strings.
        </p>

        <!-- cs_close -->
        <hr><h3><a name="cs_close"><code>cs_close</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_close (cs_State *C);</pre>
        <p>
        Close all active to-be-closed variables in the main thread,
        release all objects in the given CScript state
        (calling the corresponding garbage-collection metamethods, if any),
        and frees all dynamic memory used by this state.
        <br/><br/>
        On several platforms, you may not need to call this function,
        because all resources are naturally released when the host program ends.
        On the other hand, long-running programs that create multiple states,
        such as daemons or web servers, will probably need to close states as
        soon as they are not needed.
        </p>

        <!-- cs_newthread -->
        <hr><h3><a name="cs_newthread"><code>cs_newthread</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>cs_State *cs_newthread (cs_State *C);</pre>
        <p>
        Creates a new thread, pushes it on the stack,
        and returns a pointer to a <a href="#cs_State"><code>cs_State</code></a>
        that represents this new thread.
        The new thread returned by this function shares with the original
        thread its global environment, but has an independent execution stack.
        <br/><br/>
        Threads are subject to garbage collection, like any CScript object.
        </p>

        <!-- cs_resetthread -->
        <hr><h3><a name="cs_resetthread"><code>cs_resetthread</code></a></h3>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>int cs_resetthread (cs_State *C);</pre>
        <p>
        Resets a thread, cleaning its call stack and closing all pending
        to-be-closed variables.
        Returns a status code: <a href="#CS_OK"><code>CS_OK</code></a>
        for no errors in the thread (either the original error that stopped
        the thread or errors in closing methods), or an error status otherwise.
        In case of error, leaves the error object on the top of the stack.
        </p>

        <!-- cs_atpanic -->
        <hr><h3><a name="cs_atpanic"><code>cs_atpanic</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_CFunction cs_atpanic (cs_State *C, cs_CFunction panicf);</pre>
        <p>
        Sets a new panic function and returns the old one
        (see <a href="#4.4">&sect;4.4</a>).
        </p>

        <!-- cs_version -->
        <hr><h3><a name="cs_version"><code>cs_version</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_version (cs_State *C);</pre>
        <p>
        Returns the version number of this core.
        </p>

        <!-- cs_settop -->
        <hr><h3><a name="cs_settop"><code>cs_settop</code></a></h3>
        <span class="apii">[-?, +?, <em>e</em>]</span>
        <pre>void cs_settop (cs_State *C, int n);</pre>
        <p>
        Sets the stack top to hold <code>n</code> values on the stack.
        If the new top is greater than the old one, then the new elements are
        filled with <b>nil</b>.
        If <code>index</code> is&nbsp;0, then all stack elements are removed.
        If <code>index</code> is negative, then the new 
        <br/><br/>
        This function can run arbitrary code when removing an index
        marked as to-be-closed from the stack.
        </p>

        <!-- cs_gettop -->
        <hr><h3><a name="cs_gettop"><code>cs_gettop</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_gettop (cs_State *C);</pre>
        <p>
        Returns the index of the top element in the stack.
        This result is equal to the number of elements in the stack - 1;
        So return value of -1&nbsp;means an empty stack.
        </p>

        <!-- cs_absindex -->
        <hr><h3><a name="cs_absindex"><code>cs_absindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_absindex (cs_State *C, int index);</pre>
        <p>
        Converts the acceptable index <code>index</code> into an equivalent
        absolute index (that is, one that does not depend on the stack size).
        </p>

        <!-- cs_rotate -->
        <hr><h3><a name="cs_rotate"><code>cs_rotate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_rotate (cs_State *C, int index, int n);</pre>
        <p>
        Rotates the stack elements between the valid index <code>index</code>
        and the top of the stack.
        The elements are rotated <code>n</code> positions in the direction of
        the top, for a positive <code>n</code>, or <code>-n</code> positions
        in the direction of the bottom, for a negative <code>n</code>.
        The absolute value of <code>n</code> must not be greater than the size
        of the slice being rotated.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_copy -->
        <hr><h3><a name="cs_copy"><code>cs_copy</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_copy (cs_State *C, int src, int dest);</pre>
        <p>
        Copies the element at index <code>src</code> into the valid
        index <code>dest</code>, replacing the value at that position.
        Values at other positions are not affected.
        </p>

        <!-- cs_checkstack -->
        <hr><h3><a name="cs_checkstack"><code>cs_checkstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_checkstack (cs_State *C, int n);</pre>
        <p>
        Ensures that the stack has space for at least <code>n</code> extra
        elements, that is, that you can safely push up to <code>n</code>
        values into it.
        It returns false if it cannot fulfill the request, either because it
        would cause the stack to be greater than a fixed maximum size
        (typically at least several thousand elements) or because it cannot
        allocate memory for the extra space.
        This function never shrinks the stack; if the stack already has space
        for the extra elements, it is left unchanged.
        </p>

        <!-- cs_push -->
        <hr><h3><a name="cs_push"><code>cs_push</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push (cs_State *C, int index);</pre>
        <p>
        Pushes a copy of the element at the given index onto the stack.
        </p>

        <!-- cs_xmove -->
        <hr><h3><a name="cs_xmove"><code>cs_xmove</code></a></h3>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void cs_xmove (cs_State *src, cs_State *dest, int n);</pre>
        <p>
        Exchange values between different threads of the same state.
        <br/><br/>
        This function pops <code>n</code> values from the stack
        <code>src</code>, and pushes them onto the stack <code>dest</code>.
        </p>

        <!-- cs_is_number -->
        <hr><h3><a name="cs_is_number"><code>cs_is_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_number (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a number, and
        0&nbsp;otherwise.
        </p>

        <!-- cs_is_integer -->
        <hr><h3><a name="cs_is_integer"><code>cs_is_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_integer (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is an integer
        (that is, the value is a number and is represented as an integer),
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_string -->
        <hr><h3><a name="cs_is_string"><code>cs_is_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_string (cs_State *C);</pre>
        <p>
        </p>

        <!-- cs_is_cfunction -->
        <hr><h3><a name="cs_is_cfunction"><code>cs_is_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_is_cfunction (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a C&nbsp;function,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_userdata -->
        <hr><h3><a name="cs_is_userdata"><code>cs_is_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_userdata (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a userdata
        (either full or light), and 0&nbsp;otherwise.
        </p>

        <!-- cs_type -->
        <hr><h3><a name="cs_type"><code>cs_type</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_type (cs_State *C, int index);</pre>
        <p>
        Returns the type of the value in the given valid index,
        or <code>CS_TNONE</code> for a non-valid but acceptable index.
        The types returned by <a href="#cs_type"><code>cs_type</code></a>
        are coded by the following constants defined in <code>cscript.h</code>:
        <a name="CS_TNIL"><code>CS_TNIL</code></a>,
        <a name="CS_TBOOL"><code>CS_TBOOL</code></a>,
        <a name="CS_TNUMBER"><code>CS_TNUMBER</code></a>,
        <a name="CS_TUSERDATA"><code>CS_TUSERDATA</code></a>,
        <a name="CS_TLIGHTUSERDATA"><code>CS_TLIGHTUSERDATA</code></a>,
        <a name="CS_TSTRING"><code>CS_TSTRING</code></a>,
        <a name="CS_TLIST"><code>CS_TLIST</code></a>,
        <a name="CS_TTABLE"><code>CS_TTABLE</code></a>,
        <a name="CS_TFUNCTION"><code>CS_TFUNCTION</code></a>,
        <a name="CS_TCLASS"><code>CS_TCLASS</code></a>,
        <a name="CS_TINSTANCE"><code>CS_TINSTANCE</code></a>
        and <a name="CS_TTHREAD"><code>CS_TTHREAD</code></a>.
        </p>

        <!-- cs_typename -->
        <hr><h3><a name="cs_typename"><code>cs_typename</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_typename (cs_State *C, int type);</pre>
        <p>
        Returns the name of the type encoded by the value <code>type</code>,
        which must be one the values returned by
        <a href="#cs_type"><code>cs_type</code></a>.
        </p>

        <!-- cs_to_numberx -->
        <hr><h3><a name="cs_to_numberx"><code>cs_to_numberx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_to_numberx (cs_State *C, int index, int *isnum);</pre>
        <p>
        Converts the CScript value at the given index to the C&nbsp;type
        <a href="#cs_Number"><code>cs_Number</code></a>
        (see <a href="#cs_Number"><code>cs_Number</code></a>).
        The CScript value must be a number or a string convertible to a number
        (see <a href="#3.4.3">&sect;3.4.3</a>); otherwise,
        <a href="#cs_to_numberx"><code>cs_to_numberx</code></a>
        returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- cs_to_integerx -->
        <hr><h3><a name="cs_to_integerx"><code>cs_to_integerx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer cs_to_integerx (cs_State *C, int index, int *isnum);</pre>
        <p>
        Converts the CScript value at the given index
        to the signed integral type
        <a href="#cs_Integer"><code>cs_Integer</code></a>.
        The CScript value must be an integer, or a number or string
        convertible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>);
        otherwise, <code>cs_to_integerx</code> returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- cs_to_bool -->
        <hr><h3><a name="cs_to_bool"><code>cs_to_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_to_bool (cs_State *C, int index);</pre>
        <p>
        Converts the CScript value at the given index to a C&nbsp;boolean
        value (0&nbsp;or&nbsp;1).
        Like all tests in CScript,
        <a href="#cs_to_bool"><code>cs_to_bool</code></a>
        returns true for any CScript value different from <b>false</b> and
        <b>nil</b>; otherwise it returns false.
        (If you want to accept only actual boolean values,
        use <a href="#cs_is_bool"><code>cs_is_bool</code></a> to test the
        value's type.)
        </p>

        <!-- cs_to_lstring -->
        <hr><h3><a name="cs_to_lstring"><code>cs_to_lstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_to_lstring (cs_State *C, int index, size_t *len);</pre>
        <p>
        Converts the CScript value at the given index to a C&nbsp;string.
        If <code>len</code> is not <code>NULL</code>,
        it sets <code>*len</code> with the string length.
        The CScript value must be a string; otherwise, the function returns
        <code>NULL</code>.
        <br/><br/>
        <code>cs_to_lstring</code> returns a pointer to a string inside the
        CScript state (see <a href="#4.1.3">&sect;4.1.3</a>).
        This string always has a zero ('<code>\0</code>') after its last
        character (as in&nbsp;C), but can contain other zeros in its body.
        </p>

        <!-- cs_to_cfunction -->
        <hr><h3><a name="cs_to_cfunction"><code>cs_to_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_CFunction cs_to_cfunction (cs_State *C, int index);</pre>
        <p>
        Converts a value at the given index to a C&nbsp;function.
        That value must be a C&nbsp;function;
        otherwise, returns <code>NULL</code>.
        </p>

        <!-- cs_to_userdata -->
        <hr><h3><a name="cs_to_userdata"><code>cs_to_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *cs_to_userdata (cs_State *C, int index);</pre>
        <p>
        If the value at the given index is a full userdata, returns its
        memory-block address.
        If the value is a light userdata, returns its value (a pointer).
        Otherwise, returns <code>NULL</code>.
        </p>

        <!-- cs_to_pointer -->
        <hr><h3><a name="cs_to_pointer"><code>cs_to_pointer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const void *cs_to_pointer (cs_State *C, int index);</pre>
        <p>
        Converts the value at the given index to a generic C&nbsp;pointer
        (<code>void*</code>).
        The value can be a userdata, a table, a thread, a string, instance,
        a class, a list or a function; otherwise, <code>cs_to_pointer</code>
        returns <code>NULL</code>.
        Different objects will give different pointers.
        There is no way to convert the pointer back to its original value.
        <br/><br/>
        Typically this function is used only for hashing and debug information.
        </p>

        <!-- cs_to_thread -->
        <hr><h3><a name="cs_to_thread"><code>cs_to_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_State *cs_to_thread (cs_State *C, int index);</pre>
        <p>
        Converts the value at the given index to a CScript thread
        (represented as <code>cs_State*</code>).
        This value must be a thread; otherwise, the function returns
        <code>NULL</code>.
        </p>

        <!-- cs_arith -->
        <hr><h3><a name="cs_arith"><code>cs_arith</code></a></h3>
        <span class="apii">[-(2|1), +1, <em>e</em>]</span>
        <pre>void cs_arith (cs_State *C, int op);</pre>
        <p>
        Performs an arithmetic or bitwise operation over the two values
        (or one, in the case of negations) at the top of the stack,
        with the value on the top being the second operand, pops these values,
        and pushes the result of the operation.
        The function follows the semantics of the corresponding CScript
        operator (that is, it may call metamethods).
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="CS_OPADD"><code>CS_OPADD</code></a>: </b>
                performs addition (<code>+</code>)
            </li>
            <li>
                <b><a name="CS_OPSUB"><code>CS_OPSUB</code></a>: </b>
                performs subtraction (<code>-</code>)
            </li>
            <li>
                <b><a name="CS_OPMUL"><code>CS_OPMUL</code></a>: </b>
                performs multiplication (<code>*</code>)
            </li>
            <li>
                <b><a name="CS_OPDIV"><code>CS_OPDIV</code></a>: </b>
                performs float division (<code>/</code>)
            </li>
            <li>
                <b><a name="CS_OPIDIV"><code>CS_OPIDIV</code></a>: </b>
                performs integer division (<code>//</code>)
            </li>
            <li>
                <b><a name="CS_OPMOD"><code>CS_OPMOD</code></a>: </b>
                performs modulo (<code>%</code>)
            </li>
            <li>
                <b><a name="CS_OPPOW"><code>CS_OPPOW</code></a>: </b>
                performs exponentiation (<code>^</code>)
            </li>
            <li>
                <b><a name="CS_OPSHL"><code>CS_OPSHL</code></a>: </b>
                performs left shift (<code>&lt;&lt;</code>)
            </li>
            <li>
                <b><a name="CS_OPSHR"><code>CS_OPSHR</code></a>: </b>
                performs right shift (<code>&gt;&gt;</code>)
            </li>
            <li>
                <b><a name="CS_OPBAND"><code>CS_OPBAND</code></a>: </b>
                performs bitwise AND (<code>&amp;</code>)
            </li>
            <li>
                <b><a name="CS_OPBOR"><code>CS_OPBOR</code></a>: </b>
                performs bitwise OR (<code>|</code>)
            </li>
            <li>
                <b><a name="CS_OPBXOR"><code>CS_OPBXOR</code></a>: </b>
                performs bitwise exclusive OR (<code>~</code>)
            </li>
            <li>
                <b><a name="CS_OPUNM"><code>CS_OPUNM</code></a>: </b>
                performs mathematical negation (unary <code>-</code>)
            </li>
            <li>
                <b><a name="CS_OPBNOT"><code>CS_OPBNOT</code></a>: </b>
                performs bitwise NOT (<code>~</code>)
            </li>
        </ul>
        </p>

        <!-- cs_rawequal -->
        <hr><h3><a name="cs_rawequal"><code>cs_rawequal</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_rawequal (cs_State *C, int v1, int v2);</pre>
        <p>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        Returns a boolean.
        </p>

        <!-- cs_compare -->
        <hr><h3><a name="cs_compare"><code>cs_compare</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_compare (cs_State *C, int index1, int index2, int op);</pre>
        <p>
        Compares two CScript values.
        Returns 1 if the value at index <code>index1</code> satisfies
        <code>op</code> when compared with the value at index
        <code>index2</code>, following the semantics of the corresponding
        CScript operator (that is, it may call metamethods).
        Otherwise returns&nbsp;0.
        Also returns&nbsp;0 if any of the indices is not valid.
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="CS_OPEQ"><code>CS_OPEQ</code></a>: </b>
                compares for equality (<code>==</code>)
            </li>
            <li>
                <b><a name="CS_OPLT"><code>CS_OPLT</code></a>: </b>
                compares for less than (<code>&lt;</code>)
            </li>
            <li>
                <b><a name="CS_OPLE"><code>CS_OPLE</code></a>: </b>
                compares for less or equal (<code>&lt;=</code>)
            </li>
        </ul>
        </p>

        <!-- cs_push_nil -->
        <hr><h3><a name="cs_push_nil"><code>cs_push_nil</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_nil (cs_State *C);</pre>
        <p>
        Pushes a nil value onto the stack.
        </p>

        <!-- cs_push_number -->
        <hr><h3><a name="cs_push_number"><code>cs_push_number</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_number (cs_State *C, cs_Number n);</pre>
        <p>
        Pushes a float with value <code>n</code> onto the stack.
        </p>

        <!-- cs_push_integer -->
        <hr><h3><a name="cs_push_integer"><code>cs_push_integer</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_integer (cs_State *C, cs_Integer n);</pre>
        <p>
        Pushes an integer with value <code>n</code> onto the stack.
        </p>

        <!-- cs_push_lstring -->
        <hr><h3><a name="cs_push_lstring"><code>cs_push_lstring</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *cs_push_lstring (cs_State *C, const char *s, size_t len);</pre>
        <p>
        Pushes the string pointed to by <code>s</code> with size
        <code>len</code> onto the stack.
        CScript will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        The string can contain any binary data, including embedded zeros.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        </p>

        <!-- cs_push_string -->
        <hr><h3><a name="cs_push_string"><code>cs_push_string</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *cs_push_string (cs_State *C, const char *s);</pre>
        <p>
        Pushes the zero-terminated string pointed to by <code>s</code>
        onto the stack.
        CScript will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        <br/><br/>
        If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and
        returns <code>NULL</code>.
        </p>

        <!-- cs_push_fstring -->
        <hr><h3><a name="cs_push_fstring"><code>cs_push_fstring</code></a></h3>
        <span class="apii">[-0, +1, <em>v</em>]</span>
        <pre>const char *cs_push_fstring (cs_State *C, const char *fmt, ...);</pre>
        <p>
        Pushes onto the stack a formatted string and returns a pointer to
        this string (see <a href="#4.1.3">&sect;4.1.3</a>).
        It is similar to the ISO&nbsp;C function <code>sprintf</code>,
        but has two important differences.
        First, you do not have to allocate space for the result; the result
        is a CScript string and CScript takes care of memory allocation
        (and deallocation, through garbage collection).
        Second, the conversion specifiers are quite restricted.
        There are no flags, widths, or precisions.
        <br/>
        The conversion specifiers can only be:
        <ul>
            <li>
                '<code>%%</code>' (inserts the character '<code>%</code>'),
            </li>
            <li>
                '<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
            </li>
            <li>
                '<code>%f</code>' (inserts a <a href="#cs_Number"><code>cs_Number</code></a>),
            </li>
            <li>
                '<code>%I</code>' (inserts a <a href="#cs_Integer"><code>cs_Integer</code></a>),
            </li>
            <li>
                '<code>%p</code>' (inserts a pointer),
            </li>
            <li>
                '<code>%d</code>' (inserts an <code>int</code>),
            </li>
            <li>
                '<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
            </li>
            <li>
                '<code>%U</code>' (inserts a <code>long int</code> as a UTF-8 byte sequence).
            </li>
        </ul>
        This function may raise errors due to memory overflow
        or an invalid conversion specifier.
        </p>

        <!-- cs_push_vfstring -->
        <hr><h3><a name="cs_push_vfstring"><code>cs_push_vfstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_push_vfstring (cs_State *C, const char *fmt, va_list argp);</pre>
        <p>
        Equivalent to
        <a href="#cs_push_fstring"><code>cs_push_fstring</code></a>,
        except that it receives a <code>va_list</code> instead of a variable
        number of arguments.
        </p>

        <!-- cs_push_cclosure -->
        <hr><h3><a name="cs_push_cclosure"><code>cs_push_cclosure</code></a></h3>
        <span class="apii">[-n, +1, <em>m</em>]</span>
        <pre>void cs_push_cclosure (cs_State *C, cs_CFunction f, int upvals);</pre>
        <p>
        Pushes a new C&nbsp;closure onto the stack.
        This function receives a pointer to a C&nbsp;function and pushes onto
        the stack a CScript value of type <code>function</code> that, when
        called, invokes the corresponding C&nbsp;function.
        The parameter <code>n</code> tells how many upvalues this function
        will have (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Any function to be callable by CScript must follow the correct protocol
        to receive its parameters and return its results
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        When a C&nbsp;function is created, it is possible to associate some
        values with it, the so called upvalues; these upvalues are then
        accessible to the function whenever it is called.
        This association is called a C&nbsp;closure
        (see <a href="#4.2">&sect;4.2</a>).
        To create a C&nbsp;closure, first the initial values for its upvalues
        must be pushed onto the stack.
        (When there are multiple upvalues, the first value is pushed first.)
        Then <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a>
        is called to create and push the C&nbsp;function onto the stack,
        with the argument <code>n</code> telling how many values will be
        associated with the function.
        <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a> also
        pops these values from the stack.
        <br/><br/>
        When <code>n</code> is zero, this function creates a
        <em>light C&nbsp;function</em>, which is just a pointer to the
        C&nbsp;function.
        In that case, it never raises a memory error.
        </p>

        <!-- cs_push_bool -->
        <hr><h3><a name="cs_push_bool"><code>cs_push_bool</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_bool (cs_State *C, int b);</pre>
        <p>
        Pushes a boolean value with value <code>b</code> onto the stack.
        </p>

        <!-- cs_push_lightuserdata -->
        <hr><h3><a name="cs_push_lightuserdata"><code>cs_push_lightuserdata</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_lightuserdata (cs_State *C, void *p);</pre>
        <p>
        Pushes a light userdata onto the stack.
        <br/><br/>
        Userdata represent C&nbsp;values in CScript.
        A <em>light userdata</em> represents a pointer, a <code>void*</code>.
        It is a value (like a number): you do not create it and it is not
        collected (as it was never created).
        A light userdata is equal to "any" light userdata with the same
        C&nbsp;address.
        </p>

        <!-- cs_push_userdata -->
        <hr><h3><a name="cs_push_userdata"><code>cs_push_userdata</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void *cs_push_userdata (cs_State *C, size_t size, int nuv);</pre>
        <p>
        This function creates and pushes on the stack a new full userdata,
        with <code>nuv</code> associated CScript values, called
        <code>user values</code>, plus an associated block of raw memory with
        <code>size</code> bytes.
        (The user values can be set and read with the functions
        <a href="#cs_set_uservalue"><code>cs_set_uservalue</code></a> and
        <a href="#cs_get_uservalue"><code>cs_get_uservalue</code></a>.)
        <br/><br/>
        The function returns the address of the block of memory.
        CScript ensures that this address is valid as long as the corresponding
        userdata is alive (see <a href="#2.5">&sect;2.5</a>).
        Moreover, if the userdata is marked for finalization
        (see <a href="#2.5.3">&sect;2.5.3</a>), its address is valid at least
        until the call to its finalizer.
        </p>

        <!-- cs_push_list -->
        <hr><h3><a name="cs_push_list"><code>cs_push_list</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void cs_push_list (cs_State *C, int size);</pre>
        <p>
        Creates a new empty list and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many elements the
        list will have.
        CScript may use these hints to preallocate memory for the new
        list.
        This preallocation may help performance when you know in advance how
        many elements the list will have.
        </p>

        <!-- cs_push_table -->
        <hr><h3><a name="cs_push_table"><code>cs_push_table</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void cs_push_table (cs_State *C, int size);</pre>
        <p>
        Creates a new empty table and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many elements the
        table will have.
        CScript may use these hints to preallocate memory for the new
        table.
        This preallocation may help performance when you know in advance how
        many elements the table will have.
        </p>

        <!-- cs_push_thread -->
        <hr><h3><a name="cs_push_thread"><code>cs_push_thread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_push_thread (cs_State *C);</pre>
        <p>
        Pushes the thread represented by <code>C</code> onto the stack.
        Returns 1 if this thread is the main thread of its state.
        </p>

        <!-- cs_push_instance -->
        <hr><h3><a name="cs_push_instance"><code>cs_push_instance</code></a></h3>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void cs_push_instance (cs_State *C, int clsobj);</pre>
        <p>
        Creates a new instance from class object at index <code>clsobj</code>
        and pushes it on top of the stack. <code>clsobj</code> must be a
        valid index of the class object.
        <br/>
        This function may call <code>__call</code> metamethod if the class
        implements it.
        <br/>
        (In which case the returned value might not necessarily be the
        instance.)
        </p>

        <!-- cs_push_class -->
        <hr><h3><a name="cs_push_class"><code>cs_push_class</code></a></h3>
        <span class="apii">[-nup, +1, <em>m</em>]</span>
        <pre>void cs_push_class (cs_State *C, int nup, const cs_Entry *l);</pre>
        <p>
        Creates a new class and pushes it on top of the stack.
        Argument <code>l</code> is a list of name-function pairs which are
        set as the <em>methods</em> of the class.
        Additionally each <em>method</em> in <code>l</code> has <code>nup</code>
        upvalues associated with it.
        These upvalues are located on top of the stack and are popped off after
        this function returns.
        <br/><br/>
        Every method entry in the list <code>l</code> with a non-NULL name
        must have a C&nbsp;function associated with it.
        </p>

        <!-- cs_push_subclass -->
        <hr><h3><a name="cs_push_subclass"><code>cs_push_subclass</code></a></h3>
        <span class="apii">[-nup, +1, <em>m</em>]</span>
        <pre>void cs_push_subclass (cs_State *C,
                       int sc,
                       int nup,
                       const cs_Entry *l);</pre>
        <p>
        Similar to <a href="#cs_push_class"><code>cs_push_class</code></a>,
        except this creates a <em>sub</em>class of superclass at index
        <code>sc</code>.
        First the inheritance of superclass <code>sc</code> is done, then the
        methods in list <code>l</code> are set.
        </p>

        <!-- cs_push_metaclass -->
        <hr><h3><a name="cs_push_metaclass"><code>cs_push_metaclass</code></a></h3>
        <span class="apii">[-nup, +1, <em>m</em>]</span>
        <pre>void cs_push_metaclass (cs_State *C,
                        int ml,
                        int nup,
                        const cs_Entry *l);</pre>
        <p>
        Similar to <a href="#cs_push_class"><code>cs_push_class</code></a>,
        except this function accepts additional argument <code>ml</code>
        which is the index of <em>metalist</em>
        (see <a href="#2.4">&sect;2.4</a>).
        </p>

        <!-- cs_push_metasubclass -->
        <hr><h3><a name="cs_push_metasubclass"><code>cs_push_metasubclass</code></a></h3>
        <span class="apii">[-nup, +1, <em>m</em>]</span>
        <pre>void cs_push_metasubclass (cs_State *C,
                           int sc,
                           int ml,
                           int nup,
                           const cs_Entry *l);</pre>
        <p>
        This function is combination of
        <a href="#cs_push_subclass"><code>cs_push_subclass</code></a> and
        <a href="#cs_push_metaclass"><code>cs_push_metaclass</code></a>.
        </p>

        <!-- cs_get_global -->
        <hr><h3><a name="cs_get_global"><code>cs_get_global</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_global (cs_State *C, const char *name);</pre>
        <p>
        Pushes onto the stack the value of the global <code>name</code>.
        Returns the type of that value.
        </p>

        <!-- cs_get -->
        <hr><h3><a name="cs_get"><code>cs_get</code></a></h3>
        <span class="apii">[-1, +1, <em>e</em>]</span>
        <pre>int cs_get (cs_State *C, int index);</pre>
        <p>
        Pushes on the stack the value <code>obj[k]</code>, where
        <code>obj</code> is the value at the given index and <code>k</code>
        is the value on top of the stack.
        <br/><br/>
        This function pops the key from the stack, pushing the resulting
        value in its place.
        As in CScript, this function may trigger a metamethod
        for the "getidx" event (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_raw -->
        <hr><h3><a name="cs_get_raw"><code>cs_get_raw</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int cs_get_raw (cs_State *C, int index);</pre>
        <p>
        Similar to <a href="#cs_get"><code>cs_get</code></a>, but does a raw
        access (i.e., without metamethods).
        The value at <code>index</code> must be a table, list or instance.
        </p>

        <!-- cs_get_index -->
        <hr><h3><a name="cs_get_index"><code>cs_get_index</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Pushes onto the stack the value <code>a[i]</code>,
        where <code>a</code> is the list at the given index.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_nilindex -->
        <hr><h3><a name="cs_get_nilindex"><code>cs_get_nilindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_nilindex (cs_State *C, int index, uint begin, int end);</pre>
        <p>
        Returns the first <b>nil</b> index  inside the list at
        the given index starting from <code>begin</code> index up to
        <code>end</code> index (inclusive).
        If <code>end</code> is greater or equal than the length of the list,
        or is less than 0, it is clipped to the last index (list length - 1).
        If there is no such index this returns -1.
        </p>

        <!-- cs_get_nnilindex -->
        <hr><h3><a name="cs_get_nnilindex"><code>cs_get_nnilindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_nnilindex (cs_State *C, int index, uint begin, int end);</pre>
        <p>
        Similar to <a href="#cs_get_nnilindex"><code>cs_get_nnilindex</code></a>
        except this returns the first Non-<b>nil</b> index.
        </p>

        <!-- cs_get_nilindex_rev -->
        <hr><h3><a name="cs_get_nilindex_rev"><code>cs_get_nilindex_rev</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_nilindex_rev (cs_State *C, int index, int begin, uint end);</pre>
        <p>
        Similar to
        <a href="#cs_get_nilindex"><code>cs_get_nilindex</code></a>
        except this performs the search in reverse.
        Additionally if <code>begin</code> is greater or equal than the length
        of the list, or is less than 0, it is clipped to the last index
        (list length - 1).
        </p>

        <!-- cs_get_nnilindex_rev -->
        <hr><h3><a name="cs_get_nnilindex_rev"><code>cs_get_nnilindex_rev</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_nnilindex_rev (cs_State *C, int index, int begin, uint end);</pre>
        <p>
        Similar to
        <a href="#cs_get_nilindex_rev"><code>cs_get_nilindex_rev</code></a>
        except this returns the first Non-<b>nil</b> index.
        </p>

        <!-- cs_get_field -->
        <hr><h3><a name="cs_get_field"><code>cs_get_field</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int cs_get_field (cs_State *C, int index);</pre>
        <p>
        Identical to <a href="#cs_get_raw"><code>cs_get_raw</code></a> the only
        difference being that value at <code>index</code> must only be a
        table or instance (list is not allowed as lists do not have fields).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldstr -->
        <hr><h3><a name="cs_get_fieldstr"><code>cs_get_fieldstr</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int cs_get_fieldstr (cs_State *C, int index, const char *field);</pre>
        <p>
        Similar to <a href="#cs_get_field"><code>cs_get_fieldstr</code></a>
        but instead of using the value on top of the stack as key, it instead
        uses the argument <code>field</code> which is a null-terminated string
        (i.e., <code>obj[field]</code>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldptr -->
        <hr><h3><a name="cs_get_fieldptr"><code>cs_get_fieldptr</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldptr (cs_State *C, int index, const void *field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is the pointer.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldint -->
        <hr><h3><a name="cs_get_fieldint"><code>cs_get_fieldint</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldint (cs_State *C, int index, cs_Integer field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is CScript <a href="#cs_Integer"><code>integer</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldflt -->
        <hr><h3><a name="cs_get_fieldflt"><code>cs_get_fieldflt</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldflt (cs_State *C, int index, cs_Number field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is CScript <a href="#cs_Number"><code>float</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_class -->
        <hr><h3><a name="cs_get_class"><code>cs_get_class</code></a></h3>
        <span class="apii">[-0, +0|1, &ndash;]</span>
        <pre>int cs_get_class (cs_State *C, int index);</pre>
        <p>
        Pushes the class of the object at the <code>index</code> on top of
        the stack.
        <br/>
        Returns <code>CS_TCLASS</code> if the object at <code>index</code>
        is instance, otherwise nothing is pushed and this returns 
        <code>CS_TNONE</code>.
        </p>

        <!-- cs_get_superclass -->
        <hr><h3><a name="cs_get_superclass"><code>cs_get_superclass</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>int cs_get_superclass (cs_State *C, int index);</pre>
        <p>
        Pushes the superclass of the value at the given index; the value at
        the given index must be either a class or instance.
        <br/>
        Returns 1 if the value has superclass, otherwise nothing is pushed
        and 0 is returned.
        </p>

        <!-- cs_get_method -->
        <hr><h3><a name="cs_get_method"><code>cs_get_method</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_method (cs_State *C, int index);</pre>
        <p>
        Pushes onto the stack a method of the value <code>ins[k]</code> where
        <code>ins</code> is the value at the given index and <code>k</code>
        is the value on top of the stack.
        This performs raw access on the method table of the instance and as
        such can't invoke a metamethod.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_uservalue -->
        <hr><h3><a name="cs_get_uservalue"><code>cs_get_uservalue</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_uservalue (cs_State *C, int index, unsigned short n);</pre>
        <p>
        Pushes onto the stack the <code>n</code>-th user value associated with
        the full userdata at the given index and returns the type of the
        pushed value.
        <br/><br/>
        If the userdata does not have that value, pushes <b>nil</b> and
        returns <a href="CS_TNONE"><code>CS_TNONE</code></a>.
        </p>

        <!-- cs_get_metalist -->
        <hr><h3><a name="cs_get_metalist"><code>cs_get_metalist</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>int cs_get_metalist (cs_State *C, int index);</pre>
        <p>
        Pushes the metalist of value at the given index on top of the stack.
        Only <em>fulluserdata</em>, <em>class</em> and transitively
        <em>instance</em> values have metalist.
        This returns 1 if the value at given index has a metalist,
        otherwise it does not push anything on the stack and it returns 0.
        </p>

        <!-- cs_set_global -->
        <hr><h3><a name="cs_set_global"><code>cs_set_global</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void cs_set_global (cs_State *C, const char *name);</pre>
        <p>
        Pops a value from the stack and sets it as the new value of global
        <code>name</code>.
        </p>

        <!-- cs_set -->
        <hr><h3><a name="cs_set"><code>cs_set</code></a></h3>
        <span class="apii">[-2, +0, <em>e</em>]</span>
        <pre>void cs_set (cs_State *C, int index);</pre>
        <p>
        Does the equivalent to <code>obj[k] = v</code>, where <code>obj</code>
        is the value at the given index, <code>v</code> is the value on top of
        the stack and <code>k</code> is the key value on stack below the
        <code>v</code>.
        <br/><br/>
        This function pops both the key and value off the stack.
        As in CScript, this function may trigger a metamethod
        for the "setidx" event (see <a href="#2.4">&sect;2.4</a>).
        </p>

        <!-- cs_set_raw -->
        <hr><h3><a name="cs_set_raw"><code>cs_set_raw</code></a></h3>
        <span class="apii">[-2, +0, <em>v</em>]</span>
        <pre>void cs_set_raw (cs_State *C, int index);</pre>
        <p>
        Similar to <a href="#cs_set"><code>cs_set</code></a> except that it
        performs a raw set, meaning it wont invoke a metamethod.
        <br/>
        Value at the given index must be a table, list or instance, otherwise
        this function errors as the value can't be indexed.
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- cs_set_index -->
        <hr><h3><a name="cs_set_index"><code>cs_set_index</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void cs_set_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Does the equivalent of <code>l[i] = v</code>, where <code>l</code>
        is the list at the given index, <code>i</code> is index into the
        list and <code>v</code> is element value on top of the stack.
        <br/>
        As in CScript, the list grows in order to ensure that index fits,
        so if the index into the list is not in positive bounds of the list,
        then the list will try to grow in order to fit the index.
        Additionally all the "holes" will be set as <b>nil</b> and length
        updated to the <code>i + 1</code> (assuming that <code>i</code> is
        positive and in bounds of <code>int</code>).
        <br/><br/>
        This function pops the element value off the stack.
        </p>

        <!-- cs_set_field -->
        <hr><h3><a name="cs_set_field"><code>cs_set_field</code></a></h3>
        <span class="apii">[-2, +0, <em>m</em>]</span>
        <pre>void cs_set_field (cs_State *C, int index);</pre>
        <p>
        Identical to <a href="#cs_set_raw"><code>cs_set_raw</code></a> the only
        difference being that value at <code>index</code> must only be a table
        or instance (list is not allowed as lists do not have fields).
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- cs_set_fieldstr -->
        <hr><h3><a name="cs_set_fieldstr"><code>cs_set_fieldstr</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_set_fieldstr (cs_State *C, int index, const char *field);</pre>
        <p>
        Similar to <a href="#cs_set_field"><code>cs_set_field</code></a>
        but instead of using the value on stack as the key, it instead uses
        the argument <code>field</code> which is null-terminated string
        (i.e., <code>obj[field]&nbsp;=&nbsp;v</code>).
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldptr -->
        <hr><h3><a name="cs_set_fieldptr"><code>cs_set_fieldptr</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_set_fieldptr (cs_State *C, int index, const void *field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the pointer.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldint -->
        <hr><h3><a name="cs_set_fieldint"><code>cs_set_fieldint</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_set_fieldint (cs_State *C, int index, cs_Integer field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the CScript
        <a href="#cs_Integer">integer</a>.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldflt -->
        <hr><h3><a name="cs_set_fieldflt"><code>cs_set_fieldflt</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_set_fieldflt (cs_State *C, int index, cs_Number field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the CScript
        <a href="#cs_Number">float</a>.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_metalist -->
        <hr><h3><a name="cs_set_metalist"><code>cs_set_metalist</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void cs_set_metalist (cs_State *C, int index);</pre>
        <p>

        </p>

        <!-- cs_set_uservalue -->
        <hr><h3><a name="cs_set_uservalue"><code>cs_set_uservalue</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>int cs_set_uservalue (cs_State *C, int index, unsigned short n);</pre>
        <p>
        Pops a value from the stack and sets it as the new <code>n</code>-th
        user value associated to the full userdata at the given index.
        Returns 0 if the userdata does not have that value.
        </p>

        <!-- cs_status -->
        <hr><h3><a name="cs_status"><code>cs_status</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_status (cs_State *C);</pre>
        <p>
        Returns the status of the thread <code>C</code>.
        <br/><br/>
        The status can be <a href="#CS_OK"><code>CS_OK</code></a> for a normal
        thread.
        <br/>
        (This function is here only for when the coroutines get implemented,
        currently it offers nothing helpful.)
        <br/><br/>
        You can call functions only in threads with status
        <a href="#CS_OK"><code>CS_OK</code></a>.
        </p>

        <!-- cs_error -->
        <hr><h3><a name="cs_error"><code>cs_error</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_error (cs_State *C);</pre>
        <p>
        Raises a CScript error, using the value on the top of the stack as
        the error object.
        This function does a long jump, and therefore never returns
        (see <a href="#csL_error"><code>csL_error</code></a>).
        </p>

        <!-- cs_call -->
        <hr><h3><a name="cs_call"><code>cs_call</code></a></h3>
        <span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
        <pre>void cs_call (cs_State *C, int nargs, int nresults);</pre>
        <p>
        Calls a function.
        Like regular CScript calls, <code>cs_call</code> respects the
        <code>__call</code> metamethod.
        So, here the word "function" means any callable value.
        <br/><br/>
        To do a call you must use the following protocol:
        first, the function to be called is pushed onto the stack;
        then, the arguments to the call are pushed in direct order;
        that is, the first argument is pushed first.
        Finally you call <a href="#cs_call"><code>cs_call</code></a>;
        <code>nargs</code> is the number of arguments that you pushed onto
        the stack.
        When the function returns, all arguments and the function value are
        popped and the call results are pushed onto the stack.
        The number of results is adjusted to <code>nresults</code>,
        unless <code>nresults</code> is
        <a name="CS_MULRET"><code>CS_MULRET</code></a>.
        In this case, all results from the function are pushed;
        CScript takes care that the returned values fit into the stack space,
        but it does not ensure any extra space in the stack.
        The function results are pushed onto the stack in direct order
        (the first result is pushed first), so that after the call the last
        result is on the top of the stack.
        <br/><br/>
        Any error while calling and running the function is propagated upwards
        (with a <code>longjmp</code>).
        <br/><br/>
        The following example shows how the host program can do the
        equivalent to this CScript code:
        <pre>
    a = f("how", t.x, 14)</pre>
        Here it is in&nbsp;C:
        <pre>
    cs_get_global(C, "f");                 /* function to be called */
    cs_push_literal(C, "how");                      /* 1st argument */
    cs_get_global(C, "t");                   /* table to be indexed */
    cs_get_fieldstr(C, -1, "x");    /* push result of t.x (2nd arg) */
    cs_remove(C, -2);                  /* remove 't' from the stack */
    cs_push_integer(C, 14);                         /* 3rd argument */
    cs_call(C, 3, 1);     /* call 'f' with 3 arguments and 1 result */
    cs_set_global(C, "a");                        /* set global 'a' */</pre>
        Note that the code above is <em>balanced</em>:
        at its end, the stack is back to its original configuration.
        This is considered good programming practice.
        </p>

        <!-- cs_pcall -->
        <hr><h3><a name="cs_pcall"><code>cs_pcall</code></a></h3>
        <span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
        <pre>int cs_pcall (cs_State *C, int nargs, int nresults, int msgh);</pre>
        <p>
        Calls a function (or a callable object) in protected mode.
        <br/><br/>
        Both <code>nargs</code> and <code>nresults</code> have the same
        meaning as in <a href="#cs_call"><code>cs_call</code></a>.
        If there are no errors during the call,
        <a href="#cs_pcall"><code>cs_pcall</code></a> behaves exactly like
        <a href="#cs_call"><code>cs_call</code></a>.
        However, if there is any error,
        <a href="#cs_pcall"><code>cs_pcall</code></a> catches it, pushes a
        single value on the stack (the error object), and returns an error code.
        Like <a href="#cs_call"><code>cs_call</code></a>,
        <a href="#cs_pcall"><code>cs_pcall</code></a> always removes the
        function and its arguments from the stack.
        <br/><br/>
        If <code>absmsgh</code> is less than 0, then the error object returned
        on the stack is exactly the original error object.
        Otherwise, <code>absmsgh</code> is the absolute stack index of a
        <em>message handler</em>.
        (This index cannot be a pseudo-index.)
        In case of runtime errors, this handler will be called with the error
        object and its return value will be the object returned on the stack
        by <a href="#cs_pcall"><code>cs_pcall</code></a>.
        <br/><br/>
        Typically, the message handler is used to add more debug information
        to the error object, such as a stack traceback.
        Such information cannot be gathered after the return of
        <a href="#cs_pcall"><code>cs_pcall</code></a>, since by then the stack
        has unwound.
        <br/><br/>
        The <a href="#cs_pcall"><code>cs_pcall</code></a> function returns one
        of the following status codes:
        <a href="#CS_OK"><code>CS_OK</code></a>,
        <a href="#CS_ERRRUNTIME"><code>CS_ERRRUNTIME</code></a>,
        <a href="#CS_ERRMEM"><code>CS_ERRMEM</code></a> or
        <a href="#CS_ERRERROR"><code>CS_ERRERROR</code></a>.
        </p>

        <!-- cs_load -->
        <hr><h3><a name="cs_load"><code>cs_load</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_load (cs_State *C,
             cs_Reader reader,
             void *userdata,
             const char *chunkname);</pre>
        <p>
        Loads a CScript chunk without running it.
        If there are no errors, <code>cs_load</code> pushes the compiled chunk
        as a CScript function on top of the stack.
        Otherwise, it pushes an error message.
        <br/><br/>
        The <code>cs_load</code> function uses a user-supplied
        <code>reader</code> function to read the chunk
        (see <a href="#cs_Reader"><code>cs_Reader</code></a>).
        The <code>userdata</code> argument is an opaque value passed to the
        reader function.
        <br/><br/>
        The <code>chunkname</code> argument gives a name to the chunk, which
        is used for error messages and in debug information
        (see <a href="#4.7">&sect;4.7</a>).
        <br/><br/>
        <code>cs_load</code> uses the stack internally, so the reader function
        must always leave the stack unmodified when returning.
        <br/><br/>
        <code>cs_load</code> can return
        <a href="#CS_OK"><code>CS_OK</code></a>,
        <a href="#CS_ERRSYNTAX"><code>CS_ERRSYNTAX</code></a>, or
        <a href="#CS_ERRMEM"><code>CS_ERRMEM</code></a>.
        The function may also return other values corresponding to errors
        raised by the read function (see <a href="#4.4.1">&sect;4.4.1</a>).
        </p>

        <!-- cs_gc -->
        <hr><h3><a name="cs_gc"><code>cs_gc</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_gc (cs_State *C, int what, ...);</pre>
        <p>
        Controls the garbage collector.
        <br/><br/>
        This function performs several tasks, according to the value of the
        parameter <code>what</code>.
        For options that need extra arguments, they are listed after the
        option.
        <ul>
            <li>
                <b><code>CS_GCSTOP</code>: </b>
                Stops the garbage collector.
            </li>
            <li>
                <b><code>CS_GCRESTART</code>: </b>
                Restarts the garbage collector.
            </li>
            <li>
                <b><code>CS_GCCOLLECT</code>: </b>
                Performs a full garbage-collection cycle.
            </li>
            <li>
                <b><code>CS_GCCOUNT</code>: </b>
                Returns the current amount of memory (in Kbytes) in use by
                CScript.
            </li>
            <li>
                <b><code>CS_GCCOUNTBYTES</code>: </b>
                Returns the remainder of dividing the current amount of bytes
                of memory in use by CScript by 1024.
            </li>
            <li>
                <b><code>CS_GCSTEP</code> (int stepsize): </b>
                Performs an incremental step of garbage collection,
                corresponding to the allocation of <code>stepsize</code> Kbytes.
            </li>
            <li>
                <b><code>CS_GCISRUNNING</code>: </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
            <li>
                <b><code>CS_GCINC</code> (int pause, int stepmul, stepsize): </b>
                Changes the collector to incremental mode with the given
                parameters (see <a href="#2.5.1">&sect;2.5.1</a>).
                Returns the previous mode (which is always <code>CS_GCINC</code>).
            </li>
        </ul>
        For more details about these options,
        see <a href="#gc"><code>gc</code></a>.
        <br/><br/>
        This function should not be called by a finalizer.
        </p>

        <!-- cs_setwarnf -->
        <hr><h3><a name="cs_setwarnf"><code>cs_setwarnf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_setwarnf (cs_State *C, cs_WarnFunction fwarn, void *ud);</pre>
        <p>
        Sets the warning function to be used by CScript to emit warnings
        (see <a href="#cs_WarnFunction"><code>cs_WarnFunction</code></a>).
        The <code>ud</code> parameter sets the value <code>ud</code> passed to
        the warning function.
        </p>

        <!-- cs_warning -->
        <hr><h3><a name="cs_warning"><code>cs_warning</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_warning (cs_State *C, const char *msg, int cont);</pre>
        <p>
        Emits a warning with the given message.
        A message in a call with <code>tocont</code> true should be continued
        in another call to this function.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about warnings.
        </p>

        <!-- cs_len -->
        <hr><h3><a name="cs_len"><code>cs_len</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Unsigned cs_len (cs_State *C, int index);</pre>
        <p>
        Returns the "length" of the value at the given index.
        For strings, this is the string length;
        for lists, this is the list length;
        for tables, this is the number of non <b>nil</b> key values;
        for classes, this is the number of methods;
        for instances, this is the number of non <b>nil</b> fields;
        for userdata, this is the size of the block of memory allocated
        for the userdata.
        For other values, this call returns&nbsp;0.
        </p>

        <!-- cs_next -->
        <hr><h3><a name="cs_next"><code>cs_next</code></a></h3>
        <span class="apii">[-1, +(2|0), <em>v</em>]</span>
        <pre>int cs_next (cs_State *C, int index);</pre>
        <p>
        Pops a key from the stack, and pushes a key&ndash;value pair from the
        table or instance at the given index, the "next" pair
        after the given key.
        If there are no more elements in the table or no more fields in the
        instances, then <a href="#cs_next"><code>cs_next</code></a>
        returns&nbsp;0 and pushes nothing.
        <br/><br/>
        A typical table traversal looks like this:
        <pre>
    /* table is in the stack at index 't' */
    cs_push_nil(C);  /* first key */
    while (cs_next(C, t) != 0) {
        /* uses 'key' (at index -2) and 'value' (at index -1) */
        printf("%s - %s\n",
               cs_typename(C, cs_type(C, -2)),
               cs_typename(C, cs_type(C, -1)));
        /* removes 'value'; keeps 'key' for next iteration */
        cs_pop(C, 1);
    }</pre>
        This function may raise an error if the given key is neither
        <b>nil</b> nor present in the table or instance.
        See function <a href="#next"><code>next</code></a> for the caveats of
        modifying the table or instance fields during its traversal.
        </p>

        <!-- cs_concat -->
        <hr><h3><a name="cs_concat"><code>cs_concat</code></a></h3>
        <span class="apii">[-n, +1, <em>e</em>]</span>
        <pre>void cs_concat (cs_State *C,  int n);</pre>
        <p>
        Concatenates the <code>n</code> values at the top of the stack,
        pops them, and leaves the result on the top.
        If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on
        the stack (that is, the function does nothing);
        if <code>n</code> is 0, the result is the empty string.
        Concatenation is performed following the usual semantics of CScript
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        </p>

        <!-- cs_stringtonumber -->
        <hr><h3><a name="cs_stringtonumber"><code>cs_stringtonumber</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>size_t cs_stringtonumber (cs_State *C, const char *s, int *f);</pre>
        <p>
        Converts the zero-terminated string <code>s</code> to a number,
        pushes that number into the stack, and returns the total size of
        the string, that is, its length plus one.
        The conversion can result in an integer or a float,
        according to the lexical conventions of CScript
        (see <a href="#3.1">&sect;3.1</a>).
        The string may have leading and trailing whitespaces and a sign.
        If the string is not a valid numeral, returns 0 and pushes nothing.
        (Note that the result can be used as a boolean, true if the conversion
        succeeds.)
        If <code>f</code> is provided then it will be set to -1 in case the
        underflow occurred, 1 if overflow occurred or 0 if conversion
        was performed without underflow and overflow occurring.
        </p>

        <!-- cs_getallocf -->
        <hr><h3><a name="cs_getallocf"><code>cs_getallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Alloc cs_getallocf (cs_State *C, void **ud);</pre>
        <p>
        Returns the memory-allocation function of a given state.
        If <code>ud</code> is not <code>NULL</code>, CScript stores in
        <code>*ud</code> the opaque pointer given when the memory-allocator
        function was set.
        </p>

        <!-- cs_setallocf -->
        <hr><h3><a name="cs_setallocf"><code>cs_setallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_setallocf (cs_State *C, cs_Alloc f, void *ud);</pre>
        <p>
        Changes the allocator function of a given state to <code>f</code>
        with user data <code>ud</code>.
        </p>

        <!-- cs_toclose -->
        <hr><h3><a name="cs_toclose"><code>cs_toclose</code></a></h3>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void cs_toclose (cs_State *C, int index);</pre>
        <p>
        Marks the given index in the stack as a to-be-closed slot
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        Like a to-be-closed variable in CScript, the value at that slot in
        the stack will be closed when it goes out of scope.
        Here, in the context of a C function, to go out of scope means that
        the running function returns to CScript, or there is an error,
        or the slot is removed from the stack through
        <a href="#cs_setntop"><code>cs_setntop</code></a> or
        <a href="#cs_pop"><code>cs_pop</code></a>,
        or there is a call to
        <a href="#cs_closeslot"><code>cs_closeslot</code></a>.
        A slot marked as to-be-closed should not be removed from the stack
        by any other function in the API except
        <a href="#cs_setntop"><code>cs_setntop</code></a> or
        <a href="#cs_pop"><code>cs_pop</code></a>,
        unless previously deactivated by
        <a href="#cs_closeslot"><code>cs_closeslot</code></a>.
        <br/><br/>
        This function raises an error if the value at the given slot
        neither has a <code>__close</code> metamethod nor is a false value.
        <br/><br/>
        This function should not be called for an index that is equal to
        or below an active to-be-closed slot.
        <br/><br/>
        Note that, both in case of errors and of a regular return,
        by the time the <code>__close</code> metamethod runs,
        the C&nbsp;stack was already unwound, so that any automatic
        C&nbsp;variable declared in the calling function
        (e.g., a buffer) will be out of scope.
        </p>

        <!-- cs_closeslot -->
        <hr><h3><a name="cs_closeslot"><code>cs_closeslot</code></a></h3>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>void cs_closeslot (cs_State *C, int index);</pre>
        <p>
        Close the to-be-closed slot at the given index and set its value to
        <b>nil</b>.
        The index must be the last index previously marked to be closed
        (see <a href="#cs_toclose"><code>cs_toclose</code></a>) that is still
        active (that is, not closed yet).
        </p>

        <!-- cs_getextraspace -->
        <hr><h3><a name="cs_getextraspace"><code>cs_getextraspace</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *cs_getextraspace (cs_State *C);</pre>
        <p>
        Returns a pointer to a raw memory area associated with the
        given CScript state.
        The application can use this area for any purpose;
        CScript does not use it for anything.
        <br/><br/>
        Each new thread has this area initialized with a copy of the area
        of the main thread.
        <br/><br/>
        By default, this area has the size of a pointer to void, but you can
        recompile CScript with a different size for this area.
        (See <code>CS_EXTRASPACE</code> in <code>csconf.h</code>.)
        </p>

        <!-- cs_getntop -->
        <hr><h3><a name="cs_getntop"><code>cs_getntop</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_getntop (cs_State *C);</pre>
        <p>
        Similar to <a href="#cs_gettop"><code>cs_gettop</code></a> except
        this returns the actual number of the values on the stack.
        So the return value of 0 means an empty stack.
        (This is equivalent to
        <a href="#cs_gettop"><code>cs_gettop</code></a><code>&nbsp;+&nbsp;1</code>.)
        </p>

        <!-- cs_to_number -->
        <hr><h3><a name="cs_to_number"><code>cs_to_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_to_number (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_numberx"><code>cs_to_numberx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_to_integer -->
        <hr><h3><a name="cs_to_integer"><code>cs_to_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer cs_to_integer (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_integerx"><code>cs_to_integerx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_pop -->
        <hr><h3><a name="cs_pop"><code>cs_pop</code></a></h3>
        <span class="apii">[-n, +0, &ndash;]</span>
        <pre>void cs_pop (cs_State *C, int n);</pre>
        <p>
        Pops <code>n</code> elements from the stack.
        It is implemented as a macro over
        <a href="#cs_setntop"><code>cs_setntop</code></a>.
        </p>

        <!-- cs_push_cfunction -->
        <hr><h3><a name="cs_push_cfunction"><code>cs_push_cfunction</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_cfunction (cs_State *C, cs_CFunction f);</pre>
        <p>
        Pushes a C&nbsp;function onto the stack.
        This function is equivalent to
        <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a> with
        no upvalues.
        </p>

        <!-- cs_register -->
        <hr><h3><a name="cs_register"><code>cs_register</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void cs_register (cs_State *C, const char *name, cs_CFunction f);</pre>
        <p>
        Sets the C&nbsp;function <code>f</code> as the new value of global
        <code>name</code>.
        It is defined as a macro:
        <pre>
    #define cs_register(C,n,f) \
            (cs_push_cfunction(C, f), cs_set_global(C, n))</pre>
        </p>

        <!-- cs_is_cfunction -->
        <hr><h3><a name="cs_is_cfunction"><code>cs_is_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_cfunction (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a C&nbsp;function,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_list -->
        <hr><h3><a name="cs_is_list"><code>cs_is_list</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_list (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is the list,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_table -->
        <hr><h3><a name="cs_is_table"><code>cs_is_table</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_table (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a table,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_class -->
        <hr><h3><a name="cs_is_class"><code>cs_is_class</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_class (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a class,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_instance -->
        <hr><h3><a name="cs_is_instance"><code>cs_is_instance</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_instance (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a instance,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_lightuserdata -->
        <hr><h3><a name="cs_is_lightuserdata"><code>cs_is_lightuserdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_lightuserdata (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a light userdata,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_nil -->
        <hr><h3><a name="cs_is_nil"><code>cs_is_nil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_nil (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is <b>nil</b>,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_boolean -->
        <hr><h3><a name="cs_is_bool"><code>cs_is_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_bool (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a boolean,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_thread -->
        <hr><h3><a name="cs_is_thread"><code>cs_is_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_thread (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a thread,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_none -->
        <hr><h3><a name="cs_is_none"><code>cs_is_none</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_none (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the given index is not valid, and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_noneornil -->
        <hr><h3><a name="cs_is_noneornil"><code>cs_is_noneornil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_noneornil (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the given index is not valid or if the value at this
        index is <b>nil</b>, and 0&nbsp;otherwise.
        </p>

        <!-- cs_push_literal -->
        <hr><h3><a name="cs_push_literal"><code>cs_push_literal</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>const char *cs_push_literal (cs_State *C, const char *s);</pre>
        <p>
        This macro is equivalent to
        <a href="#cs_push_string"><code>cs_push_string</code></a>, but should
        be used only when <code>s</code> is a literal string.
        (CScript may optimize this case.)
        </p>

        <!-- cs_push_mainthread -->
        <hr><h3><a name="cs_push_mainthread"><code>cs_push_mainthread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_mainthread (cs_State *C);</pre>
        <p>
        Pushes the main thread of the state onto the stack.
        </p>

        <!-- cs_push_globaltable -->
        <hr><h3><a name="cs_push_globaltable"><code>cs_push_globaltable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_globaltable (cs_State *C);</pre>
        <p>
        Pushes the global table onto the stack.
        </p>

        <!-- cs_push_registrytable -->
        <hr><h3><a name="cs_push_registrytable"><code>cs_push_registrytable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_registrytable (cs_State *C);</pre>
        <p>
        Pushes the registry table onto the stack.
        </p>

        <!-- cs_to_string -->
        <hr><h3><a name="cs_to_string"><code>cs_to_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_to_string (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_lstring"><code>cs_to_lstring</code></a>
        with <code>len</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_insert -->
        <hr><h3><a name="cs_insert"><code>cs_insert</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>void cs_insert (cs_State *C, int index);</pre>
        <p>
        Moves the top element into the given valid index, shifting up the
        elements above this index to open space.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_remove -->
        <hr><h3><a name="cs_remove"><code>cs_remove</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_remove (cs_State *C, int index);</pre>
        <p>
        Removes the element at the given valid index, shifting down the
        elements above this index to fill the gap.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_replace -->
        <hr><h3><a name="cs_replace"><code>cs_replace</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_replace (cs_State *C, int index);</pre>
        <p>
        Moves the top element into the given valid index without shifting any
        element (therefore replacing the value at that given index), and then
        pops the top element.
        </p>

        <!-- cs_getstack -->
        <hr><h3><a name="cs_getstack"><code>cs_getstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_getstack (cs_State *C, int level, cs_Debug *ar);</pre>
        <p>
        Gets information about the interpreter runtime stack.
        <br/><br/>
        This function fills parts of a
        <a href="#cs_Debug"><code>cs_Debug</code></a> structure with an
        identification of the <em>activation record</em> of the function
        executing at a given level.
        Level&nbsp;0 is the current running function, whereas level
        <em>n+1</em> is the function that has called level <em>n</em>.
        When called with a level greater than the stack depth,
        <a href="#cs_getstack"><code>cs_getstack</code></a> returns 0;
        otherwise it returns 1.
        </p>

        <!-- cs_getinfo -->
        <hr><h3><a name="cs_getinfo"><code>cs_getinfo</code></a></h3>
        <span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
        <pre>int cs_getinfo (cs_State *C, const char *what, cs_Debug *ar);</pre>
        <p>
        Gets information about a specific function or function invocation.
        <br/><br/>
        To get information about a function invocation, the parameter
        <code>ar</code> must be a valid activation record that was filled by
        a previous call to <a href="#cs_getstack"><code>cs_getstack</code></a>.
        <br/><br/>
        To get information about a function, you push it onto the stack and
        start the <code>what</code> string with the character
        '<code>&gt;</code>'.
        (In that case, <code>cs_getinfo</code> pops the function from the top
        of the stack.)
        For instance, to know in which line a function <code>f</code> was defined,
        you can write the following code:
        <pre>
    cs_Debug ar;
    cs_get_global(C, "f");  /* get global 'f' */
    cs_getinfo(C, "&gt;s", &amp;ar);
    printf("%d\n", ar.defline);</pre>
        Each character in the string <code>what</code> selects some fields of
        the structure <code>ar</code> to be filled or a value to be pushed on
        the stack.
        (These characters are also documented in the declaration of the
        structure <a href="#cs_Debug"><code>cs_Debug</code></a>, between
        parentheses in the comments following each field.)
        <ul>
            <li>
                <b>'<code>f</code>': </b>
                pushes onto the stack the function that is running at the
                given level;
            </li>
            <li>
                <b>'<code>l</code>': </b>
                fills in the field <code>currline</code>;
            </li>
            <li>
                <b>'<code>n</code>': </b>
                fills in the fields <code>name</code> and
                <code>namewhat</code>;
            </li>
            <li>
                <b>'<code>s</code>': </b>
                fills in the fields <code>source</code>,
                <code>shortsrc</code>, <code>defline</code>,
                <code>lastdefline</code> and <code>what</code>;
            </li>
            <li>
                <b>'<code>u</code>': </b>
                fills in the fields <code>nupvals</code>, <code>nparams</code>
                and <code>isvararg</code>;
            </li>
        </ul>
        This function returns 0 to signal an invalid option in
        <code>what</code>; even then the valid options are handled correctly.
        </p>

        <!-- cs_getlocal -->
        <hr><h3><a name="cs_getlocal"><code>cs_getlocal</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *cs_getlocal (cs_State *C, const cs_Debug *ar, int n);</pre>
        <p>
        Gets information about a local variable or a temporary value of a
        given activation record or a given function.
        <br/><br/>
        In the first case, the parameter <code>ar</code> must be a valid
        activation record that was filled by a previous call to
        <a href="#cs_getstack"><code>cs_getstack</code></a>.
        The index <code>n</code> selects which local variable to inspect.
        <br/><br/>
        <a href="#cs_getlocal"><code>cs_getlocal</code></a> pushes the
        variable's value onto the stack and returns its name.
        <br/><br/>
        In the second case, <code>ar</code> must be <code>NULL</code> and the
        function to be inspected must be on the top of the stack.
        In this case, only parameters of CScript functions are visible
        (as there is no information about what variables are active)
        and no values are pushed onto the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pushes nothing) when the index is
        greater than the number of active local variables.
        </p>

        <!-- cs_setlocal -->
        <hr><h3><a name="cs_setlocal"><code>cs_setlocal</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *cs_setlocal (cs_State *C, const cs_Debug *ar, int n);</pre>
        <p>
        Sets the value of a local variable of a given activation record.
        It assigns the value on the top of the stack to the variable and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index is
        greater than the number of active local variables.
        <br/><br/>
        Parameters <code>ar</code> and <code>n</code> are as in the function
        <a href="#cs_getlocal"><code>cs_getlocal</code></a>.
        </p>

        <!-- cs_getupvalue -->
        <hr><h3><a name="cs_getupvalue"><code>cs_getupvalue</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *cs_getupvalue (cs_State *C, int index, int n);</pre>
        <p>
        Gets information about the <code>n</code>-th upvalue of the closure
        at the given index.
        It pushes the upvalue's value onto the stack and returns its name.
        Returns <code>NULL</code> (and pushes nothing) when the index
        <code>n</code> is greater than the number of upvalues.
        </p>

        <!-- cs_setupvalue -->
        <hr><h3><a name="cs_setupvalue"><code>cs_setupvalue</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *cs_setupvalue (cs_State *C, int index, int n);</pre>
        <p>
        Sets the value of a closure's upvalue.
        It assigns the value on the top of the stack to the upvalue and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index
        <code>n</code> is greater than the number of upvalues.
        <br/><br/>
        Parameters <code>funcindex</code> and <code>n</code> are as in
        the function <a href="#cs_getupvalue"><code>cs_getupvalue</code></a>.
        </p>




        <h1>5 &ndash; <a name="5">The Auxiliary Library</h1>
        <p>
        The <em>auxiliary library</em> provides several convenient functions
        to interface C with CScript.
        While the basic API provides the primitive functions for all
        interactions between C and CScript, the auxiliary library provides
        higher-level functions for some common tasks.
        <br/><br/>
        All functions and types from the auxiliary library are defined in
        header file <code>cauxlib.h</code> and have a prefix <code>csL_</code>.
        <br/><br/>
        All functions in the auxiliary library are built on top of the basic
        API, and so they provide nothing that cannot be done with that API.
        Nevertheless, the use of the auxiliary library ensures more
        consistency to your code.
        <br/><br/>
        Several functions in the auxiliary library use internally some
        extra stack slots.
        When a function in the auxiliary library uses less than five slots,
        it does not check the stack size; it simply assumes that there are
        enough slots.
        <br/><br/>
        Several functions in the auxiliary library are used to check
        C&nbsp;function arguments.
        Because the error message is formatted for arguments
        (e.g., "<code>bad argument #1</code>"), you should not use these
        functions for other stack values.
        <br/><br/>
        Functions called <code>csL_check*</code> always raise an error if
        the check is not satisfied.
        </p>


        <h2>5.1 &ndash; <a name="5.1">Functions and Types</a></h2>
        <p>Here we list all functions and types from the auxiliary library:</p>

        <hr><h3><a name="csL_error"><code>csL_error</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error (cs_State *C, const char *fmt, ...);</pre>
        <p>
        Raises an error.
        The error message format is given by <code>fmt</code> plus any extra
        arguments, following the same rules of
        <a href="#cs_push_fstring"><code>cs_push_fstring</code></a>.
        It also adds at the beginning of the message the file name and
        the line number where the error occurred, if this information is
        available.
        <br/><br/>
        This function never returns, but it is an idiom to use it in
        C&nbsp;functions as <code>return csL_error(<em>args</em>)</code>.
        </p>

        <hr><h3><a name="csL_error_arg"><code>csL_error_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error_arg (cs_State *C, int arg, const char *extra);</pre>
        <p>
        Raises an error reporting a problem with argument <code>arg</code>
        of the C&nbsp;function that called it, using a standard message
        that includes <code>extra</code> as a comment:
        <pre>
    bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extra</em>)</pre>
        This function never returns.
        </p>

        <hr><h3><a name="csL_error_type"><code>csL_error_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error_type (cs_State *C, int arg, const char *tname);</pre>
        <p>
        Raises a type error for the argument <code>arg</code> of the
        C&nbsp;function that called it, using a standard message;
        <code>tname</code> is a "name" for the expected type.
        This function never returns.
        </p>

        <hr><h3><a name="csL_check_number"><code>csL_check_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Number csL_check_number (cs_State *C, int arg);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a number
        and returns this number converted to a <code>cs_Number</code>.
        </p>

        <hr><h3><a name="csL_check_integer"><code>csL_check_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Integer csL_check_integer (cs_State *C);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is an integer
        and returns this integer.
        </p>

        <hr><h3><a name="csL_check_lstring"><code>csL_check_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_check_lstring (cs_State *C, int arg, size_t *l);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a string
        and returns this string;
        if <code>l</code> is not <code>NULL</code> fills its referent
        with the string's length.
        <br/><br/>
        This function uses
        <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_check_type"><code>csL_check_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_type (cs_State *C, int arg, int t);</pre>
        <p>
        Checks whether the function argument <code>arg</code> has type
        <code>t</code>.
        See <a href="#cs_type"><code>cs_type</code></a> for the encoding of
        types for <code>t</code>.
        </p>

        <hr><h3><a name="csL_check_any"><code>csL_check_any</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_any (cs_State *C, int arg);</pre>
        <p>
        Checks whether the function has an argument of any type
        (including <b>nil</b>) at position <code>arg</code>.
        </p>

        <hr><h3><a name="csL_check_stack"><code>csL_check_stack</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_stack (cs_State *C, int sz, const char *msg);</pre>
        <p>
        Grows the stack size to <code>top + sz</code> elements,
        raising an error if the stack cannot grow to that size.
        <code>msg</code> is an additional text to go into the error message
        (or <code>NULL</code> for no additional text).
        </p>

        <!-- TODO -->
        <hr><h3><a name="csL_check_userdata"><code>csL_check_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void *csL_check_userdata (cs_State *C, int arg, const char *vmtname);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a full userdata
        and if it's <a href="#cs_VMT">vmt</a> is equal to the
        <code>vmtname</code> in the registry table, if true, this returns
        the pointer to the <em>fulluserdata</em>
        (see <a href="#cs_to_userdata"><code>cs_to_userdata</code></a>),
        otherwise it raises error.
        </p>

        <hr><h3><a name="csL_check_option"><code>csL_check_option</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_option (cs_State *C
                       int arg,
                       const char *dfl,
                       const char *const opts[]);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a string and
        searches for this string in the array <code>opts</code>
        (which must be NULL-terminated).
        Returns the index in the array where the string was found.
        Raises an error if the argument is not a string or if the string
        cannot be found.
        <br/><br/>
        If <code>dfl</code> is not <code>NULL</code>, the function uses
        <code>dfl</code> as a default value when there is no argument
        <code>arg</code> or when this argument is <b>nil</b>.
        <br/><br/>
        This is a useful function for mapping strings to C&nbsp;enums.
        (The usual convention in CScript libraries is to use strings instead of
        numbers to select options.)
        </p>

        <hr><h3><a name="csL_opt_number"><code>csL_opt_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Number csL_opt_number (cs_State *C, int arg, cs_Number dfl);</pre>
        <p>
        If the function argument <code>arg</code> is a number, returns this
        number as a <code>cs_Number</code>.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt_integer"><code>csL_opt_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Integer csL_opt_integer (cs_State *C, int arg, cs_Integer dfl);</pre>
        <p>
        If the function argument <code>arg</code> is an integer, returns this
        integer.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt_lstring"><code>csL_opt_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_opt_lstring (cs_State *C,
                             int arg,
                             const char *dfl,
                             size_t *l);</pre>
        <p>
        If the function argument <code>arg</code> is a string, returns this
        string.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        <br/><br/>
        If <code>l</code> is not <code>NULL</code>, fills its referent with
        the result's length.
        If the result is <code>NULL</code> (only possible when returning
        <code>dfl</code> and <code>dfl == NULL</code>), its length is
        considered zero.
        <br/><br/>
        This function uses
        <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_loadfile"><code>csL_loadfile</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int csL_loadfile (cs_State *C, const char *filename);</pre>
        <p>
        Loads a file as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to
        load the chunk in the file named <code>filename</code>.
        If <code>filename</code> is <code>NULL</code>, then it loads from
        the standard input.
        <br/><br/>
        This function returns the same results as
        <a href="#cs_load"><code>cs_load</code></a> or
        <a href="#CS_ERRFILE"><code>CS_ERRFILE</code></a> for file-related
        errors.
        <br/><br/>
        As <a href="#cs_load"><code>cs_load</code></a>, this function only
        loads the chunk; it does not run it.
        </p>

        <hr><h3><a name="csL_loadstring"><code>csL_loadstring</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_loadstring (cs_State *C, const char *s);</pre>
        <p>
        Loads a string as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to
        load the chunk in the zero-terminated string <code>s</code>.
        </p>

        <hr><h3><a name="csL_loadbuffer"><code>csL_loadbuffer</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_loadbuffer (cs_State *C,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>
        <p>
        Loads a buffer as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to load
        the chunk in the buffer pointed to by <code>buff</code> with size
        <code>sz</code>.
        <br/><br/>
        This function returns the same results as
        <a href="#cs_load"><code>cs_load</code></a>.
        <code>name</code> is the chunk name, used for debug information and
        error messages.
        </p>

        <hr><h3><a name="csL_to_lstring"><code>csL_to_lstring</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_to_lstring (cs_State *C, int index, size_t *len);</pre>
        <p>
        Converts any CScript value at the given index to a C&nbsp;string
        in a reasonable format.
        The resulting string is pushed onto the stack and also
        returned by the function (see <a href="#4.1.3">&sect;4.1.3</a>).
        If <code>len</code> is not <code>NULL</code>, the function also sets
        <code>*len</code> with the string length.
        </p>

        <hr><h3><a name="csL_to_fulluserdata"><code>csL_to_fulluserdata</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void csL_to_fulluserdata (cs_State *C, int index);</pre>
        <p>
        Returns pointer to the <em>full userdata</em> at the given index.
        If the value is not <em>full userdata</em> this returns NULL.
        </p>

        <hr><h3><a name="csL_to_lightuserdata"><code>csL_to_lightuserdata</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void csL_to_lightuserdata (cs_State *C, int index);</pre>
        <p>
        Returns pointer to the <em>light userdata</em> at the given index.
        If the value is not <em>light userdata</em> this returns NULL.
        </p>

        <hr><h3><a name="csL_where"><code>csL_where</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_where (cs_State *C, int level);</pre>
        <p>
        Pushes onto the stack a string identifying the current position
        of the control at level <code>lvl</code> in the call stack.
        Typically this string has the following format:
        <pre>
    <em>chunkname</em>:<em>currentline</em>:</pre>
        Level&nbsp;0 is the running function, level&nbsp;1 is the function
        that called the running function, etc.
        <br/><br/>
        This function is used to build a prefix for error messages.
        </p>

        <hr><h3><a name="csL_fileresult"><code>csL_fileresult</code></a></h3><p>
        <span class="apii">[-0, +(1|3), <em>m</em>]</span>
        <pre>void csL_fileresult (cs_State *C, int ok, const char *fname);</pre>
        <p>
        This function produces the return values for file-related functions
        in the standard library.
        </p>

        <hr><h3><a name="csL_get_property"><code>csL_get_property</code></a></h3><p>
        <span class="apii">[-1, +1, <em>m</em>]</span>
        <pre>int csL_get_property (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_get_field"><code>cs_get_field</code></a>
        except if the field is <b>nil</b> then it will try and get the method
        under the same key
        (via <a href="#cs_get_class"><code>cs_get_class</code></a>
        and <a href="#cs_get_method"><code>cs_get_method</code></a>).
        <br/><br/>
        This function returns the type of the field or method (aka property),
        and replaces the key on top of the stack with the value of the
        property.
        <br/>
        (Note that if the function returned
        <a href="#CS_TNIL"><code>CS_TNIL</code></a>, it means that both the
        field and method are <b>nil</b>).
        </p>

        <hr><h3><a name="csL_set_index"><code>csL_set_index</code></a></h3><p>
        <span class="apii">[-1, +0, <em>v</em>]</span>
        <pre>void csL_set_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Equivalent to <a href="#cs_set_index"><code>cs_set_index</code></a>
        but this invokes error if the index <code>i</code> is negative.
        </p>

        <hr><h3><a name="csL_newstate"><code>csL_newstate</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_State *csL_newstate (void);</pre>
        <p>
        Creates a new CScript state.
        It calls <a href="#cs_newstate"><code>cs_newstate</code></a> with an
        allocator based on the ISO&nbsp;C allocation functions and then
        sets a warning function and a panic function
        (see <a href="#4.4">&sect;4.4</a>) that print messages to standard
        error output.
        <br/><br/>
        Returns the new state or <code>NULL</code> if there is a memory
        allocation error.
        </p>

        <hr><h3><a name="csL_get_subtable"><code>csL_get_subtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>int csL_get_subfield (cs_State *C, int index, const char *field);</pre>
        <p>
        Ensures that the value <code>obj[field]</code>, where <code>obj</code>
        is the value at the given index, is a table, and pushes that table
        onto the stack.
        Returns true if it finds a previous table there and false if it
        creates a new table.
        </p>

        <hr><h3><a name="csL_importf"><code>csL_importf</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void csL_importf (cs_State *C, const char *modname,
                  cs_CFunction openf, int global);</pre>
        <p>
        If <code>package.loaded[modname]</code> is not true,
        calls the function <code>openf</code> with the string
        <code>modname</code> as an argument and sets the call result to
        <code>package.loaded[modname]</code>, as if that function has been
        called through <a href="#import"><code>import</code></a>.
        <br/><br/>
        If <code>global</code> is true, also stores the module into the
        global <code>modname</code>.
        <br/><br/>
        Leaves a copy of the module on the stack.
        </p>

        <!-- TODO -->
        <hr><h3><a name="csL_test_userdata"><code>csL_test_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *csL_test_userdata (cs_State *C, int index, const char *vmtname);</pre>
        <p>
        This function works like
        <a href="#csL_check_userdata"><code>csL_check_userdata</code></a>,
        except that, when the test fails, it returns <code>NULL</code>
        instead of raising an error.
        </p>

        <hr><h3><a name="csL_traceback"><code>csL_traceback</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_traceback (cs_State *C, cs_State *C1,
                    int level, const char *msg);</pre>
        <p>
        Creates and pushes a traceback of the stack <code>C1</code>.
        If <code>msg</code> is not <code>NULL</code>, it is appended
        at the beginning of the traceback.
        The <code>level</code> parameter tells at which level to start the
        traceback.
        </p>

        <hr><h3><a name="csL_setfuncs"><code>csL_setfuncs</code></a></h3><p>
        <span class="apii">[-nup, +0, <em>m</em>]</span>
        <pre>void csL_setfuncs (cs_State *C, const cs_Entry *l, int nup);</pre>
        <p>
        Registers all functions in the array <code>l</code>
        (see <a href="#cs_Entry"><code>cs_Entry</code></a>) into the table or
        instance on the top of the stack (below optional upvalues, see next).
        <br/><br/>
        When <code>nup</code> is not zero, all functions are created with
        <code>nup</code> upvalues, initialized with copies of the
        <code>nup</code> values previously pushed on the stack on top of
        the table or instance.
        These values are popped from the stack after the registration.
        <br/><br/>
        A function with a <code>NULL</code> value represents a placeholder,
        which is filled with <b>false</b>.
        </p>

        <hr><h3><a name="csL_gsub"><code>csL_gsub</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_gsub (cs_State *C, const char *s,
               const char *p, const char *r);</pre>
        <p>
        Creates a copy of string <code>s</code>, replacing any occurrence of
        the string <code>p</code> with the string <code>r</code>.
        Pushes the resulting string on the stack and returns it.
        Think of it as string substitution <code>s/{p}/{r}/g</code>, the input
        being the function argument <code>s</code>.
        </p>

        <hr><h3><a name="csL_ref"><code>csL_ref</code></a></h3><p>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void csL_ref (cs_State *C, int l);</pre>
        <p>
        Creates and returns a <em>reference</em>, in the list at index
        <code>l</code>, for the object on the top of the stack
        (and pops the object).
        <br/><br/>
        A reference is a unique integer index into that list.
        As long as you do not manually add entries into the list
        <code>l</code>, <a href="#csL_ref"><code>csL_ref</code></a> ensures
        the uniqueness of the index it returns.
        You can retrieve an object referred by the reference <code>r</code>
        by calling <code>cs_get_index(C, l, r)</code>.
        The function <a href="#csL_unref"><code>csL_unref</code></a> frees
        a reference.
        <br/><br/>
        If the object on the top of the stack is <b>nil</b>,
        <a href="#csL_ref"><code>csL_ref</code></a> returns the constant
        <a name="CS_REFNIL"><code>CS_REFNIL</code></a>.
        The constant <a name="CS_NOREF"><code>CS_NOREF</code></a> is
        guaranteed to be different from any reference returned by
        <a href="#csL_ref"><code>csL_ref</code></a>.
        </p>

        <hr><h3><a name="csL_unref"><code>csL_unref</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void csL_unref (cs_State *C, int l, int ref);</pre>
        <p>
        Releases the reference <code>ref</code> from the list at index
        <code>l</code> (see <a href="#csL_ref"><code>csL_ref</code></a>).
        The entry is removed from the list, so that the referred object
        can be collected.
        The reference <code>ref</code> is also freed to be used again.
        <br/><br/>
        If <code>ref</code> is <a href="#CS_NOREF"><code>CS_NOREF</code></a>
        or <a href="#CS_REFNIL"><code>CS_REFNIL</code></a>,
        <a href="#csL_unref"><code>csL_unref</code></a> does nothing.
        </p>

        <hr><h3><a name="csL_checkversion"><code>csL_checkversion</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_checkversion (cs_State *C);</pre>
        <p>
        Checks whether the code making the call and the CScript library being
        called are using the same version of CScript.
        </p>

        <hr><h3><a name="csL_typename"><code>csL_typename</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *csL_typename (cs_State *C, int index);</pre>
        <p>
        Returns the name of the type of the value at the given index.
        </p>

        <hr><h3><a name="csL_check_string"><code>csL_check_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_check_string (cs_State *C, int index);</pre>
        <p>
        Checks whether the function argument <code>index</code> is a string
        and returns this string.
        <br/><br/>
        This function uses <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its result,
        so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_opt_string"><code>csL_opt_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_opt_string (cs_State *C, int index, const char *dflt);</pre>
        <p>
        If the function argument <code>index</code> is a string, returns
        this string.
        If this argument is absent or is <b>nil</b>, returns <code>dflt</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt"><code>csL_opt</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>T csL_opt (C, func, index, dflt);</pre>
        <p>
        This macro is defined as follows:
        <pre>
    (cs_is_noneornil(C, index) ? (dfl) : fn(C, index))</pre>
        In words, if the argument <code>index</code> is <b>nil</b> or absent,
        the macro results in the default <code>dflt</code>.
        Otherwise, it results in the result of calling <code>func</code>
        with the state <code>C</code> and the argument index <code>index</code>
        as arguments.
        Note that it evaluates the expression <code>dflt</code> only if
        needed.
        </p>

        <hr><h3><a name="csL_check_arg"><code>csL_check_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_arg (cs_State *C,
                    int cond,
                    int index,
                    const char *extramsg);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error with a standard message
        (see <a href="#csL_error_arg"><code>csL_error_arg</code></a>).
        </p>

        <hr><h3><a name="csL_expect_arg"><code>csL_expect_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_expect_arg (cs_State *C
                    int cond,
                    int index,
                    const char *tname);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error about the type of the argument
        at <code>index</code> with a standard message
        (see <a href="#csL_error_type"><code>csL_error_type</code></a>).
        </p>

        <hr><h3><a name="csL_push_fail"><code>csL_push_fail</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_push_fail (cs_State *C);</pre>
        <p>
        Pushes the <b>fail</b> value onto the stack
        (see <a href="#6">&sect;6</a>).
        </p>

        <hr><h3><a name="csL_newlibtable"><code>csL_newlibtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_newlibtable (cs_State *C, const cs_Entry l[]);</pre>
        <p>
        Creates a new table with a size optimized to store all entries in
        the array <code>l</code> (but does not actually store them).
        It is intended to be used in conjunction with
        <a href="#csL_setfuncs"><code>csL_setfuncs</code></a>
        (see <a href="#csL_newlib"><code>csL_newlib</code></a>).
        <br/><br/>
        It is implemented as a macro.
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="csL_newlib"><code>csL_newlib</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_newlib (cs_State *C, const cs_Entry l[]);</pre>
        <p>
        Creates a new table and registers there
        the functions in the list <code>l</code>.
        <br/><br/>
        It is implemented as the following macro:
        <pre>
    (csL_newlibtable(C,l), csL_setfuncs(C,l,0))</pre>
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="csL_get_registrytable"><code>csL_get_registrytable</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_get_registrytable (cs_State *C, const char *name);</pre>
        <p>
        Equivalent to <code>t[name]</code> where <code>t</code> is the
        registry table located in the registry under index
        <a href="#CS_RINDEX_REGTABLE"><code>CS_RINDEX_REGTABLE</code></a>
        (see <a href="#4.3">&sect;4.3</a>).
        </p>

        <hr><h3><a name="csL_get_rsubtable"><code>csL_get_rsubtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_get_rsubtable (cs_State *C, const char *name);</pre>
        <p>
        Equivalent to
        <a href="#csL_get_subtable"><code>csL_get_subtable</code></a>, except
        here the object being indexed is the registry table which is pushed
        on top of the stack, and later removed after the operation.
        </p>

        <hr><h3><a name="csL_get_gsubtable"><code>csL_get_gsubtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_get_gsubtable (cs_State *C, const char *name);</pre>
        <p>
        Equivalent to
        <a href="#csL_get_subtable"><code>csL_get_subtable</code></a>, except
        here the object being indexed is the global table which is pushed
        on top of the stack, and later removed after the operation.
        </p>

        <hr><h3><a name="csL_intop"><code>csL_intop</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer csL_intop (op, x, y);</pre>
        <p>
        Perform arithmetic operation <code>op</code> on
        <a href="#cs_Integer"><code>cs_Integer</code></a> values
        <code>x</code> and <code>y</code> with wrap-around semantics,
        as the CScript core does.
        <br/><br/>
        This is implemented as the following macro:
        <pre>
    ((cs_Integer)((cs_Unsigned)(x) op (cs_Unsigned)(y)))</pre>
        </p>

        <hr><h3><a name="csL_Buffer"><code>csL_Buffer</code></a></h3><p>
        <pre>typedef struct csL_Buffer csL_Buffer;</pre>
        <p>
        Type for a <em>string buffer</em>.
        <br/><br/>
        A string buffer allows C&nbsp;code to build CScript strings piecemeal.
        Its pattern of use is as follows:
        <ul>
            <li>
                First declare a variable <code>b</code> of type
                <a href="#csL_Buffer"><code>csL_Buffer</code></a>.
            </li>
            <li>
                Then initialize it with a call
                <code>csL_buff_init(C, &amp;b)</code>.
            </li>
            <li>
                Then add string pieces to the buffer calling any of
                the <code>csL_buff_push*</code> functions.
            </li>
            <li>
                Finish by calling <code>csL_buff_end(&amp;b)</code>.
                This call leaves the final string on the top of the stack.
            </li>
        </ul>
        If you know beforehand the maximum size of the resulting string,
        you can initialize the buffer by preallocate the its size with
        <a href="#csL_buff_initsz"><code>csL_buff_initsz</code></a>.
        <br/><br/>
        During its normal operation, a string buffer uses a variable number
        of stack slots.
        So, while using a buffer, you cannot assume that you know where
        the top of the stack is.
        You can use the stack between successive calls to buffer operations
        as long as that use is balanced;
        that is, when you call a buffer operation, the stack is at the same
        level it was immediately after the previous buffer operation.
        (The only exception to this rule is
        <a href="#csL_buff_push_stack"><code>csL_buff_push_stack</code></a>.)
        After calling <a href="#csL_buff_end"><code>csL_buff_end</code></a>,
        the stack is back to its level when the buffer was initialized,
        plus the final string on its top.
        </p>

        <hr><h3><a name="csL_buffptr"><code>csL_buffptr</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>char *csL_buffptr (csL_Buffer *B);</pre>
        <p>
        Returns the address of the current content of buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        Note that any addition to the buffer may invalidate this address.
        </p>

        <hr><h3><a name="csL_bufflen"><code>csL_bufflen</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>size_t csL_bufflen (csL_Buffer *B);</pre>
        <p>
        Returns the length of the current content of buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buffadd"><code>csL_buffadd</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void csL_buffadd (csL_Buffer *B, size_t n);</pre>
        <p>
        Adds to the buffer <code>B</code> a string of length <code>n</code>
        previously copied to the buffer area
        (see <a href="#csL_buff_initsz"><code>csL_buff_initsz</code></a>).
        </p>

        <hr><h3><a name="csL_buffsub"><code>csL_buffsub</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void csL_buffsub (csL_Buffer *B, int n);</pre>
        <p>
        Removes <code>n</code> bytes from the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        The buffer must have at least that many bytes.
        </p>

        <hr><h3><a name="csL_buff_push"><code>csL_buff_push</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push (csL_Buffer *B, char c);</pre>
        <p>
        Adds the byte <code>c</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buff_init"><code>csL_buff_init</code></a></h3><p>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>void csL_buff_init (cs_State *C, csL_Buffer *B);</pre>
        <p>
        Initializes a buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        This function does not allocate any space;
        the buffer must be declared as a variable.
        </p>

        <hr><h3><a name="csL_buff_initsz"><code>csL_buff_initsz</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *csL_buff_initsz (cs_State *C, csL_Buffer *B, size_t sz);</pre>
        <p>
        Equivalent to the sequence
        <a href="#csL_buff_init"><code>csL_buff_init</code></a>,
        <a href="#csL_buff_ensure"><code>csL_buff_ensure</code></a>.
        </p>

        <hr><h3><a name="csL_buff_ensure"><code>csL_buff_ensure</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *csL_buff_ensure (csL_Buffer *B, size_t sz);</pre>
        <p>
        Returns an address to a space of size <code>sz</code>
        where you can copy a string to be added to buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        After copying the string into this space you must call
        <a href="#csL_buffadd"><code>csL_buffadd</code></a> with the size
        of the string to actually add it to the buffer.
        </p>

        <hr><h3><a name="csL_buff_push_lstring"><code>csL_buff_push_lstring</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_lstring (csL_Buffer *B, const char *s, size_t l);</pre>
        <p>
        Adds the string pointed to by <code>s</code> with length
        <code>l</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        The string can contain embedded zeros.
        </p>

        <hr><h3><a name="csL_buff_push_string"><code>csL_buff_push_string</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_string (csL_Buffer *B, const char *s);</pre>
        <p>
        Adds the zero-terminated string pointed to by <code>s</code>
        to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buff_push_stack"><code>csL_buff_push_stack</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_stack (csL_Buffer *B);</pre>
        <p>
        Adds the value on the top of the stack to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        Pops the value.
        <br/><br/>
        This is the only function on string buffers that can (and must)
        be called with an extra element on the stack, which is the value
        to be added to the buffer.
        </p>

        <hr><h3><a name="csL_buff_push_gsub"><code>csL_buff_push_gsub</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_gsub (csL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre>
        <p>
        Adds a copy of the string <code>s</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>),
        replacing any occurrence of the string <code>p</code> with the
        string <code>r</code>.
        </p>

        <hr><h3><a name="csL_buff_end"><code>csL_buff_end</code></a></h3><p>
        <span class="apii">[-?, +1, <em>m</em>]</span>
        <pre>void csL_buff_end (csL_Buffer *B);</pre>
        <p>
        Finishes the use of buffer <code>B</code> leaving the final string
        on the top of the stack.
        </p>




        <hr><h1>6 &ndash; <a name="6">The Standard Libraries</h1>
        <p>
        The standard CScript libraries provide useful functions that are
        implemented in&nbsp;C through the C&nbsp;API.
        Most of these functions provide essential service to the
        language that is not express via the language syntax and others
        provide access to outside services (e.g., I/O).
        <br/><br/>
        All libraries are implemented through the official C&nbsp;API and are
        provided as separate C&nbsp;modules.
        <br/><br/>
        The notation <b>fail</b> means a false value representing some kind of
        failure (the recommendation is to always test the success of these
        functions with <code>(!status)</code>, instead of
        <code>(status == nil)</code>).
        <br/><br/>
        Currently, CScript has the following standard libraries:
        <ul>
            <li>basic library (<a href="#6.1">&sect;6.1</a>);</li>
            <li>package library(<a href="#6.2">&sect;6.2</a>);</li>
            <li>math library (<a href="#6.3">&sect;6.3</a>);</li>
            <li>string library (<a href="#6.4">&sect;6.4</a>);</li>
            <li>input-output library (<a href="#6.5">&sect;6.5</a>);</li>
            <li>operating system library (<a href="#6.6">&sect;6.6</a>);</li>
        </ul>
        To have access to these libraries, the C&nbsp;host program should
        call the <a href="#csL_openlibs"><code>csL_openlibs</code></a>
        function, which opens all standard libraries.
        Alternatively, the host program can open them individually by using
        <a href="#csL_importf"><code>csL_importf</code></a> to call
        <a name="csopen_base"><code>csopen_base</code></a> (for the basic library),
        <a name="csopen_package"><code>csopen_package</code></a> (for the package library),
        <a name="csopen_string"><code>csopen_string</code></a> (for the string library),
        <a name="csopen_math"><code>csopen_math</code></a> (for the math library),
        <a name="csopen_io"><code>csopen_io</code></a> (for the I/O library),
        <a name="csopen_os"><code>csopen_os</code></a> (for the operating system library),
        These functions are declared in <a name="cslib.h"><code>cslib.h</code></a>
        </p>


        <h2>6.1 &ndash; <a name="6.1">Basic Library</a></h2>
        <p>
        The basic library provides core functions to CScript.
        </p>

        <!-- error -->
        <hr/><h3><a name="error"><code>error (message [, level])</code></a></h3>
        <p>
        Raises an error with <code>message</code> as the error object.
        This function never returns.
        <br/> <br/>
        Usually, <code>error</code> adds some information about the error position
        at the beginning of the message, if the message is a string.
        The <code>level</code> argument specifies how to get the error position.
        With level&nbsp;0 (the default), the error position is where the
        <code>error</code> function was called.
        Level&nbsp;1 points the error to where the function
        that called <code>error</code> was called; and so on.
        Passing a negative level (e.g., <code>-1</code>) avoids the addition
        of error position information to the message.
        </p>

        <!-- assert -->
        <hr/><h3><a name="assert"><code>assert (v [, message])</code></a></h3>
        <p>
        Raises an error if the value of its argument <code>v</code> is false
        (i.e., <b>nil</b> or <b>false</b>); otherwise, returns all its arguments.
        <br/><br/>
        In case of error, <code>message</code> is the error object;
        when absent, it defaults to "<code>assertion failed!</code>"
        </p>

        <!-- gc -->
        <hr/><h3><a name="gc"><code>gc ([opt [, arg]])</code></a></h3>
        <p>
        This function is a generic interface to the garbage collector.
        It performs different functions according to its first argument,
        <code>opt</code>:
        <ul>
            <li>
                <b>"<code>collect</code>": </b>
                Performs a full garbage-collection cycle.
                This is the default option.
            </li>
            <li>
                <b>"<code>stop</code>": </b>
                Stops automatic execution of the garbage collector.
                The collector will run only when explicitly invoked,
                until a call to restart it.
            </li>
            <li>
                <b>"<code>restart</code>": </b>
                Restarts automatic execution of the garbage collector.
            </li>
            <li>
                <b>"<code>count</code>": </b>
                Returns the total memory in use by CScript in Kbytes.
                The value has a fractional part, so that it multiplied by
                1024 gives the exact number of bytes in use by CScript.
            </li>
            <li>
                <b>"<code>step</code>": </b>
                Performs a garbage-collection step.
                The step "size" is controlled by <code>arg</code>.
                With a zero value, the collector will perform one basic
                (indivisible) step.
                For non-zero values, the collector will perform as if that
                amount of memory (in Kbytes) had been allocated by CScript.
                Returns <b>true</b> if the step finished a collection cycle.
            </li>
            <li>
                <b>"<code>isrunning</code>": </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
            <li>
                <b>"<code>incremental</code>": </b>
                Change the collector mode to incremental.
                This option can be followed by three numbers:
                the garbage-collector pause, the step multiplier,
                and the step size. A zero means to not change that value.
                Returns the previous collector mode as a string (which
                is always "incremental").
            </li>
        </ul>
        This function should not be called by a finalizer (<code>__gc</code>).
        </p>

        <!-- load -->
        <hr/><h3><a name="load"><code>load (chunk [, chunkname])</code></a></h3>
        <p>
        Loads a chunk.
        <br/><br/>
        If <code>chunk</code> is a string, the chunk is this string.
        If <code>chunk</code> is a function, <code>load</code> calls it
        repeatedly to get the chunk pieces. Each call to <code>chunk</code>
        must return a string that concatenates with previous results.
        A return of an empty string, <b>nil</b>, or no value signals the end
        of the chunk.
        If there are no syntactic errors, <code>load</code> returns the
        compiled chunk as a function; otherwise, it returns <b>fail</b> plus
        the error message.
        <br/> <br/>
        <code>chunkname</code> is used as the name of the chunk for error
        messages and debug information.
        When absent, it defaults to <code>chunk</code>, if <code>chunk</code>
        is a string, or to "<code>=(load)</code>" otherwise.
        </p>

        <!-- loadfile -->
        <hr/><h3><a name="loadfile"><code>loadfile ([filename])</code></a></h3>
        <p>
        Similar to <a href="#load"><code>load</code></a>,
        but gets the chunk from file <code>filename</code> or from the
        standard input, if no file name is given.
        </p>

        <!-- runfile -->
        <hr/><h3><a name="runfile"><code>runfile ([filename])</code></a></h3>
        <p>
        Opens the named file and executes its content as a CScript chunk.
        When called without arguments, <code>runfile</code> executes the
        content of the standard input (<code>stdin</code>).
        Returns all values returned by the chunk.
        In case of errors, <code>runfile</code> propagates the error to its
        caller (that is, <code>runfile</code> does not run in protected mode).
        </p>

        <!-- getmetamethod -->
        <hr/><h3><a name="getmetamethod"><code>getmetamethod (v, name)</code></a></h3>
        <p>
        Returns the metamethod of the given <code>v</code> or <b>nil</b>
        if <code>v</code> does not have virtual method table and/or the
        <code>v</code> does not implement the metamethod <code>name</code>.
        </p>

        <!-- next -->
        <hr/><h3><a name="next"><code>next (v [, index])</code></a></h3>
        <p>
        Allows a program to traverse of all keys or fields of <code>v</code>.
        Its first argument is a table or instance and its second argument
        is an index into this table or instance.
        A call to <code>next</code> returns the next index of the
        <code>v</code> and its associated value.
        When called with <b>nil</b> as its second argument, <code>next</code>
        returns an initial index and its associated value.
        When called with the last index, or with <b>nil</b> in an empty
        table or instance without fields, <code>next</code> returns <b>nil</b>.
        If the second argument is absent, then it is interpreted as <b>nil</b>.
        In particular, you can use <code>next(v)</code> to check whether a
        table is empty or if the instance has no fields.
        <br/><br/>
        The order in which the indices are enumerated is not specified.
        <br/><br/>
        You should not assign any value to a non-existent field in a table
        during its traversal. You may however modify existing fields.
        In particular, you may set existing fields to <b>nil</b>.
        </p>

        <!-- pairs -->
        <hr/><h3><a name="pairs"><code>pairs (v)</code></a></h3>
        <p>
        Returns three values: the <a href="#next"><code>next</code></a>
        function, <code>v</code>, and <b>nil</b>, so that the construction

        <pre>   foreach k,v in pairs(v) <em>body</em></pre>

        will iterate over all key&ndash;value pairs of <code>v</code>;
        <code>v</code> should be either a <em>table</em> or <em>instance</em>.
        <br/><br/>
        See function <a href="next"><code>next</code></a> for the caveats
        of modifying the table or instance fields during its traversal.
        </p>

        <!-- ipairs -->
        <hr/><h3><a name="ipairs"><code>ipairs (l)</code></a></h3>
        <p>
        Returns three values (an iterator function, the list <code>l</code>,
        and -1)
        so that the construction

        <pre>   foreach i,v in ipairs(l) <em>body</em></pre>

        will iterate over the index&ndash;value pairs
        (<code>0,l[0]</code>), (<code>1,l[1]</code>), ...,
        up to the <em>length</em> of the list <code>a</code>.
        </p>

        <!-- pcall -->
        <hr/><h3><a name="pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>
        </p>
        Calls the function <code>f</code> with the given arguments in
        <em>protected mode</em>.
        This means that any error inside&nbsp;<code>f</code> is not propagated;
        instead, <code>pcall</code> catches the error and returns a status code.
        Its first result is the status code (a boolean), which is <b>true</b>
        if the call succeeds without errors.
        In such case, <code>pcall</code> also returns all results from the call,
        after this first result.
        <br/><br/>
        In case of any error, <code>pcall</code> returns <b>false</b> plus the error object.
        Note that errors caught by <code>pcall</code> do not call a message handler.
        <p>

        <!-- xpcall -->
        <hr/><h3><a name="xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>
        <p>
        This function is similar to <a href="#pcall"><code>pcall</code></a>,
        except that it sets a new message handler <code>msgh</code>.
        </p>

        <!-- print -->
        <hr/><h3><a name="print"><code>print (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Receives any number of arguments and prints their values to
        <code>stdout</code>, converting each argument to a string
        following the same rules of <a href="#tostring"><code>tostring</code></a>.
        <br/><br/>
        The function <code>print</code> is not intended for formatted output,
        but only as a quick way to show a value, for instance for debugging.
        For complete control over the output, use
        <a href="#io.printf"><code>io.printf</code></a> and
        <a href="#io.write"><code>io.write</code></a>.
        </p>

        <!-- warn -->
        <hr/><h3><a name="warn"><code>warn (msg1, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Emits a warning with a message composed by the concatenation
        of all its arguments (which should be strings).
        <br/><br/>
        By convention, a one-piece message starting with '<code>@</code>'
        is intended to be a <em>control message</em>,
        which is a message to the warning system itself.
        In particular, the standard warning function in CScript
        recognizes the control messages "<code>@off</code>",
        to stop the emission of warnings, and "<code>@on</code>", to
        (re)start the emission; it ignores unknown control messages.
        </p>

        <!-- len -->
        <hr/><h3><a name="len"><code>len (v)</code></a></h3>
        <p>
        Returns the length of the object <code>v</code>, which must be
        list, table, instance or a string.
        <br/> <br/>
        <em>List</em> length is total number of elements in use (one index
        above the biggest index that was set);
        <em>table</em> length is total number of keys with non-<b>nil</b>
        values; <em>instance</em> length is total number of fields with
        non-<b>nil</b> values; <em>string</em> length is size of string in
        bytes.
        <br/><br/>
        Returns an integer.
        </p>

        <!-- rawequal -->
        <hr/><h3><a name="rawequal"><code>rawequal (v1, v2)</code></a></h3>
        <p>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        <br/><br/>
        Returns a boolean.
        </p>

        <!-- rawget -->
        <hr/><h3><a name=rawget""><code>rawget (v, index)</code></a></h3>
        <p>
        Gets the real value of <code>v[index]</code>,
        without calling the <code>__getidx</code> metamethod.
        <code>v</code> must be an instance and <code>index</code> may be
        any CScript value.
        </p>

        <!-- rawset -->
        <hr/><h3><a name="rawset"><code>rawset (v, index, value)</code></a></h3>
        <p>
        Sets the real value of <code>v[index]</code> to <code>value</code>,
        without using the <code>__setidx</code> metamethod.
        <code>v</code> must be an instance;
        <code>index</code> any value different from <b>nil</b> and NaN;
        <code>value</code> any CScript value.
        <br/><br/>
        This function returns <code>v</code>.
        </p>

        <!-- getargs -->
        <hr/><h3><a name="getargs"><code>getargs (index, &middot;&middot;&middot;)</code></a></h3>
        <p>
        If <code>index</code> is a number, this returns all arguments after
        argument at number <code>index</code> (starting from 0); a negative
        number indexes from the end (-1 is the last argument).
        Otherwise, <code>index</code> must be one of these strings:
        <code>"list"</code>, <code>"table"</code> or <code>"len"</code>.
        <br/><br/>
        In case <code>index</code> is <code>"list"</code> or
        <code>"table"</code> string then <code>getargs</code> returns
        the total number of extra arguments it received; <code>"list"</code>
        returns the extra arguments inside the list, <code>"table"</code>
        returns the extra arguments inside the table where each argument is
        a key with <b>true</b> value.
        <br/><br/>
        However if <code>index</code> is 
        <code>"len"</code> string, then <code>getargs</code> returns integer
        corresponding to total number of extra arguments.
        </p>

        <!-- tonumber -->
        <hr/><h3><a name="tonumber"><code>tonumber (v, [, base])</code></a></h3>
        <p>
        When called with no <code>base</code>,
        <code>tonumber</code> tries to convert its argument to a number.
        If the argument <code>v</code> is already a number or a string
        convertible to a number, then <code>tonumber</code> returns this
        number and overflow flag; otherwise, it returns <b>fail</b>.
        <br/><br/>
        The conversion of strings can result in integers or floats.
        The string may have leading and trailing spaces and a sign.
        The conversion mimics C standard library functions <code>strtod</code>
        and <code>strtol</code>.
        <br/><br/>
        When called with <code>base</code>, then <code>v</code> must be a
        string to be interpreted as an integer numeral in that base.
        The base may be any integer between 2 and 36, inclusive.
        In bases above&nbsp;10, the letter '<code>A</code>' (in either upper
        or lower case) represents&nbsp;10, '<code>B</code>' represents&nbsp;11,
        and so forth, with '<code>Z</code>' representing 35.
        If the string <code>v</code> is not a valid numeral in the given base,
        the function returns <b>fail</b>.
        </p>

        <!-- tostring -->
        <hr/><h3><a name="tostring"><code>tostring (v)</code></a></h3>
        <p>
        Receives a value of any type and converts it to a string in a
        human-readable format.
        </p>

        <!-- typeof -->
        <hr/><h3><a name="typeof"><code>typeof (v)</code></a></h3>
        <p>
        Returns the type of its only argument, coded as a string.
        The possible results of this function are
        "<code>nil</code>" (a string, not the value <b>nil</b>),
        "<code>number</code>",
        "<code>string</code>",
        "<code>boolean</code>",
        "<code>list</code>",
        "<code>table</code>",
        "<code>function</code>",
        "<code>class</code>",
        "<code>instance</code>",
        "<code>thread</code>",
        and "<code>userdata</code>".
        </p>

        <hr/><h3><a name="getclass"><code>getclass (v)</code></a></h3>
        <p>
        Returns the class of the instance <code>v</code>.
        If <code>v</code> is not an instance, the function returns
        <b>fail</b>.
        </p>

        <!-- __G -->
        <hr/><h3><a name="__G"><code>__G</code></a></h3>
        <p>
        A global variable (not a function) that holds the global table
        (see <a href="#2.2">&sect;2.2</a>).
        </p>

        <!-- __VERSION -->
        <hr/><h3><a name="__VERSION"><code>__VERSION</code></a></h3>
        A global variable (not a function) that holds a string containing
        the running CScript version.
        <br/>
        The current value of this variable is "<code>CScript 1.0</code>".
        </p>


        <h2>6.2 &ndash; <a name="6.2">Package Library</a></h2>
        <p>
        The package library provides basic facilities for loading modules
        in CScript.
        It exports one function directly in the global environment:
        <a href="#import"><code>import</code></a>.
        Everything else is exported in the table
        <a name="package"><code>package</code></a>.

        <hr><h3><a name="import"><code>import (modname)</code></a></h3>
        <p>
        Loads the given module.
        The function starts by looking into the
        <a href="#package.loaded"><code>package.loaded</code></a> table
        to determine whether <code>modname</code> is already loaded.
        If it is, then <code>import</code> returns the value stored
        at <code>package.loaded[modname]</code>.
        (The absence of a second result in this case
        signals that this call did not have to load the module.)
        Otherwise, it tries to find a <em>loader</em> for the module.
        <br/><br/>
        To find a loader, <code>import</code> is guided by the list
        <a href="#package.searchers"><code>package.searchers</code></a>.
        Each item in this list is a search function, that searches for the
        module in a particular way.
        By changing this list, we can change how <code>import</code> looks
        for a module.
        The following explanation is based on the default configuration
        for <a href="#package.searchers"><code>package.searchers</code></a>.
        <br/><br/>
        First <code>import</code> queries <code>package.preload[modname]</code>.
        If it has a value, this value (which must be a function) is the loader.
        Otherwise <code>import</code> searches for a CScript loader using the
        path stored in <a href="#package.path"><code>package.path</code></a>.
        If that also fails, it searches for a C&nbsp;loader using the
        path stored in <a href="#package.cpath"><code>package.cpath</code></a>.
        If that also fails, it tries an <em>all-in-one</em> loader
        (see <a href="#package.searchers"><code>package.searchers</code></a>).
        <br/><br/>
        Once a loader is found, <code>import</code> calls the loader with
        two arguments:
        <code>modname</code> and an extra value, a <em>loader data</em>,
        also returned by the searcher.
        The loader data can be any value useful to the module;
        for the default searchers,
        it indicates where the loader was found.
        (For instance, if the loader came from a file,
        this extra value is the file path.)
        If the loader returns any non-nil value,
        <code>import</code> assigns the returned value to
        <code>package.loaded[modname]</code>.
        If the loader does not return a non-nil value and
        has not assigned any value to <code>package.loaded[modname]</code>,
        then <code>import</code> assigns <b>true</b> to this entry.
        In any case, <code>import</code> returns the
        final value of <code>package.loaded[modname]</code>.
        Besides that value, <code>import</code> also returns as a second
        result the loader data returned by the searcher,
        which indicates how <code>import</code> found the module.
        <br/><br/>
        If there is any error loading or running the module,
        or if it cannot find any loader for the module,
        then <code>import</code> raises an error.
        </p>

        <hr><h3><a name="package.config"><code>package.config</code></a></h3>
        <p>
        A string describing some compile-time configurations for packages.
        This string is a sequence of lines:
        <ul>
            <li>
                The first line is the directory separator string.
                Default is '<code>\</code>' for Windows and '<code>/</code>'
                for all other systems.
            </li>
            <li>
                The second line is the character that separates templates
                in a path.
                Default is '<code>;</code>'.
            </li>
            <li>
                The third line is the string that marks the substitution
                points in a template.
                Default is '<code>?</code>'.
            </li>
            <li>
                The fourth line is a string that, in a path in Windows,
                is replaced by the executable's directory.
                Default is '<code>!</code>'.
            </li>
            <li>
                The fifth line is a mark to ignore all text after it
                when building the <code>csopen_</code> function name.
                Default is '<code>-</code>'.
            </li>
        </ul>
        </p>

        <hr><h3><a name="package.cpath"><code>package.cpath</code></a></h3>
        <p>
        A string with the path used by <a href="#import"><code>import</code></a>
        to search for a C&nbsp;loader.
        <br/><br/>
        CScript initializes the C&nbsp;path
        <a href="#package.cpath"><code>package.cpath</code></a> in the same
        way it initializes the CScript path
        <a href="#package.path"><code>package.path</code></a>,
        using the environment variable
        <a name="CS_CPATH_1_0"><code>CS_CPATH_1_0</code></a>,
        or the environment variable
        <a name="CS_CPATH"><code>CS_CPATH</code></a>,
        or a default path defined in <code>csconf.h</code>.
        </p>

        <hr><h3><a name="package.loaded"><code>package.loaded</code></a></h3>
        <p>
        A table used by <a href="#import"><code>import</code></a> to control
        which modules are already loaded.
        When you import a module <code>modname</code> and
        <code>package.loaded[modname]</code> is not false,
        <a href="#import"><code>import</code></a> simply returns the value
        stored there.
        <br/><br/>
        This variable is only a reference to the real table;
        assignments to this variable do not change the
        table used by <a href="#import"><code>import</code></a>.
        The real table is in the registry table
        (see <a href="#4.3">&sect;4.3</a>) under the key
        <a name="CS_LOADED_TABLE"><code>CS_LOADED_TABLE</code></a>.
        </p>

        <hr><h3><a name="package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>
        <p>
        Dynamically links the host program with the C&nbsp;library
        <code>libname</code>.
        <br/><br/>
        If <code>funcname</code> is "<code>*</code>", then it only links with
        the library, making the symbols exported by the library available
        to other dynamically linked libraries.
        Otherwise, it looks for a function <code>funcname</code> inside the
        library and returns this function as a C&nbsp;function.
        So, <code>funcname</code> must follow the
        <a href="#cs_CFunction"><code>cs_CFunction</code></a> prototype
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        This is a low-level function.
        It completely bypasses the package and module system.
        Unlike <a href="#import"><code>import</code></a>, it does not perform
        any path searching and does not automatically adds extensions.
        <code>libname</code> must be the complete file name of the
        C&nbsp;library, including if necessary a path and an extension.
        <code>funcname</code> must be the exact name exported by the
        C&nbsp;library (which may depend on the C&nbsp;compiler and linker
        used).
        <br/><br/>
        This functionality is not supported by ISO&nbsp;C.
        As such, it is only available on some platforms
        (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems
        that support the <code>dlfcn</code> standard).
        <br/><br/>
        This function is inherently insecure, as it allows CScript to call
        any function in any readable dynamic library in the system.
        (CScript calls any function assuming the function has a proper
        prototype and respects a proper protocol
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        Therefore, calling an arbitrary function in an arbitrary dynamic
        library more often than not results in an access violation.)
        </p>

        <hr><h3><a name="package.path"><code>package.path</code></a></h3>
        <p>
        A string with the path used by<a href="#import"><code>import</code></a>
        to search for a CScript loader.
        <br/><br/>
        At start-up, CScript initializes this variable with the value of the
        environment variable <a name="CS_PATH_1_0"><code>CS_PATH_1_0</code></a>
        or the environment variable <a name="CS_PATH"><code>CS_PATH</code></a>
        or with a default path defined in <code>csconf.h</code>, if those
        environment variables are not defined.
        A "<code>;;</code>" in the value of the environment variable is
        replaced by the default path.
        </p>

        <hr><h3><a name="package.preload"><code>package.preload</code></a></h3>
        <p>
        A table to store loaders for specific modules
        (see <a href="#import"><code>import</code></a>).
        <br/><br/>
        This variable is only a reference to the real table;
        assignments to this variable do not change the table used by
        <a href="#import"><code>import</code></a>.
        The real table is stored in the registry table
        (see <a href="#4.3">&sect;4.3</a>), under the key
        <a name="CS_PRELOAD_TABLE"><code>CS_PRELOAD_TABLE</code></a>.
        </p>

        <hr><h3><a name="package.searchers"><code>package.searchers</code></a></h3>
        <p>
        List used by <a href="#import"><code>import</code></a> to control
        how to find modules.
        <br/><br/>
        Each entry in this list is a <em>searcher function</em>.
        When looking for a module, <a href="#import"><code>import</code></a>
        calls each of these searchers in ascending order, with the module name
        (the argument given to <a href="#import"><code>import</code></a>) as
        its sole argument.
        If the searcher finds the module, it returns another function,
        the module <em>loader</em>, plus an extra value,
        a <em>loader data</em>, that will be passed to that loader and
        returned as a second result by
        <a href="#import"><code>import</code></a>.
        If it cannot find the module, it returns a string explaining why
        (or <b>nil</b> if it has nothing to say).
        <br/><br/>
        CScript initializes this list with four searcher functions.
        <br/><br/>
        The first searcher simply looks for a loader in the
        <a href="#package.preload"><code>package.preload</code></a> list.
        <br/><br/>
        The second searcher looks for a loader as a CScript library,
        using the path stored at
        <a href="#package.path"><code>package.path</code></a>.
        The search is done as described in function
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        <br/><br/>
        The third searcher looks for a loader as a C&nbsp;library,
        using the path given by the variable
        <a href="#package.cpath"><code>package.cpath</code></a>.
        Again, the search is done as described in function
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        For instance, if the C&nbsp;path is the string

        <pre>
    "./?.so;./?.dll;/usr/local/?/init.so"</pre>

        the searcher for module <code>foo</code> will try to open the files
        <code>./foo.so</code>, <code>./foo.dll</code>,
        and <code>/usr/local/foo/init.so</code>, in that order.
        Once it finds a C&nbsp;library, this searcher first uses a dynamic
        link facility to link the application with the library.
        Then it tries to find a C&nbsp;function inside the library to
        be used as the loader.
        The name of this C&nbsp;function is the string "<code>csopen_</code>"
        concatenated with a copy of the module name where each dot
        is replaced by an underscore.
        Moreover, if the module name has a hyphen, its suffix after
        (and including) the first hyphen is removed.
        For instance, if the module name is <code>a.b.c-v2.1</code>,
        the function name will be <code>csopen_a_b_c</code>.
        <br/><br/>
        The fourth searcher tries an <em>all-in-one loader</em>.
        It searches the C&nbsp;path for a library for the root name of the
        given module.
        For instance, when requiring <code>a.b.c</code>, it will search for
        a C&nbsp;library for <code>a</code>.
        If found, it looks into it for an open function for
        the submodule;
        in our example, that would be <code>csopen_a_b_c</code>.
        With this facility, a package can pack several C&nbsp;submodules
        into one single library, with each submodule keeping its original
        open function.
        <br/><br/>
        All searchers except the first one (preload) return as the extra
        value the file path where the module was found, as returned by
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        The first searcher always returns the string "<code>:preload:</code>".
        <br/><br/>
        Searchers should raise no errors and have no side effects in CScript.
        (They may have side effects in C, for instance by linking the
        application with a library.)
        </p>

        <hr><h3><a name="package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>
        </p>
        Searches for the given <code>name</code> in the given <code>path</code>.
        <br/><br/>
        A path is a string containing a sequence of <em>templates</em>
        separated by semicolons.
        For each template, the function replaces each interrogation mark
        (if any) in the template with a copy of <code>name</code> wherein
        all occurrences of <code>sep</code> (a dot, by default) were replaced
        by <code>rep</code> (the system's directory separator, by default),
        and then tries to open the resulting file name.
        <br/><br/>
        For instance, if the path is the string

        <pre>
    "./?.csp;./?.lc;/usr/local/?/init.csp"</pre>

        the search for the name <code>foo.a</code> will try to open the
        files <code>./foo/a.csp</code>, <code>./foo/a.lc</code>, and
        <code>/usr/local/foo/a/init.csp</code>, in that order.
        <br/><br/>
        Returns the resulting name of the first file that it can open in read
        mode (after closing the file), or <b>fail</b> plus an error message
        if none succeeds.
        (This error message lists all file names it tried to open.)
        </p>


        <h2>6.3 &ndash; <a name="6.3">String Library</a></h2>
        <p>
        This library provides generic functions for string manipulation,
        such as finding and extracting substrings and other common operations.
        All of the functionality is provided in the global table 
        <a name="string"><code>string</code></a>.
        When indexing strings in CScript, the first character is at position
        &nbsp;0 (same as in C).
        Indices are allowed to be negative and are interpreted as indexing
        backwards, from the end of the string.
        Thus, the last character is at position -1, and so on.
        <br/><br/>
        The string library assumes one-byte character encodings.
        </p>

        <!-- string.split -->
        <hr/><h3><a name="string.split"><code>string.split (s [, sep [, maxsplit]])</code></a></h3>
        <p>
        Return list of the words in the string, using sep as the delimiter
        string.
        If <code>maxsplit</code> is given, at most maxsplit splits are done
        (thus, the list will have at most <code>maxsplit+1</code> elements).
        If <code>maxsplit</code> is not specified or is <b>nil</b>, then there
        is no limit on the number of splits (all possible splits are made).
        <br/>
        If <code>sep</code> is given, consecutive delimiters are not grouped
        together and are deemed to delimit empty strings.
        <br/>
        For example

        <pre>
    string.split("1,,2", ",")</pre>

        returns

        <pre>
    ["1", "", "2"]</pre>

        The <code>sep</code> argument is a string so it may consist of
        multiple characters.
        <br/>
        For example

        <pre>
    string.split("1&lt;&gt;2&lt;&gt;3", "&lt;&gt;")</pre>

        returns

        <pre>
    ["1", "2", "3"]</pre>

        Splitting an empty string with a specified separator returns

        <pre>
    [""]</pre>

        If <code>sep</code> is not specified or is <b>nil</b>, a different
        splitting algorithm is applied: runs of consecutive whitespace are
        regarded as a single separator, and the result will contain no empty
        strings at the start or end if the string has leading or trailing
        whitespace.
        Consequently, splitting an empty string or a string consisting of
        just whitespace without specified separator or a <b>nil</b> separator
        returns

        <pre>
    []</pre>

        (an empty list).
        <br/>
        For example

        <pre>
    string.split(" 1  2   3  ");</pre>

        returns

        <pre>
    ["1", "2", "3"]</pre>

        and

        <pre>
    string.split("  1  2   3  ", nil, 1);</pre>

    returns

        <pre>
    ["1", "2   3  "]</pre>
        
        (notice how the last element has no leading whitespace).
        </p>

        <!-- string.split -->
        <hr/><h3><a name="rsplit"><code>rsplit (s [, sep [, maxsplit]])</code></a></h3>
        <p>
        Similar to <a href="#string.split"><code>string.split</code></a> but it does the
        splitting in reverse, starting from the end of <code>s</code>.
        The returned value is also an list holding the splits which are
        in reverse order.
        </p>

        <!-- string.startswith -->
        <hr/><h3><a name="string.startswith"><code>string.startswith (s, prefix [, i [, j]])</code></a></h3>
        <p>
        Checks if the string <code>s</code> starts with the <code>prefix</code>
        string and it returns the index in <code>s</code> after the
        <code>prefix</code>.
        If the <code>prefix</code> is not the prefix of <code>s</code> this
        returns <b>fail</b> and the non-matching index in <code>s</code>.
        There are two optional arguments, start index to where to start the
        search from in <code>s</code>, and end index that specifies to
        stop comparing the string after that index.
        In case where start index <code>i</code> and end index <code>j</code>
        is specified and <code>i</code> is greater than <code>j</code> or the
        range between <code>i</code> and <code>j</code> is smaller than the
        length of <code>prefix</code> string, <b>fail</b> is returned
        (as usual) and -1 representing invalid index.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/><br/>
        Example
        <pre>
    local res, i = string.startswith("This is it!", "This", 0, -1);
    assert(res == 4 and i == nil);</pre>
        </p>

        <!-- reverse -->
        <hr/><h3><a name="reverse"><code>reverse (s)</code></a></h3>
        <p>
        Returns reversed string <code>s</code>.
        <br/><br/>
        Example
        <pre>
    local s = string.reverse("test");
    assert(s == "tset");</pre>
        </p>

        <!-- string.repeat -->
        <hr/><h3><a name="string.repeat"><code>string.repeat (s, n, [, sep])</code></a></h3>
        <p>
        Returns string <code>s</code> that is repeated <code>n</code> times.
        Optional separator <code>sep</code> can be specified which will
        separate repeated string <code>s</code>.
        If <code>n</code> is less than 1, empty string will be returned.
        <br/><br/>
        Example:
        <pre>
    local s = string.repeat("69", 4, "&lt;420&gt;");
    assert(s == "69&lt;420&gt;69&lt;420&gt;69&lt;420&gt;69");</pre>
        </p>

        <!-- string.join -->
        <hr/><h3><a name="string.join"><code>string.join (s, v)</code></a></h3>
        <p>
        Return a string which is the concatenation of the strings in the
        list or table <code>v</code>.
        The separator between elements is the string <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    local t = ["Love", "Anger", "Fury", "Peace"];
    local s = string.join(", ", t);
    assert(s == "Love, Anger, Fury, Peace");</pre>
        </p>

        <!-- string.fmt -->
        <hr/><h3><a name="string.fmt"><code>string.fmt (fmts, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns a formatted version of its variable number of arguments
        following the description given in its first argument,
        which must be a string.
        The format string follows the same rules as the ISO&nbsp;C function
        <code>sprintf</code>.
        The only differences are that the conversion specifiers and modifiers
        <code>F</code>, <code>n</code>, <code>*</code>, <code>h</code>,
        <code>L</code>, and <code>l</code> are not supported and that there
        is an extra specifier, <code>q</code>.
        Both width and precision, when present, are limited to two digits.
        <br/><br/>
        The specifier <code>q</code> formats booleans, nil, numbers, and
        strings in a way that the result is a valid constant in CScript
        source code.
        Booleans and nil are written in the obvious way
        (<code>true</code>, <code>false</code>, <code>nil</code>).
        Floats are written in hexadecimal,
        to preserve full precision.
        A string is written between double quotes,
        using escape sequences when necessary to ensure that
        it can safely be read back by the CScript interpreter.
        For instance, the call

        <pre>
    string.fmt('%q', "a string with \"quotes\" and \n new line")</pre>

        may produce the string:

        <pre>
    "a string with \"quotes\" and \
     new line"</pre>

        This specifier does not support modifiers (flags, width, precision).
        <br/><br/>
        The conversion specifiers
        <code>A</code>, <code>a</code>, <code>E</code>, <code>e</code>,
        <code>f</code>, <code>G</code>, and <code>g</code> all expect a
        number as argument.
        The specifiers <code>c</code>, <code>d</code>, <code>i</code>,
        <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
        expect an integer.
        <br/><br/>
        The specifier <code>s</code> expects a string;
        if its argument is not a string,
        it is converted to one following the same rules of
        <a href="#tostring"><code>tostring</code></a>.
        If the specifier has any modifier, the corresponding string argument
        should not contain embedded zeros.
        <br/><br/>
        The specifier <code>p</code> formats the pointer returned by
        <a href="#cs_to_pointer"><code>cs_to_pointer</code></a>.
        That gives a unique string identifier for tables, userdata,
        threads, strings, and functions.
        For other values (numbers, nil, booleans),
        this specifier results in a string representing
        the pointer <code>NULL</code>.
        <br/><br/>
        Example:
        <pre>
    local s = string.fmt("Hello, %s", "World!");
    assert(s == "Hello, World");</pre>
        </p>

        <!-- string.toupper -->
        <hr/><h3><a name="string.toupper"><code>string.toupper (s [, i [, j]])</code></a></h3>
        <p>
        Returns string <code>s</code> which has all its characters converted
        to uppercase.
        Start index <code>i</code> and end index <code>j</code> can be
        specified to define range of the operation.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, this function returns <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    assert(string.toupper("blabla", 3, 4) == "blaBLa");</pre>
        </p>

        <!-- string.tolower -->
        <hr/><h3><a name="string.tolower"><code>string.tolower (s [, i [, j]])</code></a></h3>
        <p>
        Returns string <code>s</code> which has all its characters converted
        to lowercase.
        Start index <code>i</code> and end index <code>j</code> can be
        specified to define range of the operation.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, this function returns <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    assert(string.tolower("BLABLA", 3, 4) == "BLAblA");</pre>
        </p>

        <!-- string.find -->
        <hr/><h3><a name="string.find"><code>string.find (s, sub [, i [, j]])</code></a></h3>
        <p>
        Return the lowest index in the string <code>s</code> where substring
        <code>sub</code> is found, such that <code>sub</code> is contained in
        the slice s[i:j].
        Optional arguments <code>i</code> and <code>j</code> are interpreted
        as in slice notation. Return <b>fail</b> if <code>sub</code> is not
        found.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        <br/><br/>
        Example:
        <pre>
    assert(string.find("Hello, World", "llo") == 2);</pre>
        </p>

        <!-- string.rfind -->
        <hr/><h3><a name="string.rfind"><code>string.rfind (s, sub [, i [, j]])</code></a></h3>
        <p>
        Similar to <a href="#string.find"><code>string.find</code></a>,
        except the search for <code>sub</code> is done in reverse.
        <br/><br/>
        Example:
        <pre>
    assert(string.rfind("Hello, Hello", "llo") == 9);</pre>
        </p>

        <!-- string.replace -->
        <hr/><h3><a name="string.replace"><code>string.replace (s, sub, new [, n])</code></a></h3>
        <p>
        Return a copy of the string <code>s</code> with all occurrences of
        substring <code>sub</code> replaced by <code>new</code>.
        If the optional argument <code>n</code> is given, only the first
        <code>n</code> occurrences are replaced.
        <br/><br/>
        Example:
        <pre>
    assert(string.replace("Hello, Hello", "ll", "LL", 1) == "HeLLo, Hello");</pre>
        </p>

        <!-- string.substr -->
        <hr/><h3><a name="string.substr"><code>string.substr (s [, i [, j]])</code></a></h3>
        <p>
        Returns the substring of <code>s</code> that starts at <code>i</code>
        and continues up to (including) <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns the empty string.
        <br/><br/>
        Example:
        <pre>
    assert(string.substr("Hello, Hello", 2, -4) == "llo, He");</pre>
        </p>

        <!-- string.swapcase -->
        <hr/><h3><a name="string.swapcase"><code>string.swapcase (s [, i [, j]])</code></a></h3>
        <p>
        Swaps case of characters of string <code>s</code> in range starting
        from index <code>i</code> up to (including) <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    assert(string.swapcase("hi, HI") == "HI, hi");</pre>
        </p>

        <!-- string.swapupper -->
        <hr/><h3><a name="string.swapupper"><code>string.swapupper (s [, i [, j]])</code></a></h3>
        <p>
        Swaps lowercase characters to uppercase of string <code>s</code> in
        range starting from index <code>i</code> up to (including)
        <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    assert(string.swapupper("hi, HI") == "HI, HI");</pre>
        </p>

        <!-- string.swaplower -->
        <hr/><h3><a name="string.swaplower"><code>string.swaplower (s [, i [, j]])</code></a></h3>
        <p>
        Swaps uppercase characters to lowercase of string <code>s</code> in
        range starting from index <code>i</code> up to (including)
        <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <br/><br/>
        Example:
        <pre>
    assert(string.swaplower("hi, HI") == "hi, hi");</pre>
        </p>

        <!-- string.byte -->
        <hr/><h3><a name="string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
        <p>
        Returns the internal numeric codes of the characters
        <code>s[i]</code>, <code>s[i+1]</code>, ..., <code>s[j]</code>.
        <br/><br/>
        The default value for <code>i</code> is&nbsp;0;
        <br/>
        The default value for <code>j</code> is&nbsp;i;
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, or the string <code>s</code> is empty,
        the function will not return any results.
        <br/><br/>
        Example:
        <pre>
    local a, b = string.byte("ok");
    assert(a == 'o');
    assert(b == nil);</pre>
        </p>

        <!-- string.bytes -->
        <hr/><h3><a name="string.bytes"><code>string.bytes (s [, i [, j]])</code></a></h3>
        <p>
        Similar to <a href="#string.byte"><code>string.byte</code></a>,
        except this returns results in an list.
        <br/><br/>
        The default value for <code>i</code> is&nbsp;0.
        <br/>
        The default value for <code>j</code> is&nbsp;-1.
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, or the string <code>s</code> is empty,
        the function will not return any results.
        <br/><br/>
        Example:
        <pre>
    local a = string.bytes("Hello");
    assert(len(a) == 5);
    assert(a[0] == 'H');
    assert(a[1] == 'e');
    assert(a[2] == 'l');
    assert(a[3] == 'l');
    assert(a[4] == 'o');
    assert(a[5] == nil);</pre>
        </p>


        <h2>6.4 &ndash; <a name="6.4">Math Library</a></h2>
        <p>
        This library provides basic mathematical functions.
        It provides all its functions and constants inside the table
        <a name="math"><code>math</code></a>.
        Functions with the annotation "<code>integer/float</code>" give
        integer results for integer arguments
        and float results for non-integer arguments.
        The rounding functions
        <a href="math.ceil"><code>math.ceil</code></a>,
        <a href="math.floor"><code>math.floor</code></a>,
        and <a href="math.modf"><code>math.modf</code></a>
        return an integer when the result fits in the range of an integer,
        or a float otherwise.
        </p>

        <!-- math.abs -->
        <hr/><h3><a name="math.abs"><code>math.abs (x)</code></a></h3>
        <p>
        Returns the maximum value between <code>x</code> and <code>-x</code>.
        (integer/float)
        <br/><br/>
        Example:
        <pre>
    assert(math.abs(-5) == 5);
    assert(math.abs(5) == 5);
    assert(math.abs(-5.25) == 5.25);
    assert(math.abs(5.25) == 5.25);</pre>
        </p>

        <!-- math.acos -->
        <hr/><h3><a name="math.acos"><code>math.acos (x)</code></a></h3>
        <p>
        Returns the arc cosine of <code>x</code> (in radians).
        <br/><br/>
        Example:
        <pre>
    assert(math.acos(1) == 0);
    assert(math.acos(1.2) != math.acos(1.2));</pre>
        </p>

        <!-- math.asin -->
        <hr/><h3><a name="math.asin"><code>math.asin (x)</code></a></h3>
        <p>
        Returns the arc sine of <code>x</code> (in radians).
        <br/><br/>
        Example:
        <pre>
    assert(math.asin(0) == 0);
    assert(math.asin(1.2) != math.asin(1.2));</pre>
        </p>

        <!-- math.atan -->
        <hr/><h3><a name="math.atan"><code>math.atan (y [, x])</code></a></h3>
        <p>
        Returns the arc tangen of <code>y/x</code> (in radians),
        using the sign of both arguments to find the quadrant of the result.
        It also handles correctly the case of <code>x</code> being zero.
        <br/><br/>
        The default value for <code>x</code> is 1, so that the call
        <code>math.atan(y)</code> returns the arc tangent of <code>y</code>.
        <br/><br/>
        Example:
        <pre>
    assert(math.atan(0) == 0);
    assert(math.atan(0, 2.5) == 0);</pre>
        </p>

        <!-- math.ceil -->
        <hr/><h3><a name="math.ceil"><code>math.ceil (x)</code></a></h3>
        <p>
        Returns the smallest integral value greater than or equal to
        <code>x</code>.
        <br/><br/>
        Example:
        <pre>
    assert(math.ceil(1) == 1);
    assert(math.ceil(0.6) == 1);
    assert(math.ceil(0.5) == 1);
    assert(math.ceil(0.49) == 1);
    assert(math.ceil(-15) == -15);
    assert(math.ceil(-15.6) == -15);
    assert(math.ceil(-15.5) == -15);
    assert(math.ceil(-15.4) == -15);</pre>
        </p>

        <!-- math.cos -->
        <hr/><h3><a name="math.cos"><code>math.cos (x)</code></a></h3>
        <p>
        Returns the cosine of <code>x</code> (assumed to be in radians).
        <br/><br/>
        Example:
        <pre>
    assert(math.cos(1) == 1);</pre>
        </p>

        <!-- math.deg -->
        <hr/><h3><a name="math.deg"><code>math.deg (x)</code></a></h3>
        <p>
        Converts the angle <code>x</code> from radians to degrees.
        <br/><br/>
        Example:
        <pre>
    assert(math.deg(math.pi) == 180);
    assert(math.deg(math.pi*2) == 360);</pre>
        </p>

        <!-- math.exp -->
        <hr/><h3><a name="math.exp"><code>math.exp (x)</code></a></h3>
        <p>
        Returns the value <em>e<sup>x</sup></em>
        (where <code>e</code> is the base of natural logarithms).
        <br/><br/>
        Example:
        <pre>
    print(math.exp(1));     # around 2.718281828459</pre>
        </p>

        <!-- math.floor -->
        <hr/><h3><a name="math.floor"><code>math.floor (x)</code></a></h3>
        <p>
        Returns the largest integral value less than or equal to
        <code>x</code>.
        <br/><br/>
        Example:
        <pre>
    assert(math.floor(1.2) == 1);
    assert(math.floor(1.5) == 1);
    assert(math.floor(1.6) == 1);
    assert(math.floor(-1.2) == -2);
    assert(math.floor(-1.5) == -2);
    assert(math.floor(-1.6) == -2);</pre>
        </p>

        <!-- math.fmod -->
        <hr/><h3><a name="math.fmod"><code>math.fmod (x, y)</code></a></h3>
        <p>
        Returns the remainder of the division of <code>x</code> by
        <code>y</code> that rounds the quotient towards zero. (integer/float)
        <br/><br/>
        Example:
        <pre>
    assert(math.fmod(2, 3) == 2);
    assert(math.fmod(2.5, 3.6) == 2.5);
    assert(math.fmod(3.1, 3.0) == 0.1);
    assert(math.fmod(-2.5, -3) == -2.5);
    assert(math.fmod(-2.5, 3) == -2.5);</pre>
        </p>

        <!-- math.huge -->
        <hr/><h3><a name="math.huge"><code>math.huge</code></a></h3>
        <p>
        The float value <code>HUGE_VAL</code>, a value greater than
        any other numeric value (almost always equal to <code>infinity</code>).
        <br/><br/>
        Example:
        <pre>
    assert(math.huge &gt;= inf);
    assert(math.huge &gt;= infinity);
    assert(-math.huge &lt;= -inf);
    assert(-math.huge &lt;= -infinity);</pre>
        </p>

        <!-- math.max -->
        <hr/><h3><a name="math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns the argument with the maximum value,
        according to the CScript operator <code>&lt;</code>.
        <br/><br/>
        Example:
        <pre>
    assert(math.max(2, 5, 9, 1) == 9);
    assert(math.max(inf, 2**50, -1000) == inf);</pre>
        </p>

        <!-- math.maxint -->
        <hr/><h3><a name="math.maxint"><code>math.maxint</code></a></h3>
        <p>
        An integer with the maximum value for an integer.
        </p>

        <!-- math.min -->
        <hr/><h3><a name="math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns the argument with the minimum value,
        according to the CScript operator <code>&lt;</code>.
        <pre>
    assert(math.min(2, 5, 9, 1) == 1);
    assert(math.min(inf, 2**50, -1000) == -1000);</pre>
        </p>

        <!-- math.minint -->
        <hr/><h3><a name="math.minint"><code>math.minint</code></a></h3>
        <p>
        An integer with the minimum value for an integer.
        </p>

        <!-- math.modf -->
        <hr/><h3><a name="math.modf"><code>math.modf (x)</code></a></h3>
        <p>
        Returns the integral part of <code>x</code> and the fractional part
        of <code>x</code>.
        Its second result is always a float.
        <pre>
    local ipart, fpart = math.modf(5.69);
    assert(ipart == 5 and fpart == 0.69);</pre>
        </p>

        <!-- math.pi -->
        <hr/><h3><a name="math.pi"><code>math.pi</code></a></h3>
        <p>
        The value of <em>&pi;</em>.
        </p>

        <!-- math.rad -->
        <hr/><h3><a name="math.rad"><code>math.rad (x)</code></a></h3>
        <p>
        Converts the angle <code>x</code> from degrees to radians.
        <br/><br/>
        Example:
        <pre>
    assert(math.rad(180) == math.pi);
    assert(math.rad(360) == math.pi*2);</pre>
        </p>

        <!-- math.srand -->
        <hr/><h3><a name="math.srand"><code>math.srand ([v])</code></a></h3>
        <p>
        Seeds pseudo-random number generator (PRNG).
        <br/>
        If <code>v</code> is not specified, CScript seeds the PRNG with
        its own implementation of generating seed.
        <br/>
        If <code>v</code> is a list or a table, the PRNG is seeded by the
        non-<b>nil</b> values inside the list or a table, if the value is
        collectable or has a pointer, its pointer is used as the seed value,
        otherwise the CScript generates the seed, in the way as if no
        arguments were provided.
        This is done for all the values inside the list or table.
        <br/>
        Finally if <code>v</code> is an integer, this integer is converted
        to unsigned integer, and is then used as the seed for the PRNG.
        </p>

        <!-- math.rand -->
        <hr/><h3><a name="math.rand"><code>math.rand ([m [, n]])</code></a></h3>
        <p>
        Returns a pseudo-random integer with uniform distribution.
        When called without arguments, the "random" integer is in range
        <em>[math.min, math.max]</em>.
        When called with two integers <code>m</code> and <code>n</code>,
        the "random" integer is in range <em>[m, n]</em>.
        When called with one integer <code>m</code>, the "random" integer
        is in range <em>[1, m]</em>.
        <br/><br/>
        This function uses the <code>MT19937-64</code>
        (64-bit Mersenne Twister) algorithm to produce psuedo-random 64-bit
        integers.
        <br/><br/>
        CScript initializes its pseudo-random generator with the equivalent
        of a call to <a href="#math.srand"><code>math.srand</code></a> with
        no arguments, so that <code>math.rand</code> should generate
        different sequences of results each time the program runs.
        <br/><br/>
        Example:
        <pre>
    local x = math.rand();
    assert(math.minint &lt;= x and x &lt;= math.maxint);
    x = math.rand(10);
    assert(1 &lt;= x and x &lt;= 10);
    x = math.rand(10, 50);
    assert(10 &lt;= x and x &lt;= 50);</pre>
        </p>

        <!-- math.randf -->
        <hr/><h3><a name="math.randf"><code>math.randf ()</code></a></h3>
        <p>
        Similar to <a href="#math.rand"><code>math.rand</code></a>, except
        this generates and returns a double-precision float in the range (0, 1).
        <br/><br/>
        Example:
        <pre>
    local x = math.randf();
    assert(0.0 &lt; x and x &lt; 1.0);
    x = -x;
    assert(-1.0 &lt; x and x &lt; 0);</pre>
        </p>

        <!-- math.sin -->
        <hr/><h3><a name="math.sin"><code>math.sin (x)</code></a></h3>
        <p>
        Returns the sine of <code>x</code> (assumed to be in radians).
        <br/><br/>
        Example:
        <pre>
    assert(math.sin(0) == 0);</pre>
        </p>

        <!-- math.sqrt -->
        <hr/><h3><a name="math.sqrt"><code>math.sqrt (x)</code></a></h3>
        <p>
        Returns the square root of <code>x</code>.
        (You can also use the expression <code>x**0.5</code> to compute this
        value.)
        <br/><br/>
        Example:
        <pre>
    assert(math.sqrt(4) == 2);
    assert(math.sqrt(4) == 4**0.5);</pre>
        </p>

        <!-- math.tan -->
        <hr/><h3><a name="math.tan"><code>math.tan (x)</code></a></h3>
        <p>
        Returns the tangent of <code>x</code> (assumed to be in radians).
        <br/><br/>
        Example:
        <pre>
    assert(math.tan(0) == 0);</pre>
        </p>

        <!-- math.tointeger -->
        <hr/><h3><a name="math.tointeger"><code>math.tointeger (x)</code></a></h3>
        <p>
        If the value <code>x</code> is convertible to an integer,
        returns that integer.
        Otherwise, returns <b>fail</b>.
        <br/><br/>
        Example:
        <pre>
    assert(math.tointeger(3) == 3);
    assert(math.tointeger(5.0) == 5);
    assert(math.tointeger(5.1) == nil);
    assert(math.tointeger("5.2") == nil);</pre>
        </p>

        <!-- math.type -->
        <hr/><h3><a name="math.type"><code>math.type (x)</code></a></h3>
        <p>
        Returns "<code>integer</code>" if <code>x</code> is an integer,
        "<code>float</code>" if it is a float,
        or <b>fail</b> if <code>x</code> is not a number.
        <br/><br/>
        Example:
        <pre>
    assert(math.type(3) == "integer");
    assert(math.type(5.0) == "integer");
    assert(math.type(5.1) == "float");
    assert(math.type("5.2") == nil);</pre>
        </p>

        <!-- math.ult -->
        <hr/><h3><a name="math.ult"><code>math.ult (m, n)</code></a></h3>
        <p>
        Returns a boolean, <b>true</b> if and only if integer <code>m</code>
        is below integer <code>n</code> when they are compared as unsigned
        integers ("unsigned less than").
        <br/><br/>
        Example:
        <pre>
    assert(math.ult(3, 5) == true);
    assert(math.ult(5, 4) == false);
    assert(math.ult(-5, 4) == false);
    assert(math.ult(5, -4) == true);</pre>
        </p>




        <h2>6.5 &ndash; <a name="6.5">I/O Library</a></h2>
        <p>
        </p>




        <h2>6.6 &ndash; <a name="6.6">OS Library</a></h2>
        <p>
        </p>
    </body>
</html>
