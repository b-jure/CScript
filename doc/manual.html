<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width"/>
        <title>CScript 1.0 Reference Manual</title>
        <link rel="stylesheet" type="text/css" href="cscript.css">
        <link rel="stylesheet" type="text/css" href="index.css">
    </head>
    <body>
        <h1>CScript 1.0 Reference Manual</h1>
        <small>
            <p>
            Copyright &copy; 2020&ndash;2024 Lua.org, PUC-Rio;
            2024&ndash;2025 Jure BagiÄ‡.
            </p>
        </small>
        <div class="menubar">
            <a href="contents.html#contents">contents</a>
            &middot;
            <a href="contents.html#index">index</a>
        </div>




        <h1>1 &ndash; <a name="1">Introduction</a></h1>
        <p>
        CScript is a lightweight embeddable scripting language.
        C in CScript refers to the C programming language as it mimics its
        syntax (as much as possible).
        It's syntax supports various types of programming styles and it does
        not enforce any type/style upon the user (it has all the tools and the
        user chooses the tool for the job).
        <br/><br/>
        CScript is dynamically typed, it runs by interpreting bytecode with
        a stack-based virtual machine, and it's memory is automatically
        managed by the incremental garbage collection.
        <br/><br/>
        CScript is implemented as a library fully written in C, and to be
        compiled with any standard C/C++ compiler implementing C99 standard.
        CScript distribution includes a host program called
        <code>cscript</code>, which is the interpreter that uses CScript
        library.
        CScript is intended to be primarily used as lightweight embeddable
        scripting language but also as a stand-alone language that is easy
        to learn as it shares most of its syntax with the C programming
        language and <a href="https://www.lua.org/">Lua</a>.
        <br/><br/>
        CScript is free software, and is provided with no guarantees,
        as stated in its license.
        <br/><br/>
        This manual is subject to changes, as the language itself changes.
        However the reference manual is always valid for the same version of
        CScript distribution. If you spot the mistake or you think the manual
        is lacking in various places, please let me know
        (<a href="https://github.com/b-jure/cscript">link</a> to the official
        git[hub] repository).
        </p>




        <h1>2 &ndash; <a name="2">Basic Concepts</a></h1>
        <p>
        This section describes the basic concepts of the language.
        </p>


        <h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>
        <p>
        CScript is a dynamically types language.
        This means that variables do not have types; only values do.
        There are no type definitions in the language instead all values
        carry their own type.
        <br/><br/>
        All values in CScript are first-class values, meaning all values
        can be stored in variables (as is expected), passed as arguments
        to other functions and returned as results.
        <br/><br/>
        There are eleven basic types in CScript:
        <em>nil</em>, <em>boolean</em>, <em>number</em>, <em>string</em>, 
        <em>function</em>, <em>userdata</em>, <em>thread</em>, <em>table</em>, 
        <em>array</em>, <em>class</em> and <em>instance</em>.
        <br/><br/>
        <!-- nil -->
        The type <em>nil</em> has one single value, <b>nil</b>, and is
        intended to represent absence of value.
        <br/><br/>
        <!-- boolean -->
        The type <em>boolean</em> has two values, <b>true</b> and <b>false</b>.
        Both <b>nil</b> and <b>false</b> make a condition false; they are
        collectively called <em>false values</em>
        (for example in C, we would consider <b>0</b> value as the
        <em>false value</em>).
        Any other value makes a condition true.
        So what is the difference between the <b>false</b> and <b>nil</b>?
        Here is a simple example, if we were to index a table with <b>nil</b>
        it would raise a runtime error; as said, use <b>nil</b> to indicate
        absence of value.
        <br/><br/>
        <!-- number -->
        The type <em>number</em> represents both integer and real
        (floating-point) numbers, using two subtypes: <em>integer</em> and
        <em>float</em> (as is indicated in the C&nbsp;API header).
        <br/>
        Standard CScript uses 64-bit integers and double-precision (64-bit)
        floats. Configuration header can be tinkered to allow 32-bit integers
        and/or single-precision (32-bit) floats, but this but would probably
        require internal patches (see <code>csconf.h</code> if interested).
        <br/>
        Any overflow when manipulating integer values <em>wrap around</em>,
        according to the usual rules of two-complement arithmetics.
        This holds both for negative (signed) and positive (unsigned) integers.
        <br/>
        The conversion between the two subtypes mimics C standard.
        For example, if we were to do a mathematical operation between the two
        numbers, one of them is <em>integer</em> and the other is
        <em>float</em>, before the operation <em>integer</em> would be
        converted to a <em>float</em>.
        Additionally before the operation if the both numbers are of type
        <em>float</em> but both have <em>integer</em> representation, then
        they would be converted to <em>integers</em> before the operation
        (this would result in a slower operation on processors that support
        float division but this behaviour can also be configured in CScript
        internals quite easily, check <code>cvm.c</code>).
        <br/><br/>
        <!-- string -->
        The type <em>string</em> represents immutable sequence of bytes.
        Strings can contain any 8-bit value, including embedded zeros
        ('<code>\0</code>').
        Internally CScript is encoding-agnostic; it makes no assumptions
        about the contents of a string.
        The length of any string in CScript must fit in a CScript integer.
        <br/><br/>
        <!-- function -->
        The type <em>function</em> can be a function written in CScript or
        C, both of which can be manipulated and called.
        <br/><br/>
        <!-- userdata -->
        The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data
        to be stored in a variable.
        A userdata value represents a block of raw memory.
        There are two kinds of userdata:
        <em>full userdata</em>, which is an object with a block of memory
        managed by CScript, and <em>light userdata</em>,
        which is simply a C&nbsp;pointer value.
        Userdata has no predefined operations in CScript except assignment
        and identity test (<code>==</code>).
        By using <em>VMTs</em> (virtual method tables), the programmer can
        define operations for full userdata values.
        Userdata values cannot be created or modified in CScript, only
        through the C&nbsp;API.
        This guarantees the integrity of data owned by the host program
        and C&nbsp;libraries.
        <br/><br/>
        <!-- table -->
        The type <em>table</em> implements associative arrays,
        that is, arrays that can have as indices not only numbers,
        but any CScript value except <b>nil</b> and NaN
        (<em>Not a Number</em> is a special floating-point value
        used by the IEEE 754 standard to represent undefined numerical
        results, such as <code>0/0</code>).
        <br/>
        Tables can be contain values of all types (except <b>nil</b>).
        Any key associated to the value <b>nil</b> is not considered part of
        the table. Conversely, any key that is not part of a table has
        an associated value <b>nil</b>.
        <br/>
        Tables can be indexed two different ways, given the key
        <code>name</code> we index the table <code>t</code> either as
        <code>t.name</code> or <code>t["name"]</code>.
        The array-like indexing is useful when we want to index the table
        with the value of the variable.
        <br/><br/>
        <!-- array -->
        The type <em>array</em> is a linear collection of values each
        identified by an <b>index</b>. Each <b>index</b> is positive integer
        value or 0 which is used to index the <em>array</em> in order to
        retrieve the value (variable values can also be used in place of literal
        integers). Negative integer indices are not allowed.
        <br/><br/>
        <!-- class -->
        The type <em>class</em> is useful for object-oriented programming.
        Class can contain <em>methods</em> which are defined upon class
        creation and can not be changed after.
        The reason why they can't be changed is because how inheritance is
        implemented internally, which in turn makes code much more manageable.
        <em>class</em> can inherit from another class, the name of the
        <em>class</em> from which we inherit is called a <em>superclass</em>.
        When inheriting all of the <em>superclass methods</em> are copied over
        to the <em>class</em> being created.
        <br/>
        When constructing a <em>class</em> programmer can define
        <em>metamethods</em> which are special functions that provide
        meta-programming functionality.
        <br/><br/>
        <!-- instance -->
        The type <em>instance</em> is similar to <em>table</em>; it can be
        indexed and indexed values are the values of the <em>instance</em>
        <em>fields</em>. Each <em>instance</em> is constructed from a
        <em>class</em>.
        The <em>class</em> methods of the <em>instance</em> can't be changed
        but can be shadowed by creating a non <b>nil</b> <em>field</em> with
        the same key.
        <br/><br/>
        <!-- thread -->
        The type <em>thread</em> represents independent threads of execution.
        CScript threads are not related to operating-system threads.
        <br/><br/>
        The library function <a href=#typeof><code>typeof</code></a> returns a
        string describing the type of a given value.
        </p>


        <h2>2.2 &ndash; <a name="2.2">Global Table</a></h2>
        <p>
        As we will discuss further in <a href="#3.2">&sect;3.2</a> and
        <a href="#3.3.3">&sect;3.3.3</a>, any reference to a free name
        (that is, a name not bound to any declaration) <code>var</code>
        is considered to be a global variable and it's value is set into
        the global table.
        Moreover, every chunk is compiled in the scope of global table.
        This table can be accessed via <a href="#4">API</a> or the global
        variable <a href="#__G"><code>__G</code></a> if the host program
        opened <a href="#6.1">basic library</a> (by calling
        <a href="#csL_openlibs"><code>csL_openlibs</code></a> or
        <a href="#csopen_basic"><code>csopen_basic</code></a>).
        </p>


        <h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>
        <p>
        Several operations in CScript can <em>raise</em> an error.
        An error interrupts the normal flow of the program,
        which can continue by <em>catching</em> the error.
        <br/><br/>
        CScript code can explicitly raise an error by calling the
        <a href="#error"><code>error</code></a> function.
        (This function never returns.)
        <br/><br/>
        To catch errors in CScript, you can do a <em>protected call</em>,
        using <a href="#pcall"><code>pcall</code></a>
        (or <a href="#xpcall"><code>xpcall</code></a>).
        The function <a href="#pcall"><code>pcall</code></a> calls a
        given function in <em>protected mode</em>.
        Any error while running the function stops its execution,
        and control returns immediately to <code>pcall</code>,
        which returns a status code.
        <br/><br/>
        Because CScript is an embedded extension language, CScript code
        starts running by a call from C&nbsp;code in the host program.
        (When you use CScript standalone, the <code>cscript</code>
        application is the host program.)
        Usually, this call is protected; so, when an otherwise unprotected
        error occurs during the compilation or execution of a CScript chunk,
        control returns to the host, which can take appropriate measures,
        such as printing an error message.
        <br/><br/>
        Whenever there is an error, an <em>error object</em> is propagated
        with information about the error.
        CScript itself only generates errors whose error object is a string,
        but programs can generate errors with any value as the error object.
        It is up to the CScript program or its host to handle such error
        objects.
        An error object is often called an <em>error message</em>,
        even though it does not have to be a string.
        <br/><br/>
        When you use <a href="#xpcall"><code>xpcall</code></a>
        (or <a href="#cs_pcall"><code>cs_pcall</code></a>, in C)
        you can give a <em>message handler</em> to be called in case of
        errors.
        This function is called with the original error object and returns
        a new error object.
        It is called before the error unwinds the stack, so that it can
        gather more information about the error, for instance by inspecting
        the stack and creating a stack traceback.
        This message handler is still protected by the protected call;
        so, an error inside the message handler will call the message handler
        again.
        If this loop goes on for too long, CScript breaks it and returns an
        appropriate message.
        The message handler is called only for regular runtime errors.
        It is not called for memory-allocation errors
        nor for errors while running finalizers or other message handlers.
        <br/><br/>
        CScript also offers a system of <em>warnings</em>
        (see <a href="#warn"><code>warn</code></a>).
        Unlike errors, warnings do not interfere in any way with program
        execution.
        They typically only generate a message to the user, although this
        behavior can be adapted from C
        (see <a href="#cs_setwarnf"><code>cs_setwarnf</code></a>).
        </p>


        <h2>2.4 &ndash; <a name="2.4">Metamethods</a></h2>
        <p>
        Metamethods are special kind of <b>methods</b> that alter the
        behavior of the original value under certain events.
        Class and full userdata are the only values in CScript that can
        implement <b>metamethods</b>.
        Both of these values contain a <b>virtual method table</b>, and
        each entry in this "table" contains a <b>function</b>.
        You can change several aspects of the behavior of a value by
        setting specific entries in the virtual method table.
        For example, when you try to add two instance objects, CScript
        checks for a function <code>__add</code> in the virtual method table.
        If it finds one, CScript calls this function to perform the addition.
        <br/><br/>
        The name of each <b>metamethod</b> is prefixed with two underscores.
        A metamethod can only be a CScript&nbsp;function or a C&nbsp;function.
        <br/><br/>
        You can query the virtual method table of a class, instance or
        full userdata using the
        <a href="#getmetamethod"><code>getmetamethod</code></a> function.
        <br/><br/>
        After the class is created/defined, you can't change its
        <b>virtual method table</b> anymore, this is also ensured in
        C&nbsp;API as class creation, method definitions and <em>vmt</em>
        (short for virtual method table) creation is one atomic operation.
        However the full userdata <em>vmt</em> can be mutated or changed
        at any time, but only from C&nbsp;code.
        The reason why classes can't mutate their <em>vmt</em> is because
        classes can inherit thus would introduce much more complexity.
        (Additionally the author himself dislikes the idea.)
        <br/><br/>
        A detailed list of operations controlled by <em>vmt</em> is given next.
        By convention, all metamethod names used by CScript are composed by
        two underscores followed by lowercase Latin letters.
        <ul>
            <li>
                <b><code>__add</code>: </b>
                the addition (<code>+</code>) operation.
                If any operand for an addition is not a number,
                CScript will try to call a metamethod.
                It first checks that the types of the operands match.
                Then if the operands are instances, it checks if they are
                the instances of the same class, and finally it checks for
                the presence of <code>__add</code> in that class.
                In case operands are full userdata, then it only checks for
                the presence of <code>__add</code>.
                If the metamethod is found, it will call it with the two
                operands as arguments (order of operands is left intact).
                It returns a single result, otherwise, if no metamethod is
                found, or the conditions mentioned above do not hold, CScript
                raises an error.
            </li>
            <li>
                <b><code>__sub</code>: </b>
                the subtraction (<code>-</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mul</code>: </b>
                the multiplication (<code>*</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__div</code>: </b>
                the division (<code>/</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mod</code>: </b>
                the modulo (<code>%</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__pow</code>: </b>
                the exponentiation (<code>**</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__unm</code>: </b>
                the negation (unary <code>-</code>) operation.
                Behavior similar to the addition operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__band</code>: </b>
                the bitwise AND (<code>&amp;</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod if any operand is neither
                an integer nor a float coercible to an integer
                (see <a href="#3.4.3">&sect;3.4.3</a>).
            </li>
            <li>
                <b><code>__bor</code>: </b>
                the bitwise OR (<code>|</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bxor</code>: </b>
                the bitwise exclusive OR (binary <code>^</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bnot</code>: </b>
                the bitwise NOT (unary <code>~</code>) operation.
                Behavior similar to the bitwise AND operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__shl</code>: </b>
                the bitwise left shift (<code>&lt;&lt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__shr</code>: </b>
                the bitwise right shift (<code>&gt;&gt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__concat</code>: </b>
                the concatenation (<code>..</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod if either operand is not
                a string.
            </li>
            <li>
                <b><code>__eq</code>: </b>
                the equal (<code>==</code>) operation.
                Behavior similar to the addition operation, except that
                CScript will try a metamethod only when the values being
                compared are either both instances or both full userdata
                and they are not primitively equal.
                The result of the call is always converted to a boolean.
            </li>
            <li>
                <b><code>__lt</code>: </b>
                the less than (<code>&lt;</code>) operation.
                Behavior similar to the addition operation,
                except that CScript will try a metamethod only when the
                values being compared are neither both numbers nor both
                strings.
                Moreover, the result of the call is always converted to
                a boolean.
            </li>
            <li>
                <b><code>__le</code>: </b>
                the less equal (<code>&lt;=</code>) operation.
                Behavior similar to the less than operation.
            </li>
            <li>
                <b><code>__getidx</code>: </b>
                The indexing access operation <code>v[key]</code>.
                This event happens when value <code>v</code> is an instance
                or full userdata that implements this metamethod.
                <br/><br/>
                This function is called with <code>v</code> and
                <code>key</code> as arguments, and returns a single result.
            </li>
            <li>
                <b><code>__setidx</code>: </b>
                The indexing assignment <code>v[key] = value</code>.
                Like the <code>__getidx</code> event, this event happens
                when value <code>v</code> is an instance or full userdata
                that implements this metamethod.
                <br/><br/>
                This function is called with <code>v</code>, <code>key</code>
                and <code>value</code> as arguments, and returns no results.
            </li>
            <li>
                <b><code>__call</code>: </b>
                The call operation <code>func(args)</code>.
                This event happens when CScript tries to call a value that
                is neither a function nor class.
                The metamethod is looked up in <code>func</code>.
                If present, the metamethod is called with <code>func</code>
                as its first argument, followed by the arguments of the
                original call (<code>args</code>).
                All results of the call are the results of the operation.
                This is the only metamethod that allows multiple results.
            </li>
            <li>
                <b><code>__init</code>: </b>
                This is special metamethod only used when calling class
                values. This event occurs when class value is called,
                such as <code>MyClass()</code> (where <code>MyClass</code>
                is a class value).
                If present, instance of the class being called is passed
                as the argument to this function.
                This function returns a single result.
                Usually this is used as the way to initialize the instance
                (as the name suggests).
                Keep in mind that <code>__init</code> can still be set for
                full userdata, but it will never trigger, so setting it is
                useless.
            </li>
        </ul>
        In addition to the previous list, the interpreter also implements
        the following events:
        <code>__gc</code> (see <a href="#2.5.3">&sect;2.5.3</a>) and
        <code>__close</code> (see <a href="#3.3.8">&sect;3.3.8</a>)
        </p>


        <h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>
        <p>
        CScript performs automatic memory management.
        This means that you do not have to worry about allocating memory
        for new objects or freeing it when the objects are no longer needed.
        CScript manages memory automatically by running a
        <em>garbage collector</em> to collect all <em>dead</em> objects.
        All memory used by CScript is subject to automatic management:
        strings, tables, arrays, userdata, functions, threads, classes,
        instances, internal structures, etc.
        <br/><br/>
        An object is considered <em>dead</em> as soon as the collector
        can be sure the object will not be accessed again in the normal
        execution of the program.
        ("Normal execution" here excludes finalizers, which can resurrect
        dead objects (see <a href="#2.5.3">&sect;2.5.3</a>).)
        Note that the time when the collector can be sure that an object
        is dead may not coincide with the programmer's expectations.
        The only guarantees are that CScript will not collect an object
        that may still be accessed in the normal execution of the program,
        and it will eventually collect an object that is inaccessible from
        CScript.
        (Here, <em>inaccessible from CScript</em> means that neither a
        variable nor another live object refer to the object.)
        Because CScript has no knowledge about C&nbsp;code, it never
        collects objects accessible through the registry
        (see <a href="#4.3">&sect;4.3</a>), which includes the global table
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        The garbage collector (GC) in CScript is incremental.
        <br/><br/>
        Default GC parameters are adequate for most uses.
        However, programs that waste a large proportion of their time
        allocating and freeing memory can benefit from other settings.
        Keep in mind that the GC behavior is non-portable both across
        platforms and across different CScript releases; therefore,
        optimal settings are also non-portable.
        <br/><br/>
        You can change the GC parameters by calling
        <a href="#cs_gc"><code>cs_gc</code></a> in&nbsp;C or
        <a href="#gc"><code>gc</code></a> in CScript.
        You can also use these functions to control the collector directly
        (e.g., to stop and restart it).
        </p>


        <h3>2.5.1 &ndash; <a name="2.5.1">Incremental Garbage Collection</a></h3>
        <p>
        In incremental mode, each GC cycle performs a mark-and-sweep
        collection in small steps interleaved with the program's execution.
        In this mode, the collector uses three numbers to control its
        garbage-collection cycles:
        the <em>garbage-collector pause</em>,
        the <em>garbage-collector step multiplier</em>,
        and the <em>garbage-collector step size</em>.
        <br/><br/>
        The garbage-collector pause controls how long the collector waits
        before starting a new cycle.
        The collector starts a new cycle when the use of memory hits
        <em>n%</em> of the use after the previous collection.
        Larger values make the collector less aggressive.
        Values equal to or less than 100 mean the collector will not wait
        to start a new cycle.
        A value of 200 means that the collector waits for the total memory
        in use to double before starting a new cycle.
        The default value is 200; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step multiplier controls the speed of the
        collector relative to memory allocation, that is, how many elements
        it marks or sweeps for each kilobyte of memory allocated.
        Larger values make the collector more aggressive but also increase
        the size of each incremental step.
        You should not use values less than 100, because they make the
        collector too slow and can result in the collector never finishing
        a cycle.
        The default value is 100; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step size controls the size of each incremental
        step, specifically how many bytes the interpreter allocates before
        performing a step.
        This parameter is logarithmic:
        A value of <em>n</em> means the interpreter will allocate
        <em>2<sup>n</sup></em> bytes between steps and perform equivalent
        work during the step.
        A large value (e.g., 60) makes the collector a stop-the-world
        (non-incremental) collector.
        The default value is 13, which means steps of approximately
        8&nbsp;Kbytes.


        <h3>2.5.2 &ndash; <a name="2.5.2">Garbage-Collection Metamethods</a></h3>
        <p>
        You can set garbage-collector metamethods for classes and, using the
        C&nbsp;API, for full userdata (see <a href="#2.4">&sect;2.4</a>).
        These metamethods, called <em>finalizers</em>, are called when
        the garbage collector detects that the corresponding instance or
        userdata is dead.
        Finalizers allow you to coordinate CScript's garbage collection
        with external resource management such as closing files, network
        or database connections, or freeing your own memory.
        <br/><br/>
        For an object (instance or userdata) to be finalized when collected,
        you must <em>mark</em> it for finalization.
        You mark an object for finalization when you set its <em>vmt</em>
        <code>__gc</code> metamethod.
        This marking, for instances is as soon as the class is called, before
        <code>__init</code> even runs (if present).
        As for the full userdata, it is after the <code>__gc</code> is set
        from C&nbsp;code
        (see <a href="#cs_set_usermm"><code>cs_set_usermm</code></a> and
        <a href="#cs_set_uservmt"><code>cs_set_uservmt</code></a>).
        <br/><br/>
        When a marked object becomes dead, it is not collected immediately
        by the garbage collector.
        Instead, CScript puts it in a list.
        After the collection, CScript goes through that list.
        For each object in the list, it checks the object's
        <code>__gc</code> metamethod:
        If it is present, CScript calls it with the object as its single
        argument.
        <br/><br/>
        At the end of each garbage-collection cycle, the finalizers are
        called in the reverse order that the objects were marked for
        finalization, among those collected in that cycle;
        that is, the first finalizer to be called is the one associated
        with the object marked last in the program.
        The execution of each finalizer may occur at any point during
        the execution of the regular code.
        <br/><br/>
        Because the object being collected must still be used by the finalizer,
        that object (and other objects accessible only through it) must be
        <em>resurrected</em> by CScript.
        Usually, this resurrection is transient, and the object memory is
        freed in the next garbage-collection cycle.
        However, if the finalizer stores the object in some global place
        (e.g., a global variable), then the resurrection is permanent.
        Moreover, if the finalizer marks a finalizing object for finalization
        again, its finalizer will be called again in the next cycle where
        the object is dead.
        In any case, the object memory is freed only in a GC cycle where
        the object is dead and not marked for finalization.
        <br/><br/>
        When you close a state
        (see <a href="#cs_close"><code>cs_close</code></a>), CScript calls
        the finalizers of all objects marked for finalization,
        following the reverse order that they were marked.
        If any finalizer marks objects for collection during that phase,
        these marks have no effect.
        <br/><br/>
        Finalizers cannot run the garbage collector.
        Because they can run in unpredictable times, it is good practice
        to restrict each finalizer to the minimum necessary to properly
        release its associated resource.
        <br/><br/>
        Any error while running a finalizer generates a warning;
        the error is not propagated.
        </p>




        <h1>3 &ndash; <a name="3">The Language</h1>
        <p>
        This section describes the lexis, the syntax, and the semantics
        of CScript.
        In other words, this section describes which tokens are valid,
        how they can be combined, and what their combinations mean.
        <br/><br/>
        Language constructs will be explained using the usual extended
        BNF notation, in which
        {<em>a</em>}&nbsp;means&nbsp;0 or more <em>a</em>'s, and
        [<em>a</em>]&nbsp;means an optional <em>a</em>.
        Non-terminals are shown like non-terminal, keywords are shown
        like <b>kword</b>, and other terminal symbols are shown like
        &lsquo;<b>=</b>&rsquo;.
        The complete syntax of CScript can be found in
        <a href="#9">&sect;9</a> at the end of this manual.
        </p>


        <h2>3.1 &ndash; <a name="3.1">Lexical Conventions</a></h2>
        <p>
        CScript is a free-form language.
        It ignores spaces and comments between lexical elements (tokens),
        except as delimiters between two tokens.
        In source code, CScript recognizes as spaces the standard ASCII
        whitespace characters space, form feed, newline, carriage return,
        horizontal tab, and vertical tab.
        The language tries its best to mimic C syntax, hence the "C" in
        "CScript".
        <br/><br/>
        <em>Names</em> (also called <em>identifiers</em>) in CScript can be
        any string of Latin letters, Arabic-Indic digits, and underscores,
        not beginning with a digit and not being a reserved word.
        Identifiers are used to name variables, tablea fields and instance
        fields.
        <br/><br/>
        The following <em>keywords</em> are reserved and cannot be used as
        names:

        <pre>
    and       or        break     continue  if        else
    false     true      for       foreach   in        while
    loop      fn        switch    case      default   class
    inherits  local     nil       super     return</pre>

        CScript is a case-sensitive language:
        <code>and</code> is a reserved word, but <code>And</code> and
        <code>AND</code> are two different, valid names.
        As a convention, programs should avoid creating names that start
        with two underscores followed by one or more uppercase letters
        (such as <a href="#VERSION"><code>__VERSION</code></a>).
        <br/><br/>
        The following strings denote other tokens:

        <pre>
    +     -     *     /     %     ^     !
    &amp;     ~     |     &lt;&lt;    &gt;&gt;    **
    ==    !=    &lt;=    &gt;=    &lt;     &gt;     =
    (     )     {     }     [     ]
    ;     ,     .     ..    ...</pre>

        A <em>short literal string</em> can be delimited by matching single
        or double quotes, and can contain the following C-like escape
        sequences:
        '<code>\a</code>' (bell),
        '<code>\b</code>' (backspace),
        '<code>\f</code>' (form feed),
        '<code>\n</code>' (newline),
        '<code>\r</code>' (carriage return),
        '<code>\t</code>' (horizontal tab),
        '<code>\v</code>' (vertical tab),
        '<code>\\</code>' (backslash),
        '<code>\"</code>' (quotation mark [double quote]),
        and '<code>\'</code>' (apostrophe [single quote]).
        A backslash followed by a line break results in a newline in the
        string.
        A short literal string cannot contain unescaped line breaks
        nor escapes not forming a valid escape sequence.
        <br/><br/>
        We can specify any byte in a short literal string, including
        embedded zeros, by its numeric value.
        This can be done with the escape sequence <code>\x<em>XX</em></code>,
        where <em>XX</em> is a sequence of exactly two hexadecimal digits,
        or with the escape sequence <code>\<em>ddd</em></code>,
        where <em>ddd</em> is a sequence of up to three decimal digits.
        (Note that if a decimal escape sequence is to be followed by a digit,
        it must be expressed using exactly three digits.)
        <br/><br/>
        The UTF-8 encoding of a Unicode character can be inserted in a
        literal string with the escape sequence <code>\u{<em>XXX</em>}</code>
        (with mandatory enclosing braces), where <em>XXX</em> is a sequence
        of one or more hexadecimal digits representing the character code
        point.
        This code point can be any value less than <em>2<sup>31</sup></em>.
        (CScript uses the original UTF-8 specification here, which is not
        restricted to valid Unicode code points.)
        Additionally you can specify UTF-8 encoding with
        <code>\u[<em>XXX</em>]</code>, which is identical to the previous
        example but this will additionally check if the sequence is a
        valid Unicode code point and throw syntax error otherwise.
        <br/><br/>
        As an example, in a system using ASCII
        (in which '<code>a</code>' is coded as&nbsp;97, newline is coded
        as&nbsp;10, and '<code>1</code>' is coded as&nbsp;49), the two
        literal strings below denote the same string:

        <pre>
     a = "alo\n123\""
     a = "\97lo\10\04923\""</pre>

        Any byte in a literal string not explicitly affected by the
        previous rules represents itself.
        However, CScript opens files for parsing in text mode, and the
        system's file functions may have problems with some control
        characters.
        So, it is safer to represent binary data as a quoted literal with
        explicit escape sequences for the non-text characters.
        <br/><br/>
        A <em>numeric constant</em> (or <em>numeral</em>) can be written
        with an optional fractional part and an optional decimal exponent,
        marked by a letter '<code>e</code>' or '<code>E</code>'.
        CScript also accepts hexadecimal constants, which start with
        <code>0x</code> or <code>0X</code>, and octal constants, which
        start with <code>0</code>.
        Additionally all <em>numeric constants</em> can have '<code>_</code>'
        in between digits, this acts as a separator, however this separator
        is not allowed in fractional part.
        Hexadecimal constants also accept an optional fractional part
        plus an optional binary exponent, marked by a letter
        '<code>p</code>' or '<code>P</code>' and written in decimal.
        (For instance, <code>0x1.fp10</code> denotes 1984,
        which is <em>0x1f / 16</em> multiplied by <em>2<sup>10</sup></em>.)
        Hexadecimal constants that have the fractional part, must also have
        the binary exponent.
        If you wish to declare a hexadecimal float constant, but do not
        need the binary exponent, you can just set the binary exponent to
        <code>p0</code> or <code>P0</code>
        (which is <em>2<sup>0</sup> == 1</em>).
        <br/><br/>
        A numeric constant with a radix point or an exponent denotes a float;
        otherwise, if its value fits in an integer or it is a hexadecimal or
        octal constant, it denotes an integer.
        Hexadecimal numerals with neither a radix point nor an exponent
        always denote an integer value.
        If the <em>numeric constant</em> overflows or underflows, CScript
        throws an error.
        <br/><br/>
        Examples of valid integer constants are

        <pre>
    3   345   0xff   0xBEBADA   015   000</pre>

        Examples of valid float constants are

        <pre>
    3.0      3.1416      .153      14.16e-2      0.31416E1      34e1
    0x.1Ep0  0xA23p-4    0X1.921FB54442D18P+1</pre>

        A <em>short comment</em> starts with a double forward slash
        (<code>//</code>) or a pound sign (<code>#</code>) and runs until
        the end of the line.
        A <em>long comment</em> starts with a forward slash and
        asterisk sign (<code>/*</code>) and is delimited by asterisk sign and
        forward slash (<code>*/</code>).
        These <em>comments</em> are valid anywhere outside of a string.


        <h2>3.2 &ndash; <a name="3.2">Variables</a></h2>
        <p>
        Variables are places that store values.
        There are three kinds of variables in CScript:
        global variables, local variables, table keys and instance fields.
        <br/><br/>
        A single name can denote a global variable or a local variable
        (or a function's formal parameter, which is a particular kind
        of local variable):

        <pre>
    var ::= Name</pre>

        Name denotes identifiers (see <a href="#3.1">&sect;3.1</a>).
        <br/><br/>
        Any variable name is assumed to be global unless explicitly declared
        as a local (see <a href="#3.3.7">&sect;3.3.7</a>).
        Local variables are <em>lexically scoped</em>:
        local variables can be freely accessed by functions
        defined inside their scope (see <a href="#3.5">&sect;3.5</a>).
        <br/><br/>
        Before the first assignment to a variable, its value is <b>nil</b>.
        <br/><br/>
        Square brackets are used to index a table, array or instance:

        <pre>
    var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;</pre>

        The meaning of accesses to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The syntax <code>var.Name</code> is just syntactic sugar for
        <code>var["Name"]</code>:

        <pre>
    var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name</pre>
        </p>


        <h2>3.3 &ndash; <a name="3.3">Statements</a></h2>
        <p>
        CScript supports almost identical set of statements as found in C.
        This set includes blocks, assignments, control structures,
        function calls and variable declarations.
        </p>


        <h3>3.3.1 &ndash; <a name="3.3.1">Blocks</a></h3>
        <p>
        A block is a list of statements with its own scope enclosed in between
        curly braces.
        These statements are executed sequentially:

        <pre>
    block ::= &lsquo;<b>{</b>&rsquo; {stm} &lsquo;<b>}</b>&rsquo;</pre>
        </p>


        <h3>3.3.2 &ndash; <a name="3.3.2">Chunks</a></h3>
        <p>
        The unit of compilation of CScript is called a <em>chunk</em>.
        Syntactically, a chunk is simply a block without curly braces:

        <pre>
    chunk ::= {stm}</pre>

        CScript handles a chunk as the body of an anonymous function
        with a variable number of arguments
        (see <a href="#3.4.11">&sect;3.4.11</a>).
        As such, chunks can define local variables, receive arguments,
        and return values.
        Moreover, such anonymous function is compiled as in the global scope
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        A chunk can be stored in a file or in a string inside the host program.
        To execute a chunk, CScript first <em>loads</em> it, precompiling the
        chunk's code into instructions for a virtual machine, and then CScript
        executes the compiled code with an interpreter for the virtual machine.
        </p>


        <h3>3.3.3 &ndash; <a name="3.3.3">Assignment</a></h3>
        <p>
        CScript allows multiple assignments.
        Therefore, the syntax for assignment defines a list of variables
        on the left side and a list of expressions on the right side.
        The elements in both lists are separated by commas and terminated
        by a semicolon:

        <pre>
    stm ::= varlist &lsquo;<b>=</b>&rsquo; explist &lsquo;<b>;</b>&rsquo;
    varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
    explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}</pre>

        Expressions are discussed in <a href="#3.4">&sect;3.4</a>.
        <br/><br/>
        Before the assignment,
        the list of values is <em>adjusted</em> to the length of
        the list of variables (see <a href="#3.4.12">&sect;3.4.12</a>).
        <br/><br/>
        If a variable is both assigned and read inside a multiple assignment,
        CScript ensures that all reads get the value of the variable
        before the assignment.
        Thus the code

        <pre>
    i = 3
    i, a[i] = i+1, 20</pre>

        sets <code>a[3]</code> to 20, without affecting <code>a[4]</code>
        because the <code>i</code> in <code>a[i]</code> is evaluated (to 3)
        before it is assigned&nbsp;4.
        Similarly, the line

        <pre>
     x, y = y, x</pre>

        exchanges the values of <code>x</code> and <code>y</code>,
        and

        <pre>
     x, y, z = y, z, x</pre>

        cyclically permutes the values of <code>x</code>, <code>y</code>
        and <code>z</code>.
        <br/><br/>
        Note that this guarantee covers only accesses syntactically inside
        the assignment statement.
        If a function or a metamethod called during the assignment
        changes the value of a variable, CScript gives no guarantees about
        the order of that access.
        <br/><br/>
        The meaning of assignments to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        </p>


        <h3>3.3.4 &ndash; <a name="3.3.4">Control Structures</a></h3>
        <p>
        The control structures
        <b>if</b>, <b>while</b>, <b>for</b> and <b>loop</b> have the usual
        meaning and familiar syntax:

        <pre>
    stm ::= <b>while</b> &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; stm
    stm ::= <b>for</b> &lsquo;<b>(</b>&rsquo; {localstm | exprstm} &lsquo;<b>;</b>&rsquo; {exp} &lsquo;<b>;</b>&rsquo; {exprstm} &lsquo;<b>)</b>&rsquo; stm
    stm ::= <b>loop</b> stm
    stm ::= <b>if</b> &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; stm {<b>else</b> stm}</pre>

        CScript also has a <b>foreach</b> statement
        (see <a href="#3.3.5">&sect;3.3.5</a>).
        <br/><br/>
        The condition expression of a control structure can return any value.
        Both <b>false</b> and <b>nil</b> test false.
        All values different from <b>nil</b> and <b>false</b> test true.
        In particular, the number 0 and the empty string also test true.
        <br/><br/>
        The <b>break</b> statement terminates the execution of a
        <b>while</b>, <b>repeat</b>, or <b>for</b> loop,
        skipping to the next statement after the loop:

        <pre>
    stm ::= <b>break</b> &lsquo;<b>;</b>&rsquo;</pre>

        A <b>break</b> ends the innermost enclosing loop.
        <br/><br/>
        The <b>continue</b> statement is used to skip the current iteration
        and proceed to the next iteration of the loop:

        <pre>
    stm ::= <b>continue</b> &lsquo;<b>;</b>&rsquo;</pre>

        When a <b>continue</b> statement is encountered, the remaining
        statements in the loop body are skipped, and control is transferred
        to the loop's next iteration.
        <br/><br/>
        The <b>return</b> statement is used to return values from a function
        or a chunk (which is handled as an anonymous function).
        Functions can return more than one value, so the syntax for the
        <b>return</b> statement is

        <pre>
    stm ::= <b>return</b> [explist] &lsquo;<b>;</b>&rsquo;</pre>

        The <b>return</b> statement can only be written as the last statement
        of a block or a chunk.
        If it is necessary to <b>return</b> in the middle of a block,
        then an explicit inner block can be used: <code>{ return; }</code>,
        because now <b>return</b> is the last statement in its (inner) block.
        </p>


        <h3>3.3.5 &ndash; <a name="3.3.5">Foreach Statement</a></h3>
        <p>
        The <b>foreach</b> statement is a generic loop.
        This statement works over functions, called <em>iterators</em>.
        On each iteration, the iterator function is called to produce a new
        value, stopping when this new value is <b>nil</b>.
        The generic <b>foreach</b> loop has the following syntax:

        <pre>
    stm ::= <b>foreach</b> namelist <b>in</b> explist stm
    namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}</pre>

        A <b>foreach</b> statement like

        <pre>
    foreach <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> <em>body</em></pre>

        works as follows.
        <br/><br/>
        The names <em>var_i</em> declare loop variables local to the loop body.
        The first of these variables is the <em>control variable</em>.
        <br/><br/>
        The loop starts by evaluating <em>explist</em> to produce four values:
        an <em>iterator function</em>, a <em>state</em>, an initial value for
        the control variable, and a <em>closing value</em>.
        <br/><br/>
        Then, at each iteration, CScript calls the iterator function with
        two arguments: the state and the control variable.
        The results from this call are then assigned to the loop variables,
        following the rules of multiple assignments
        (see <a href="#3.3.3">&sect;3.3.3</a>).
        If the control variable becomes <b>nil</b>, the loop terminates.
        Otherwise, the body is executed and the loop goes to the next
        iteration.
        <br/><br/>
        The closing value behaves like a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>), which can be used to release
        resources when the loop ends.
        Otherwise, it does not interfere with the loop.
        <br/><br/>
        You should not change the value of the control variable
        during the loop.
        </p>


        <h3>3.3.6 &ndash; <a name="3.3.6">Function Calls as Statements</a></h3>
        <p>
        To allow possible side-effects,
        function calls can be executed as statements:

        <pre>
    stm ::= functioncall</pre>

        In this case, all returned values are thrown away.
        Function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>.
        </p>


        <h3>3.3.7 &ndash; <a name="3.3.7">Local Declarations</a></h3>
        <p>
        Local variables can be declared anywhere inside a block.
        The declaration can include an initialization:

        <pre>
    stm ::= <b>local</b> attnamelist [&lsquo;<b>=</b>&rsquo; explist] &lsquo;<b>;</b>&rsquo;
    attnamelist ::=  Name attrib {&lsquo;<b>,</b>&rsquo; Name attrib}</pre>

        If present, an initial assignment has the same semantics
        of a multiple assignment (see <a href="#3.3.3">&sect;3.3.3</a>).
        Otherwise, all variables are initialized with <b>nil</b>.
        <br/><br/>
        Each variable name may be postfixed by an attribute
        (a name between angle brackets):

        <pre>
    attrib ::= [&lsquo;<b>&lt;</b>&rsquo; Name &lsquo;<b>&gt;</b>&rsquo;]</pre>

        There are two possible attributes:
        <code>final</code>, which declares immutable variable, that is,
        a variable that cannot be assigned to after its initialization;
        and <code>close</code>, which declares a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        A list of variables can contain at most one to-be-closed variable.
        <br/><br/>
        A chunk is also a block (see <a href="#3.3.2">&sect;3.3.2</a>),
        and so local variables can be declared in a chunk outside any
        explicit block.
        <br/><br/>
        The visibility rules for local variables are explained in
        <a href="#3.5">&sect;3.5</a>.
        </p>


        <h3>3.3.8 &ndash; <a name="3.3.8">To-be-closed Variables</a></h3>
        <p>
        A to-be-closed variable behaves like an immutable local variable,
        except that its value is <em>closed</em> whenever the variable
        goes out of scope, including normal block termination,
        exiting its block by <b>break</b>/<b>continue</b>/<b>return</b>,
        or exiting by an error.
        <br/><br/>
        Here, to <em>close</em> a value means to call its
        <code>__close</code> metamethod.
        When calling the metamethod, the value itself is passed as the
        first argument and the error object that caused the exit (if any)
        is passed as a second argument;
        if there was no error, the second argument is <b>nil</b>.
        <br/><br/>
        The value assigned to a to-be-closed variable must have a
        <code>__close</code> metamethod or be a false value.
        (<b>nil</b> and <b>false</b> are ignored as to-be-closed values.)
        <br/><br/>
        If several to-be-closed variables go out of scope at the same event,
        they are closed in the reverse order that they were declared.
        <br/><br/>
        If there is any error while running a closing method, that error is
        handled like an error in the regular code where the variable was
        defined.
        After an error, the other pending closing methods will still be called.
        </p>


        <h2>3.4 &ndash; <a name="3.4">Expressions</a></h2>
        <p>
        The basic expressions in CScript are the following:

        <pre>
    exp ::= prefixexp
    exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
    exp ::= Numeral
    exp ::= LiteralString
    exp ::= functiondef
    exp ::= tableconstructor
    exp ::= arrayconstructor
    exp ::= &lsquo;<b>...</b>&rsquo;
    exp ::= exp binop exp
    exp ::= unop exp
    prefixexp ::= var | super | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;</pre>

        Numerals and literal strings are explained in
        <a href="#3.1">&sect;3.1</a>;
        variables are explained in <a href="#3.2">&sect;3.2</a>;
        function definitions are explained in
        <a href="#3.4.11">&sect;3.4.11</a>;
        function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>;
        table and array constructors are explained in
        <a href="#3.4.9">&sect;3.4.9</a>.
        Vararg expressions, denoted by three dots ('<code>...</code>'),
        can only be used when directly inside a variadic function;
        they are explained in <a href="#3.4.11">&sect;3.4.11</a>.
        Expressions with <code>super</code> keyword can only be used during
        the class method declaration; this is explained in more detail in
        <a href="#3.4.12">&sect;3.4.12</a>.
        <br/><br/>
        Binary operators comprise arithmetic operators
        (see <a href="#3.4.1">&sect;3.4.1</a>), bitwise operators
        (see <a href="#3.4.2">&sect;3.4.2</a>), relational operators
        (see <a href="#3.4.4">&sect;3.4.4</a>), logical operators
        (see <a href="#3.4.5">&sect;3.4.5</a>), and the concatenation operator
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        Unary operators comprise the unary minus
        (see <a href="#3.4.1">&sect;3.4.1</a>), the unary bitwise NOT
        (see <a href="#3.4.2">&sect;3.4.2</a>) and the unary logical not
        (see <a href="#3.4.5">&sect;3.4.5</a>).
        </p>


        <h3>3.4.1 &ndash; <a name="3.4.1">Arithmetic Operators</a></h3>
        <p>
        CScript supports the following arithmetic operators:
        <ul>
            <li><b><code>+</code>: </b>addition</li>
            <li><b><code>-</code>: </b>subtraction</li>
            <li><b><code>*</code>: </b>multiplication</li>
            <li><b><code>/</code>: </b>float division</li>
            <li><b><code>%</code>: </b>modulo</li>
            <li><b><code>**</code>: </b>exponentiation</li>
            <li><b><code>-</code>: </b>unary minus</li>
        </ul>
        With the exception of exponentiation and float division,
        the arithmetic operators work as follows:
        If both operands are integers, the operation is performed over
        integers and the result is an integer.
        Otherwise, if both operands are numbers, then they are converted to
        floats, the operation is performed following the machine's rules
        for floating-point arithmetic (usually the IEEE 754 standard),
        and the result is a float.
        <br/><br/>
        Exponentiation and float division (<code>/</code>) always convert
        their operands to floats and the result is always a float.
        Exponentiation uses the ISO&nbsp;C function <code>pow</code>,
        so that it works for non-integer exponents too.
        <br/><br/>
        Modulo is defined as the remainder of a division that rounds
        the quotient towards minus infinity (floor division).
        <br/><br/>
        In case of overflows in integer arithmetic, all operations
        <em>wrap around</em>.
        </p>


        <h3>3.4.2 &ndash; <a name="3.4.2">Bitwise Operators</a></h3>
        <p>
        CScript supports the following bitwise operators:
        <ul>
            <li><b><code>&amp;</code>: </b>bitwise AND</li>
            <li><b><code>|</code>: </b>bitwise OR</li>
            <li><b><code>^</code>: </b>bitwise exclusive OR (xor)</li>
            <li><b><code>&gt;&gt;</code>: </b>right shift</li>
            <li><b><code>&lt;&lt;</code>: </b>left shift</li>
            <li><b><code>~</code>: </b>unary bitwise NOT</li>
        </ul>
        All bitwise operations convert its operands to integers
        (see <a href="#3.4.3">&sect;3.4.3</a>), operate on all bits of
        those integers, and result in an integer.
        <br/><br/>
        Both right and left shifts fill the vacant bits with zeros.
        Negative displacements shift to the other direction;
        displacements with absolute values equal to or higher than
        the number of bits in an integer result in zero
        (as all bits are shifted out).
        </p>


        <h3>3.4.3 &ndash; <a name="3.4.3">Coercions and Conversions</a></h3>
        <p>
        CScript provides some automatic conversions between some
        types and representations at run time.
        Bitwise operators always convert float operands to integers.
        Exponentiation and float division always convert integer operands
        to floats.
        All other arithmetic operations applied to mixed numbers
        (integers and floats) convert the integer operand to a float.
        The C API also converts both integers to floats and
        floats to integers, as needed.
        <br/><br/>
        In a conversion from integer to float, if the integer value has an
        exact representation as a float, that is the result.
        Otherwise, the conversion gets the nearest higher or the nearest
        lower representable value.
        This kind of conversion never fails.
        <br/><br/>
        The conversion from float to integer checks whether the float has
        an exact representation as an integer
        (that is, the float has an integral value and it is in the range
        of integer representation).
        If it does, that representation is the result.
        Otherwise, the conversion fails.
        </p>


        <h3>3.4.4 &ndash; <a name="3.4.4">Relational Operators</a></h3>
        <p>
        CScript supports the following relational operators:
        <ul>
            <li><b><code>==</code>: </b>equality</li>
            <li><b><code>!=</code>: </b>inequality</li>
            <li><b><code>&lt;</code>: </b>less than</li>
            <li><b><code>&gt;</code>: </b>greater than</li>
            <li><b><code>&lt;=</code>: </b>less or equal</li>
            <li><b><code>&gt;=</code>: </b>greater or equal</li>
        </ul>
        These operators always result in <b>false</b> or <b>true</b>.
        <br/><br/>
        Equality (<code>==</code>) first compares the type of its operands.
        If the types are different, then the result is <b>false</b>.
        Otherwise, the values of the operands are compared.
        Strings are equal if they have the same byte content.
        Numbers are equal if they denote the same mathematical value.
        <br/><br/>
        Tables, arrays, classes, instances, userdata, and threads are
        compared by reference:
        two objects are considered equal only if they are the same object.
        Every time you create a new object
        (a table, array, a class, a instance, a userdata or a thread),
        this new object is different from any previously existing object.
        A function is always equal to itself.
        Functions with any detectable difference
        (different behavior, different definition) are always different.
        Functions created at different times but with no detectable
        differences may be classified as equal or not
        (depending on internal caching details).
        <br/><br/>
        You can change the way that CScript compares instances and userdata
        by using the <code>__eq</code> metamethod
        (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The operator <code>!=</code> is exactly the negation of equality
        (<code>==</code>).
        <br/><br/>
        The order operators work as follows.
        If both arguments are numbers,
        then they are compared according to their mathematical values,
        regardless of their subtypes.
        Otherwise, if both arguments are strings,
        then their values are compared according to the current locale.
        Otherwise, CScript tries to call the <code>__lt</code> or the
        <code>__le</code> metamethod (see <a href="#2.4">&sect;2.4</a>).
        A comparison <code>a &gt; b</code> is translated to
        <code>b &lt; a</code> and <code>a &gt;= b</code> is translated to
        <code>b &lt;= a</code>.
        <br/><br/>
        Following the IEEE 754 standard, the special value NaN is considered
        neither less than, nor equal to, nor greater than any value,
        including itself.
        </p>


        <h3>3.4.5 &ndash; <a name="3.4.5">Logical Operators</a></h3>
        <p>
        The logical operators in CScript are <b>and</b>, <b>or</b> and
        <b>!</b>.
        Like the control structures (see <a href="#3.3.4">&sect;3.3.4</a>),
        all logical operators consider both <b>false</b> and <b>nil</b> as
        false and anything else as true.
        <br/><br/>
        The negation operator <b>!</b> always returns <b>false</b> or
        <b>true</b>.
        The conjunction operator <b>and</b> returns its first argument
        if this value is <b>false</b> or <b>nil</b>;
        otherwise, <b>and</b> returns its second argument.
        The disjunction operator <b>or</b> returns its first argument
        if this value is different from <b>nil</b> and <b>false</b>;
        otherwise, <b>or</b> returns its second argument.
        Both <b>and</b> and <b>or</b> use short-circuit evaluation;
        that is, the second operand is evaluated only if necessary.
        Here are some examples:

        <pre>
    10 or 20            --&gt; 10
    10 or error()       --&gt; 10
    nil or "a"          --&gt; "a"
    nil and 10          --&gt; nil
    false and error()   --&gt; false
    false and nil       --&gt; false
    false or nil        --&gt; nil
    10 and 20           --&gt; 20</pre>
        </p>


        <h3>3.4.6 &ndash; <a name="3.4.6">Concatenation</a></h3>
        <p>
        The string concatenation operator in CScript is
        denoted by two dots ('<code>..</code>').
        If any of the operands are not strings then the <code>__concat</code>
        metamethod is called (see <a href="#2.4">&sect;2.4</a>).
        </p>


        <h3>3.4.7 &ndash; <a name="3.4.7">Precedence</a></h3>
        <p>
        Operator precedence in CScript follows the table below,
        from lower to higher priority (it mimics operator precedence in C):

        <pre>
    or
    and
    |
    ^
    &amp;
    ==   !=
    &lt;    &lt;=   &gt;    &gt;=
    &lt;&lt;   &gt;&gt;
    ..
    +    -
    *    /    %
    unary operators (-    ~    !)
    **</pre>

        As usual, you can use parentheses to change the precedences of an
        expression.
        The concatenation ('<code>..</code>') and exponentiation
        ('<code>**</code>') operators are right associative.
        All other binary operators are left associative.
        </p>




        <h1>4 &ndash; <a name="4">The Application Programming Interface</h1>
        <p>
        This section describes the C&nbsp;API for CScript, that is,
        the set of C&nbsp;functions available to the host program to
        communicate with CScript.
        All API functions and related types and constants are declared in
        the header file <a name="cscript.h"><code>cscript.h</code></a>.
        </br></br>
        Even when we use the term "function", any facility in the API may be
        provided as a macro instead.
        Except where stated otherwise, all such macros use each of their
        arguments exactly once (except for the first argument, which is always
        a CScript state), and so do not generate any hidden side-effects.
        </br></br>
        As in most C&nbsp;libraries, the CScript API functions do not check
        their arguments for validity or consistency.
        However, you can change this behavior by compiling CScript with the
        macro <a name="CS_USE_APICHECK"><code>CS_USE_APICHECK</code></a> defined.
        </br></br>
        The CScript library is fully reentrant: it has no global variables.
        It keeps all information it needs in a dynamic structure, called
        the <em>CScript state</em>.
        </br></br>
        Each CScript state has one or more threads, which correspond to
        independent, cooperative lines of execution.
        The type <a href="#cs_State"><code>cs_State</code></a> (despite its
        name) refers to a thread.
        (Indirectly, through the thread, it also refers to the CScript state
        associated to the thread.)
        </br></br>
        A pointer to a thread must be passed as the first argument to every
        function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates
        a CScript state from scratch and returns a pointer to the
        <em>main thread</em> in the new state.
        </p>


        <h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>
        <p>
        CScript uses a <em>virtual stack</em> to pass values to and from C.
        Each element in this stack represents a CScript value (<b>nil</b>,
        number, string, etc.).
        Functions in the API can access this stack through the CScript state
        parameter that they receive.
        <br/><br/>
        Whenever CScript calls C, the called function gets a new stack,
        which is independent of previous stacks and of stacks of
        C&nbsp;functions that are still active.
        This stack initially contains any arguments to the C&nbsp;function
        and it is where the C&nbsp;function can store temporary CScript
        values and must push its results to be returned to the caller
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        For convenience, most query operations in the API do not follow a
        strict stack discipline.
        Instead, they can refer to any element in the stack by using an
        <em>index</em>:
        A positive index represents an absolute stack position, starting
        at&nbsp;0 as the bottom of the stack;
        a negative index represents an offset relative to the top of the stack.
        More specifically, if the stack has <em>n</em> elements, then
        index&nbsp;0 represents the first element
        (that is, the element that was pushed onto the stack first)
        and index&nbsp;<em>n-1</em> represents the last element;
        index&nbsp;-1 also represents the last element
        (that is, the element at the&nbsp;top)
        and index <em>-n</em> represents the first element.
        </p>


        <h3>4.1.1 &ndash; <a name="4.1.1">Stack Size</a></h3>
        <p>
        When you interact with the CScript API, you are responsible for
        ensuring consistency.
        In particular,
        <em>you are responsible for controlling stack overflow</em>.
        When you call any API function, you must ensure the stack has enough
        room to accommodate the results.
        <br/><br/>
        There is one exception to the above rule:
        When you call a CScript function without a fixed number of results
        (see <a href="#cs_call"><code>cs_call</code></a>),
        CScript ensures that the stack has enough space for all results.
        However, it does not ensure any extra space.
        So, before pushing anything on the stack after such a call
        you should use <a href="#cs_checkstack"><code>cs_checkstack</code></a>.
        <br/><br/>
        Whenever CScript calls C, it ensures that the stack has space for at
        least <a name="CS_MINSTACK"><code>CS_MINSTACK</code></a> extra elements;
        that is, you can safely push up to <code>CS_MINSTACK</code> values into it.
        <code>CS_MINSTACK</code> is defined as 20, so that usually you do
        not have to worry about stack space unless your code has loops pushing
        elements onto the stack.
        Whenever necessary, you can use the function
        <a href="#cs_checkstack"><code>cs_checkstack</code></a> to ensure
        that the stack has enough space for pushing new elements.
        </p>


        <h3>4.1.2 &ndash; <a name="4.1.2">Valid and Acceptable Indices</a></h3>
        <p>
        Any function in the API that receives stack indices works only with
        <em>valid indices</em> or <em>acceptable indices</em>.
        <br/><br/>
        A <em>valid index</em> is an index that refers to a position that
        stores a modifiable CScript value.
        It comprises stack indices between&nbsp;0 and the stack top
        (<code>0 &le; abs(index) &lt; top</code>) plus <em>pseudo-indices</em>,
        which represent some positions that are accessible to C&nbsp;code
        but that are not in the stack.
        Pseudo-indices are used to access the registry (see <a href="#4.3">&sect;4.3</a>)
        and the upvalues of a C&nbsp;function (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Functions that do not need a specific mutable position, but only a
        value (e.g., query functions), can be called with acceptable indices.
        An <em>acceptable index</em> can be any valid index, but it also can
        be any positive index after the stack top within the space allocated
        for the stack, that is, indices up to the stack size (not inclusive).
        Indices to upvalues (see <a href="#4.2">&sect;4.2</a>) greater than
        the real number of upvalues in the current C&nbsp;function are also
        acceptable (but invalid).
        Except when noted otherwise, functions in the API work with acceptable
        indices.
        <br/><br/>
        Acceptable indices serve to avoid extra tests against the stack top
        when querying the stack.
        For instance, a C&nbsp;function can query its third argument without
        the need to check whether there is a third argument, that is, without
        the need to check whether 2 is a valid index.
        <br/><br/>
        For functions that can be called with acceptable indices, any
        non-valid index is treated as if it contains a value of a virtual
        type <a name="CS_TNONE"><code>CS_TNONE</code></a>, which behaves
        like a nil value.
        </p>


        <h3>4.1.3 &ndash; <a name="4.1.3">Pointers to strings</a></h3>
        <p>
        Several functions in the API return pointers (<code>const char*</code>)
        to CScript strings in the stack.
        (See <a href="#cs_pushfstring"><code>cs_push_fstring</code></a>,
        <a href="#cs_push_lstring"><code>cs_push_lstring</code></a>,
        <a href="#cs_push_string"><code>cs_push_string</code></a>,
        and <a href="#cs_to_lstring"><code>cs_to_lstring</code></a>.
        See also <a href="#csL_check_lstring"><code>csL_check_lstring</code></a>,
        <a href="#csL_check_string"><code>csL_check_string</code></a>,
        and <a href="#csL_to_lstring"><code>csL_to_lstring</code></a> in the
        auxiliary library.)
        <br/><br/>
        In general, CScript's garbage collection can free or move internal
        memory and then invalidate pointers to internal strings.
        To allow a safe use of these pointers, the API guarantees that any
        pointer to a string in a stack index is valid while the string value
        at that index is not removed from the stack.
        (It can be moved to another index, though.)
        When the index is a pseudo-index (referring to an upvalue), the
        pointer is valid while the corresponding call is active and the
        corresponding upvalue is not modified.
        <br/><br/>
        Some functions in the debug interface also return pointers to strings,
        namely <a href="#cs_getlocal"><code>cs_getlocal</code></a>,
        <a href="#cs_getupvalue"><code>cs_getupvalue</code></a>,
        <a href="#cs_setlocal"><code>cs_setlocal</code></a>,
        and <a href="#cs_setupvalue"><code>cs_setupvalue</code></a>.
        For these functions, the pointer is guaranteed to be valid while the
        caller function is active and the given closure (if one was given)
        is in the stack.
        <br/><br/>
        Except for these guarantees, the garbage collector is free to
        invalidate any pointer to internal strings.
        </p>


        <h2>4.2 &ndash; <a name="4.2">C Closures</a></h2>
        <p>
        When a C&nbsp;function is created, it is possible to associate
        some values with it, thus creating a <em>C&nbsp;closure</em>
        (see <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a>);
        these values are called <em>upvalues</em> and are accessible to the
        function whenever it is called.
        <br/><br/>
        Whenever a C&nbsp;function is called, its upvalues are located at
        specific pseudo-indices.
        These pseudo-indices are produced by the macro
        <a href="#cs_upvalueindex"><code>cs_upvalueindex</code></a>.
        The first upvalue associated with a function is at index
        <code>cs_upvalueindex(0)</code>, and so on.
        Any access to <code>cs_upvalueindex(<em>n</em>)</code>,
        where <em>n</em> is greater than the number of upvalues of the
        current function, produces an acceptable but invalid index.
        <br/><br/>
        A C&nbsp;closure can also change the values of its corresponding
        upvalues.
        </p>


        <h2>4.3 &ndash; <a name="4.3">Registry</a></h2>
        <p>
        CScript provides a <em>registry</em>, a predefined array that can be
        used by any C&nbsp;code to store whatever CScript values it needs to
        store.
        The registry array is always accessible at pseudo-index
        <a name="CS_REGISTRYINDEX"><code>CS_REGISTRYINDEX</code></a>.
        Any C&nbsp;library can store data into this array, but it must take
        care to choose indices that are different from those used by other
        libraries, to avoid collisions.
        Typically, you would use
        <a href="#cs_getfreereg"><code>cs_getfreereg</code></a> in order to
        obtain free registry index.
        As with variable names, string keys starting with an two consecutive
        underscore followed by uppercase letters are reserved for CScript.
        <br/><br/>
        When you create a new CScript state, its registry comes with some
        predefined values.
        These predefined values are indexed with indices defined as constants
        in <code>cscript.h</code>.
        The following constants are defined:
        <ul>
            <li>
                <b><a name="CS_RINDEX_MAINTHREAD"><code>CS_RINDEX_MAINTHREAD</code></a>:</b>
                At this index the registry has the main thread of the state.
                (The main thread is the one created together with the state.)
            </li>
            <li>
                <b><a name="CS_RINDEX_GLOBALS"><code>CS_RINDEX_GLOBALS</code></a>:</b>
                At this index the registry has the global table.
            </li>
        </ul>
        </p>


        <h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>
        <p>
        Internally, CScript uses the C <code>longjmp</code> facility to handle
        errors.
        When CScript faces any error, such as a memory allocation error or a
        type error, it <em>raises</em> an error; that is, it does a long jump.
        A <em>protected environment</em> uses <code>setjmp</code>
        to set a recovery point; any error jumps to the most recent active
        recovery point.
        <br/><br/>
        Inside a C&nbsp;function you can raise an error explicitly
        by calling <a href="#cs_error"><code>cs_error</code></a>.
        <br/><br/>
        Most functions in the API can raise an error, for instance due to
        a memory allocation error.
        The documentation for each function indicates whether it can raise
        errors.
        <br/><br/>
        If an error happens outside any protected environment, CScript calls
        a <em>panic function</em>
        (see <a href="#cs_atpanic"><code>cs_atpanic</code></a>)
        and then calls <code>abort</code>, thus exiting the host application.
        Your panic function can avoid this exit by never returning
        (e.g., doing a long jump to your own recovery point outside CScript).
        <br/><br/>
        The panic function, as its name implies, is a mechanism of last resort.
        Programs should avoid it.
        As a general rule, when a C&nbsp;function is called by CScript with a
        CScript state, it can do whatever it wants on that CScript state,
        as it should be already protected.
        However, when C code operates on other CScript states
        (e.g., a CScript-state argument to the function, a CScript state
        stored in the registry, or the result of
        <a href="#cs_newthread"><code>cs_newthread</code></a>),
        it should use them only in API calls that cannot raise errors.
        <br/><br/>
        The panic function runs as if it were a message handler
        (see <a href="#2.3">&sect;2.3</a>); in particular, the error object
        is on the top of the stack.
        However, there is no guarantee about stack space.
        To push anything on the stack, the panic function must first check
        the available space (see <a href="#4.1.1">&sect;4.1.1</a>).
        </p>


        <h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>
        <p>
        Several functions that report errors in the API use the following
        status codes to indicate different kinds of errors or other conditions:
        <ul>
            <li><b><a name="CS_OK"><code>CS_OK</code></a> (0):</b>
                no errors.
            </li>
            <li><b><a name="CS_ERRRUN"><code>CS_ERRRUNTIME</code></a>:</b>
                a runtime error.
            </li>
            <li><b><a name="CS_ERRMEM"><code>CS_ERRMEM</code></a>: </b>
                memory allocation error.
                For such errors, CScript does not call the message handler.
            </li>
            <li><b><a name="CS_ERRERR"><code>CS_ERRERROR</code></a>: </b>
                error while running the message handler.
            </li>
            <li><b><a name="CS_ERRSYNTAX"><code>CS_ERRSYNTAX</code></a>:</b>
                syntax error during precompilation.</li>
            <li><b><a name="CS_ERRFILE"><code>CS_ERRFILE</code></a>:</b>
                a file-related error;
                e.g., it cannot open or read the file.</li>
        </ul><p>
        These constants are defined in the header file <code>cscript.h</code>.
        </p>


        <h2>4.5 &ndash; <a name="4.5">Functions and Types</a></h2>
        <p>
        Here we list all functions and types from the C&nbsp;API.
        Each function has an indicator like this:
        <span class="apii">[-o, +p, <em>x</em>]</span>
        <br/><br/>
        The first field, <code>o</code>, is how many elements the function
        pops from the stack.
        The second field, <code>p</code>, is how many elements the function
        pushes onto the stack.
        (Any function always pushes its results after popping its arguments.)
        A field in the form <code>x|y</code> means the function can push
        (or pop) <code>x</code> or <code>y</code> elements, depending on
        the situation; an interrogation mark '<code>?</code>' means that
        we cannot know how many elements the function pops/pushes by looking
        only at its arguments.
        (For instance, they may depend on what is in the stack.)
        The third field, <code>x</code>, tells whether the function may raise errors:
        '<code>-</code>' means the function never raises any error;
        '<code>m</code>' means the function may raise only out-of-memory errors;
        '<code>v</code>' means the function may raise the errors explained in the text;
        '<code>e</code>' means the function can run arbitrary CScript code,
        either directly or through metamethods, and therefore may raise any
        errors.
        </p>

        <!-- cs_State -->
        <hr><h3><a name="cs_State"><code>cs_State</code></a></h3>
        <pre>typedef struct cs_State cs_State;</pre>
        <p>
        An opaque structure that points to a thread and indirectly
        (through the thread) to the whole state of a CScript interpreter.
        The CScript library is fully reentrant: it has no global variables.
        All information about a state is accessible through this structure.
        <br/><br/>
        A pointer to this structure must be passed as the first argument to
        every function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates a
        CScript state from scratch.
        </p>

        <!-- cs_Integer -->
        <hr><h3><a name="cs_Integer"><code>cs_Integer</code></a></h3>
        <pre>typedef ... cs_Integer;</pre>
        <p>
        The type of integers in CScript.
        <br/><br/>
        By default this type is <code>long long</code>,
        (usually a 64-bit two-complement integer),
        (See <code>CS_INT_TYPE</code> in <code>csconf.h</code>.)
        <br/><br/>
        CScript also defines the constants
        <a name="CS_INTEGER_MIN"><code>CS_INTEGER_MIN</code></a> and
        <a name="CS_INTEGER_MAX"><code>CS_INTEGER_MAX</code></a>,
        with the minimum and the maximum values that fit in this type.
        </p>

        <!-- cs_Unsigned -->
        <hr><h3><a name="cs_Unsigned"><code>cs_Unsigned</code></a></h3>
        <pre>typedef ... cs_Unsigned;</pre>
        <p>
        The unsigned version of <a href="#cs_Integer"><code>cs_Integer</code></a>.
        </p>

        <!-- cs_Number -->
        <hr><h3><a name="cs_Number"><code>cs_Number</code></a></h3>
        <pre>typedef ... cs_Number;</pre>
        <p>
        The type of floats in CScript.
        <br/><br/>
        By default this type is double, but that can be changed to a single
        float or a long double.
        (See <code>CS_FLOAT_TYPE</code> in <code>csconf.h</code>.)
        </p>

        <!-- cs_CFunction -->
        <hr><h3><a name="cs_CFunction"><code>cs_CFunction</code></a></h3>
        <pre>typedef int (*cs_CFunction) (cs_State *C);</pre>
        <p>
        Type for C&nbsp;functions.
        <br/><br/>
        In order to communicate properly with CScript, a C&nbsp;function
        must use the following protocol, which defines the way parameters and
        results are passed: a C&nbsp;function receives its arguments from
        CScript in its stack in direct order (the first argument is pushed first).
        So, when the function starts, <code>cs_nvalues(C)</code> returns the
        number of arguments received by the function.
        The first argument (if any) is at index 0 and its last argument is at
        index <code>cs_gettop(C)</code>.
        To return values to CScript, a C&nbsp;function just pushes them onto
        the stack, in direct order (the first result is pushed first), and
        returns in C the number of results.
        Any other value in the stack below the results will be properly
        discarded by CScript.
        Like a CScript function, a C&nbsp;function called by CScript can also
        return many results.
        <br/><br/>
        As an example, the following function receives a variable number
        of numeric arguments and returns their average and their sum:
        <pre>
    static int foo (cs_State *C) {
        int n = cs_gettop(C);   /* index of last argument (or cs_nvalues(C)-1) */
        cs_Number sum = 0.0;
        int i;
        for (i = 0; i &lt;= n; i++) {
            if (!cs_is_number(C, i)) {
                cs_push_literal(C, "incorrect argument");
                cs_error(C);
            }
            sum += cs_to_number(C, i);
        }
        cs_push_number(C, sum/n);       /* first result */
        cs_push_number(C, sum);         /* second result */
        return 2;                   /* number of results */
    }</pre>
        </p>

        <!-- cs_Alloc -->
        <hr><h3><a name="cs_Alloc"><code>cs_Alloc</code></a></h3>
        <pre>typedef void *(*cs_Alloc) (void *ptr,
                           size_t osz,
                           size_t nsz,
                           void *ud);</pre>
        <p>
        The type of the memory-allocation function used by CScript states.
        The allocator function must provide a functionality similar to
        <code>realloc</code>, but not exactly the same.
        Its arguments are <code>ud</code>, last argument that is an opaque
        pointer passed to <a href="#cs_newstate"><code>cs_newstate</code></a>;
        <code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
        <code>osz</code>, the original size of the block or some code about
        what is being allocated (such as a <a href="#cs_type">type</a> tag);
        and <code>nsz</code>, the new size of the block.
        <br/><br/>
        When <code>ptr</code> is not <code>NULL</code>, <code>osz</code> is
        the size of the block pointed by <code>ptr</code>, that is, the size
        given when it was allocated or reallocated.
        <br/><br/>
        When <code>ptr</code> is <code>NULL</code>, <code>osz</code> encodes
        the kind of object that CScript is allocating.
        <code>osz</code> is any of
        <a href="#CS_TUSERDATA"><code>CS_TUSERDATA</code></a>,
        <a href="#CS_TSTRING"><code>CS_TSTRING</code></a>,
        <a href="#CS_TARRAY"><code>CS_TARRAY</code></a>,
        <a href="#CS_TTABLE"><code>CS_TTABLE</code></a>,
        <a href="#CS_TFUNCTION"><code>CS_TFUNCTION</code></a>,
        <a href="#CS_TCLASS"><code>CS_TCLASS</code></a>,
        <a href="#CS_TINSTANCE"><code>CS_TINSTANCE</code></a>, or
        <a href="#CS_TTHREAD"><code>CS_TTHREAD</code></a> when
        (and only when) CScript is creating a new object of that type.
        When <code>osz</code> is some other value, CScript is allocating
        memory for something else.
        <br/><br/>
        CScript assumes the following behavior from the allocator function:
        <br/><br/>
        When <code>nsz</code> is zero, the allocator must behave like
        <code>free</code> and then return <code>NULL</code>.
        <br/><br/>
        When <code>nsz</code> is not zero, the allocator must behave like
        <code>realloc</code>.
        In particular, the allocator returns <code>NULL</code> if and only if
        it cannot fulfill the request.
        <br/><br/>
        Here is a simple implementation for the allocator function.
        It is used in the auxiliary library by
        <a href="#csL_newstate"><code>csL_newstate</code></a>.
        <pre>
    static void *allocator (void *ptr, size_t osz, size_t nsz, void *ud) {
        (void)ud;  (void)osz;  /* not used */
        if (nsz == 0) {
            free(ptr);
            return NULL;
        } else
            return realloc(ptr, nsz);
    }</pre>
        Note that ISO&nbsp;C ensures that <code>free(NULL)</code> has no
        effect and that <code>realloc(NULL,size)</code> is equivalent to
        <code>malloc(size)</code>.
        </p>

        <!-- cs_Reader -->
        <hr><h3><a name="cs_Reader"><code>cs_Reader</code></a></h3>
        <pre>typedef const char *(*cs_Reader) (cs_State *C,
                                  void *data,
                                  size_t *size);</pre>
        <p>
        The reader function used by <a href="#cs_load"><code>cs_load</code></a>.
        Every time <a href="#cs_load"><code>cs_load</code></a> needs another
        piece of the chunk, it calls the reader, passing along its
        <code>data</code> parameter.
        The reader must return a pointer to a block of memory with a new piece
        of the chunk and set <code>size</code> to the block size.
        The block must exist until the reader function is called again.
        To signal the end of the chunk, the reader must return
        <code>NULL</code> or set <code>size</code> to zero.
        The reader function may return pieces of any size greater than zero.
        </p>

        <!-- cs_WarnFunction -->
        <hr><h3><a name="cs_WarnFunction"><code>cs_WarnFunction</code></a></h3>
        <pre>typedef void (*cs_WarnFunction) (void *ud, const char *msg, int tocont);</pre>
        <p>
        The type of warning functions, called by CScript to emit warnings.
        The first parameter is an opaque pointer set by
        <a href="#cs_setwarnf"><code>cs_setwarnf</code></a>.
        The second parameter is the warning message.
        The third parameter is a boolean that indicates whether the message is
        to be continued by the message in the next call.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about
        warnings.
        </p>

        <!-- cs_VMT -->
        <hr><h3><a name="cs_VMT"><code>cs_VMT</code></a></h3>
        <pre>typedef struct cs_VMT cs_VMT;</pre>
        <p>
        Type for Virtual Method Table used as an argument when creating a
        class with <a href="#cs_push_class"><code>cs_push_class</code></a> or
        when setting Virtual Method Table for <em>fulluserdata</em> with
        <a href="#cs_set_uservmt"><code>cs_set_uservmt</code></a>.
        <br/><br/>
        It holds an array <code>func</code> of size
        <a href="#CS_MM_N"><code>CS_MM_N</code></a> and each entry holds a
        <a href="#cs_CFunction"><code>cs_CFunction</code></a>.
        Programmer should set all entries in <code>func</code>; the metamethod
        entries that are not being used should be set as <em>NULL</em>; used
        entries should contain a valid
        <a href="#cs_CFunction"><code>cs_CFunction</code></a>.
        Here is an example of setting the <code>cs_VMT</code> before
        calling the <a href="#cs_push_class"><code>cs_push_class</code></a>:
        <pre>
    /*
    ** Suppose we are creating a Vec2 class and we wish to overload
    ** addition ("__add") operator and instance initializer ("__init").
    */

    static int initvec2 (cs_State *C) {
        /* Vec2 instance is the first and only argument */
        cs_push_number(C, 0.0);
        cs_set_fieldstr(C, 0, "x");     /* set "x" field */

        cs_push_number(C, 0.0);
        cs_set_fieldstr(C, 0, "y");     /* set "y" field */

        return 1;       /* return the instance */
    }

    static int addvec2 (cs_State *C) {
        /* arguments are two Vec2 instances */
        cs_get_class(C, 0); 
        cs_push_instance(C, -1);    /* create new Vec2 instance */

        cs_get_fieldstr(C, 0, "x");
        cs_get_fieldstr(C, 1, "x");
        cs_arith(C, OP_ADD);         /* add the "x" */
        cs_set_fieldstr(C, 2, "x");  /* set the "x" field of the new instance */

        cs_get_fieldstr(C, 0, "y");
        cs_get_fieldstr(C, 1, "y");
        cs_arith(C, OP_ADD);         /* add the "y" */
        cs_set_fieldstr(C, 2, "y");  /* set the "y" field of the new instance */

        return 1;   /* return only the new instance */
    }

    static void pushclass_vec2 (cs_State *C) {
        cs_VMT vmt = {0};       /* zero initialize */
        vmt.func[CS_MM_INIT] = initvec2;    /* set CS_MM_INIT entry */
        vmt.func[CS_MM_ADD] = addvec2;      /* set CS_MM_ADD entry */

        /*
        ** Finally create (and push) the class with 'vmt', no superclass (-1),
        ** no upvalues (0) and no methods (NULL).
        */
        cs_push_class(C, &vmt, -1, 0, NULL);
    }</pre>
        Usually you would implement this functionality within
        <em>fulluserdata</em> bypassing core API which would greatly increase
        performance. Classes are meant to be used within CScript functions,
        however CScript offers both options in order to be fully embeddable.
        For more information about what each metamethod function expects
        see <a href="#2.4"><code>&sect;2.4</code></a>.
        </p>

        <!-- cs_Entry -->
        <hr><h3><a name="cs_Entry"><code>cs_Entry</code></a></h3>
        <pre>
    typedef struct cs_Entry {
        const char *name;
        cs_CFunction func;
    } cs_Entry;</pre>
        <p>
        Type for arrays of functions or methods to be set by
        <a href="#cs_push_class"><code>cs_push_class</code></a> or
        <a href="#csL_set_funcs"><code>csL_set_funcs</code></a>.
        <code>name</code> is the function name and <code>func</code> is a
        pointer to the function.
        Any array of <a href="#csL_Entry"><code>csL_Entry</code></a> must end
        with a sentinel entry in which both <code>name</code> and
        <code>func</code> are <code>NULL</code>.
        </p>

        <!-- cs_DebugInfo -->
        <hr><h3><a name="cs_DebugInfo"><code>cs_DebugInfo</code></a></h3>
        <pre>
    typedef struct cs_Debug {
        const char *name;           /* (n) */
        const char *namewhat;       /* (n) */
        const char *what;           /* (s) */
        const char *source;         /* (s) */
        size_t srclen;              /* (s) */
        int currline;               /* (l) */
        int defline;                /* (s) */
        int lastdefline;            /* (s) */
        int nupvals;                /* (u) number of upvalues */
        int nparams;                /* (u) number of parameters */
        char isvararg;              /* (u) */
        char shortsrc[CS_MAXSRC];   /* (s) */
        /* private part */
        <em>other fields</em>
    } cs_Debug;</pre>
        <p>
        A structure used to carry different pieces of information about a
        function or an activation record.
        <a href="#cs_getstack"><code>cs_getstack</code></a> fills only the
        private part of this structure, for later use.
        To fill the other fields of
        <a href="#cs_Debug"><code>cs_Debug</code></a> with useful information,
        you must call <a href="#cs_getinfo"><code>cs_getinfo</code></a> with
        an appropriate parameter. (Specifically, to get a field, you must add
        the letter between parentheses in the field's comment to the parameter
        <code>what</code> of <a href="#cs_getinfo"><code>cs_getinfo</code></a>.)
        <br/><br/>
        The fields of <a href="#cs_Debug"><code>cs_Debug</code></a> have the
        following meaning:
        <ul>
            <li>
                <b><code>source</code>: </b>
                the source of the chunk that created the function.
            </li>
            <li>
                <b><code>srclen</code>: </b>
                The length of the string <code>source</code>.
            </li>
            <li>
                <b><code>shortsrc</code>: </b>
                a "printable" version of <code>source</code>, to be used in
                error messages.
            </li>
            <li>
                <b><code>defline</code>: </b>
                the line number where the definition of the function starts.
            </li>
            <li>
                <b><code>lastdefline</code>: </b>
                the line number where the definition of the function ends.
            </li>
            <li>
                <b><code>what</code>: </b>
                the string <code>"CScript"</code> if the function is a CScript
                function, <code>"C"</code> if it is a C&nbsp;function,
                <code>"main"</code> if it is the main part of a chunk.
            </li>
            <li>
                <b><code>currline</code>: </b>
                the current line where the given function is executing.
            </li>
            <li>
                <b><code>name</code>: </b>
                a reasonable name for the given function.
                Because functions in CScript are first-class values, they do
                not have a fixed name: some functions can be the value of
                multiple global variables, while others can be stored only
                in a table field.
                The <code>cs_getinfo</code> function checks how the function
                was called to find a suitable name.
                If it cannot find a name, then <code>name</code> is set to
                <code>NULL</code>.
            </li>
            <li>
                <b><code>namewhat</code>: </b>
                explains the <code>name</code> field.
                The value of <code>namewhat</code> can be
                <code>"global"</code>, <code>"local"</code>,
                <code>"method"</code>, <code>"field"</code>,
                <code>"upvalue"</code>, or <code>""</code> (the empty string),
                according to how the function was called. (CScript uses the
                empty string when no other option seems to apply.)
                <br/>
                <b>NOTE:</b> only <code>"method"</code> works for now, this
                is until symbolic execution is implemented internally.
            </li>
            <li>
                <b><code>nupvals</code>: </b>
                the number of upvalues of the function.
            </li>
            <li>
                <b><code>nparams</code>: </b>
                the number of parameters of the function
                (always 0&nbsp;for C&nbsp;functions).
            </li>
            <li>
                <b><code>isvararg</code>: </b>
                true if the function is a variadic function
                (always true for C&nbsp;functions).
            </li>
        </ul>
        </p>

        <!-- cs_MM -->
        <hr><h3><a name="cs_MM"><code>cs_MM</code></a></h3>
        <pre>
    typedef enum cs_MM {
        CS_MM_GETIDX = 0,
        CS_MM_SETIDX,
        CS_MM_GC,
        CS_MM_CLOSE,
        CS_MM_CALL,
        CS_MM_CONCAT,
        CS_MM_ADD, 
        CS_MM_SUB,
        CS_MM_MUL,
        CS_MM_DIV,
        CS_MM_MOD,
        CS_MM_POW,
        CS_MM_BSHL,
        CS_MM_BSHR,
        CS_MM_BAND,
        CS_MM_BOR,
        CS_MM_BXOR,
        CS_MM_UNM,
        CS_MM_BNOT,
        CS_MM_EQ,
        CS_MM_LT,
        CS_MM_LE,
        CS_MM_N, /* number of mm */
    } cs_MM;</pre>
        <p>
        These values correspond to each <a href="#Metamethods">metamethod</a>.
        They are used for setting <em>fulluserdata</em> metamethods with
        <a href="#cs_set_usermm"><code>cs_set_usermm</code></a>, testing
        if object has a metamethod defined with 
        <a href="#cs_hasmetamethod"><code>cs_hasmetamethod</code></a>, getting
        a metamethod with
        <a href="#cs_get_metamethod"><code>cs_get_metamethod</code></a> and in
        setting the <a href="#cs_VMT"><code>cs_VMT</code></a>.
        Total number of metamethods is denoted by <code>CS_MM_N</code>.
        <br/><br/>
        For more information on metamethods see <a href="#2.4">&sect;2.4</a>.
        </p>

        <!-- cs_newstate -->
        <hr><h3><a name="cs_newstate"><code>cs_newstate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_newstate (cs_Alloc f, void *ud);</pre>
        <p>
        Creates a new independent state and returns its main thread.
        Returns <code>NULL</code> if it cannot create the state
        (due to lack of memory).
        The argument <code>f</code> is the allocator function;
        CScript will do all memory allocation for this state through this
        function (see <a href="#cs_Alloc"><code>cs_Alloc</code></a>).
        The second argument, <code>ud</code>, is an opaque pointer that
        CScript passes to the allocator in every call.
        </p>

        <!-- cs_close -->
        <hr><h3><a name="cs_close"><code>cs_close</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_close (cs_State *C);</pre>
        <p>
        Close all active to-be-closed variables in the main thread,
        release all objects in the given CScript state
        (calling the corresponding garbage-collection metamethods, if any),
        and frees all dynamic memory used by this state.
        <br/><br/>
        On several platforms, you may not need to call this function,
        because all resources are naturally released when the host program ends.
        On the other hand, long-running programs that create multiple states,
        such as daemons or web servers, will probably need to close states as
        soon as they are not needed.
        </p>

        <!-- cs_newthread -->
        <hr><h3><a name="cs_newthread"><code>cs_newthread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>cs_State *cs_newthread (cs_State *C);</pre>
        <p>
        Creates a new thread, pushes it on the stack,
        and returns a pointer to a <a href="#cs_State"><code>cs_State</code></a>
        that represents this new thread.
        The new thread returned by this function shares with the original
        thread its global environment, but has an independent execution stack.
        <br/><br/>
        Threads are subject to garbage collection, like any CScript object.
        </p>

        <!-- cs_resetthread -->
        <hr><h3><a name="cs_resetthread"><code>cs_resetthread</code></a></h3>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>int cs_resetthread (cs_State *C);</pre>
        <p>
        Resets a thread, cleaning its call stack and closing all pending
        to-be-closed variables.
        Returns a status code: <a href="#CS_OK"><code>CS_OK</code></a>
        for no errors in the thread (either the original error that stopped
        the thread or errors in closing methods), or an error status otherwise.
        In case of error, leaves the error object on the top of the stack.
        </p>

        <!-- cs_atpanic -->
        <hr><h3><a name="cs_atpanic"><code>cs_atpanic</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_CFunction cs_atpanic (cs_State *C, cs_CFunction panicf);</pre>
        <p>
        Sets a new panic function and returns the old one
        (see <a href="#4.4">&sect;4.4</a>).
        </p>

        <!-- cs_version -->
        <hr><h3><a name="cs_version"><code>cs_version</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_version (cs_State *C);</pre>
        <p>
        Returns the version number of this core.
        </p>

        <!-- cs_setntop -->
        <hr><h3><a name="cs_setntop"><code>cs_setntop</code></a></h3>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void cs_setntop (cs_State *C, int n);</pre>
        <p>
        Sets the stack top to hold <code>n</code> values on the stack.
        If the new top is greater than the old one, then the new elements are
        filled with <b>nil</b>.
        If <code>index</code> is&nbsp;0, then all stack elements are removed.
        <br/><br/>
        This function can run arbitrary code when removing an index
        marked as to-be-closed from the stack.
        </p>

        <!-- cs_gettop -->
        <hr><h3><a name="cs_gettop"><code>cs_gettop</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_gettop (cs_State *C);</pre>
        <p>
        Returns the index of the top element in the stack.
        This result is equal to the number of elements in the stack - 1;
        So return value of -1&nbsp;means an empty stack.
        </p>

        <!-- cs_absindex -->
        <hr><h3><a name="cs_absindex"><code>cs_absindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_absindex (cs_State *C, int index);</pre>
        <p>
        Converts the acceptable index <code>index</code> into an equivalent
        absolute index (that is, one that does not depend on the stack size).
        </p>

        <!-- cs_rotate -->
        <hr><h3><a name="cs_rotate"><code>cs_rotate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_rotate (cs_State *C, int index, int n);</pre>
        <p>
        Rotates the stack elements between the valid index <code>index</code>
        and the top of the stack.
        The elements are rotated <code>n</code> positions in the direction of
        the top, for a positive <code>n</code>, or <code>-n</code> positions
        in the direction of the bottom, for a negative <code>n</code>.
        The absolute value of <code>n</code> must not be greater than the size
        of the slice being rotated.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_copy -->
        <hr><h3><a name="cs_copy"><code>cs_copy</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_copy (cs_State *C, int src, int dest);</pre>
        <p>
        Copies the element at index <code>src</code> into the valid
        index <code>dest</code>, replacing the value at that position.
        Values at other positions are not affected.
        </p>

        <!-- cs_checkstack -->
        <hr><h3><a name="cs_checkstack"><code>cs_checkstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_checkstack (cs_State *C, int n);</pre>
        <p>
        Ensures that the stack has space for at least <code>n</code> extra
        elements, that is, that you can safely push up to <code>n</code>
        values into it.
        It returns false if it cannot fulfill the request, either because it
        would cause the stack to be greater than a fixed maximum size
        (typically at least several thousand elements) or because it cannot
        allocate memory for the extra space.
        This function never shrinks the stack; if the stack already has space
        for the extra elements, it is left unchanged.
        </p>

        <!-- cs_push -->
        <hr><h3><a name="cs_push"><code>cs_push</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push (cs_State *C, int index);</pre>
        <p>
        Pushes a copy of the element at the given index onto the stack.
        </p>

        <!-- cs_xmove -->
        <hr><h3><a name="cs_xmove"><code>cs_xmove</code></a></h3>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void cs_xmove (cs_State *src, cs_State *dest, int n);</pre>
        <p>
        Exchange values between different threads of the same state.
        <br/><br/>
        This function pops <code>n</code> values from the stack
        <code>src</code>, and pushes them onto the stack <code>dest</code>.
        </p>

        <!-- cs_is_number -->
        <hr><h3><a name="cs_is_number"><code>cs_is_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_number (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a number, and
        0&nbsp;otherwise.
        </p>

        <!-- cs_is_integer -->
        <hr><h3><a name="cs_is_integer"><code>cs_is_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_integer (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is an integer
        (that is, the value is a number and is represented as an integer),
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_string -->
        <hr><h3><a name="cs_is_string"><code>cs_is_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_string (cs_State *C);</pre>
        <p>
        </p>

        <!-- cs_is_cfunction -->
        <hr><h3><a name="cs_is_cfunction"><code>cs_is_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_is_cfunction (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a C&nbsp;function,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_userdata -->
        <hr><h3><a name="cs_is_userdata"><code>cs_is_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_userdata (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a userdata
        (either full or light), and 0&nbsp;otherwise.
        </p>

        <!-- cs_type -->
        <hr><h3><a name="cs_type"><code>cs_type</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_type (cs_State *C, int index);</pre>
        <p>
        Returns the type of the value in the given valid index,
        or <code>CS_TNONE</code> for a non-valid but acceptable index.
        The types returned by <a href="#cs_type"><code>cs_type</code></a>
        are coded by the following constants defined in <code>cscript.h</code>:
        <a name="CS_TNIL"><code>CS_TNIL</code></a>,
        <a name="CS_TBOOL"><code>CS_TBOOL</code></a>,
        <a name="CS_TNUMBER"><code>CS_TNUMBER</code></a>,
        <a name="CS_TUSERDATA"><code>CS_TUSERDATA</code></a>,
        <a name="CS_TLIGHTUSERDATA"><code>CS_TLIGHTUSERDATA</code></a>,
        <a name="CS_TSTRING"><code>CS_TSTRING</code></a>,
        <a name="CS_TARRAY"><code>CS_TARRAY</code></a>,
        <a name="CS_TTABLE"><code>CS_TTABLE</code></a>,
        <a name="CS_TFUNCTION"><code>CS_TFUNCTION</code></a>,
        <a name="CS_TCLASS"><code>CS_TCLASS</code></a>,
        <a name="CS_TINSTANCE"><code>CS_TINSTANCE</code></a>
        and <a name="CS_TTHREAD"><code>CS_TTHREAD</code></a>.
        </p>

        <!-- cs_typename -->
        <hr><h3><a name="cs_typename"><code>cs_typename</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_typename (cs_State *C, int type);</pre>
        <p>
        Returns the name of the type encoded by the value <code>type</code>,
        which must be one the values returned by
        <a href="#cs_type"><code>cs_type</code></a>.
        </p>

        <!-- cs_to_numberx -->
        <hr><h3><a name="cs_to_numberx"><code>cs_to_numberx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_to_numberx (cs_State *C, int index, int *isnum);</pre>
        <p>
        Converts the CScript value at the given index to the C&nbsp;type
        <a href="#cs_Number"><code>cs_Number</code></a>
        (see <a href="#cs_Number"><code>cs_Number</code></a>).
        The CScript value must be a number or a string convertible to a number
        (see <a href="#3.4.3">&sect;3.4.3</a>); otherwise,
        <a href="#cs_to_numberx"><code>cs_to_numberx</code></a>
        returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- cs_to_integerx -->
        <hr><h3><a name="cs_to_integerx"><code>cs_to_integerx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer cs_to_integerx (cs_State *C, int index, int *isnum);</pre>
        <p>
        Converts the CScript value at the given index
        to the signed integral type
        <a href="#cs_Integer"><code>cs_Integer</code></a>.
        The CScript value must be an integer, or a number or string
        convertible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>);
        otherwise, <code>cs_to_integerx</code> returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- cs_to_bool -->
        <hr><h3><a name="cs_to_bool"><code>cs_to_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_to_bool (cs_State *C, int index);</pre>
        <p>
        Converts the CScript value at the given index to a C&nbsp;boolean
        value (0&nbsp;or&nbsp;1).
        Like all tests in CScript,
        <a href="#cs_to_bool"><code>cs_to_bool</code></a>
        returns true for any CScript value different from <b>false</b> and
        <b>nil</b>; otherwise it returns false.
        (If you want to accept only actual boolean values,
        use <a href="#cs_is_bool"><code>cs_is_bool</code></a> to test the
        value's type.)
        </p>

        <!-- cs_to_lstring -->
        <hr><h3><a name="cs_to_lstring"><code>cs_to_lstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_to_lstring (cs_State *C, int index, size_t *len);</pre>
        <p>
        Converts the CScript value at the given index to a C&nbsp;string.
        If <code>len</code> is not <code>NULL</code>,
        it sets <code>*len</code> with the string length.
        The CScript value must be a string; otherwise, the function returns
        <code>NULL</code>.
        <br/><br/>
        <code>cs_to_lstring</code> returns a pointer to a string inside the
        CScript state (see <a href="#4.1.3">&sect;4.1.3</a>).
        This string always has a zero ('<code>\0</code>') after its last
        character (as in&nbsp;C), but can contain other zeros in its body.
        </p>

        <!-- cs_to_cfunction -->
        <hr><h3><a name="cs_to_cfunction"><code>cs_to_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_CFunction cs_to_cfunction (cs_State *C, int index);</pre>
        <p>
        Converts a value at the given index to a C&nbsp;function.
        That value must be a C&nbsp;function;
        otherwise, returns <code>NULL</code>.
        </p>

        <!-- cs_to_userdata -->
        <hr><h3><a name="cs_to_userdata"><code>cs_to_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *cs_to_userdata (cs_State *C, int index);</pre>
        <p>
        If the value at the given index is a full userdata, returns its
        memory-block address.
        If the value is a light userdata, returns its value (a pointer).
        Otherwise, returns <code>NULL</code>.
        </p>

        <!-- cs_to_pointer -->
        <hr><h3><a name="cs_to_pointer"><code>cs_to_pointer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const void *cs_to_pointer (cs_State *C, int index);</pre>
        <p>
        Converts the value at the given index to a generic C&nbsp;pointer
        (<code>void*</code>).
        The value can be a userdata, a table, a thread, a string, instance,
        a class, array or a function; otherwise, <code>cs_to_pointer</code>
        returns <code>NULL</code>.
        Different objects will give different pointers.
        There is no way to convert the pointer back to its original value.
        <br/><br/>
        Typically this function is used only for hashing and debug information.
        </p>

        <!-- cs_to_thread -->
        <hr><h3><a name="cs_to_thread"><code>cs_to_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_State *cs_to_thread (cs_State *C, int index);</pre>
        <p>
        Converts the value at the given index to a CScript thread
        (represented as <code>cs_State*</code>).
        This value must be a thread; otherwise, the function returns
        <code>NULL</code>.
        </p>

        <!-- cs_arith -->
        <hr><h3><a name="cs_arith"><code>cs_arith</code></a></h3>
        <span class="apii">[-(2|1), +1, <em>e</em>]</span>
        <pre>void cs_arith (cs_State *C, int op);</pre>
        <p>
        Performs an arithmetic or bitwise operation over the two values
        (or one, in the case of negations) at the top of the stack,
        with the value on the top being the second operand, pops these values,
        and pushes the result of the operation.
        The function follows the semantics of the corresponding CScript
        operator (that is, it may call metamethods).
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="CS_OPADD"><code>CS_OPADD</code></a>: </b>
                performs addition (<code>+</code>)
            </li>
            <li>
                <b><a name="CS_OPSUB"><code>CS_OPSUB</code></a>: </b>
                performs subtraction (<code>-</code>)
            </li>
            <li>
                <b><a name="CS_OPMUL"><code>CS_OPMUL</code></a>: </b>
                performs multiplication (<code>*</code>)
            </li>
            <li>
                <b><a name="CS_OPDIV"><code>CS_OPDIV</code></a>: </b>
                performs float division (<code>/</code>)
            </li>
            <li>
                <b><a name="CS_OPMOD"><code>CS_OPMOD</code></a>: </b>
                performs modulo (<code>%</code>)
            </li>
            <li>
                <b><a name="CS_OPPOW"><code>CS_OPPOW</code></a>: </b>
                performs exponentiation (<code>^</code>)
            </li>
            <li>
                <b><a name="CS_OPSHL"><code>CS_OPSHL</code></a>: </b>
                performs left shift (<code>&lt;&lt;</code>)
            </li>
            <li>
                <b><a name="CS_OPSHR"><code>CS_OPSHR</code></a>: </b>
                performs right shift (<code>&gt;&gt;</code>)
            </li>
            <li>
                <b><a name="CS_OPBAND"><code>CS_OPBAND</code></a>: </b>
                performs bitwise AND (<code>&amp;</code>)
            </li>
            <li>
                <b><a name="CS_OPBOR"><code>CS_OPBOR</code></a>: </b>
                performs bitwise OR (<code>|</code>)
            </li>
            <li>
                <b><a name="CS_OPBXOR"><code>CS_OPBXOR</code></a>: </b>
                performs bitwise exclusive OR (<code>~</code>)
            </li>
            <li>
                <b><a name="CS_OPUNM"><code>CS_OPUNM</code></a>: </b>
                performs mathematical negation (unary <code>-</code>)
            </li>
            <li>
                <b><a name="CS_OPBNOT"><code>CS_OPBNOT</code></a>: </b>
                performs bitwise NOT (<code>~</code>)
            </li>
        </ul>
        </p>

        <!-- cs_rawequal -->
        <hr><h3><a name="cs_rawequal"><code>cs_rawequal</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_rawequal (cs_State *C, int v1, int v2);</pre>
        <p>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        Returns a boolean.
        </p>

        <!-- cs_compare -->
        <hr><h3><a name="cs_compare"><code>cs_compare</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_compare (cs_State *C, int index1, int index2, int op);</pre>
        <p>
        Compares two CScript values.
        Returns 1 if the value at index <code>index1</code> satisfies
        <code>op</code> when compared with the value at index
        <code>index2</code>, following the semantics of the corresponding
        CScript operator (that is, it may call metamethods).
        Otherwise returns&nbsp;0.
        Also returns&nbsp;0 if any of the indices is not valid.
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="CS_OPEQ"><code>CS_OPEQ</code></a>: </b>
                compares for equality (<code>==</code>)
            </li>
            <li>
                <b><a name="CS_OPLT"><code>CS_OPLT</code></a>: </b>
                compares for less than (<code>&lt;</code>)
            </li>
            <li>
                <b><a name="CS_OPLE"><code>CS_OPLE</code></a>: </b>
                compares for less or equal (<code>&lt;=</code>)
            </li>
        </ul>
        </p>

        <!-- cs_push_nil -->
        <hr><h3><a name="cs_push_nil"><code>cs_push_nil</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_nil (cs_State *C);</pre>
        <p>
        Pushes a nil value onto the stack.
        </p>

        <!-- cs_push_number -->
        <hr><h3><a name="cs_push_number"><code>cs_push_number</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_number (cs_State *C, cs_Number n);</pre>
        <p>
        Pushes a float with value <code>n</code> onto the stack.
        </p>

        <!-- cs_push_integer -->
        <hr><h3><a name="cs_push_integer"><code>cs_push_integer</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_integer (cs_State *C, cs_Integer n);</pre>
        <p>
        Pushes an integer with value <code>n</code> onto the stack.
        </p>

        <!-- cs_push_lstring -->
        <hr><h3><a name="cs_push_lstring"><code>cs_push_lstring</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *cs_push_lstring (cs_State *C, const char *s, size_t len);</pre>
        <p>
        Pushes the string pointed to by <code>s</code> with size
        <code>len</code> onto the stack.
        CScript will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        The string can contain any binary data, including embedded zeros.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        </p>

        <!-- cs_push_string -->
        <hr><h3><a name="cs_push_string"><code>cs_push_string</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *cs_push_string (cs_State *C, const char *s);</pre>
        <p>
        Pushes the zero-terminated string pointed to by <code>s</code>
        onto the stack.
        CScript will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        <br/><br/>
        If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and
        returns <code>NULL</code>.
        </p>

        <!-- cs_push_fstring -->
        <hr><h3><a name="cs_push_fstring"><code>cs_push_fstring</code></a></h3>
        <span class="apii">[-0, +1, <em>v</em>]</span>
        <pre>const char *cs_push_fstring (cs_State *C, const char *fmt, ...);</pre>
        <p>
        Pushes onto the stack a formatted string and returns a pointer to
        this string (see <a href="#4.1.3">&sect;4.1.3</a>).
        It is similar to the ISO&nbsp;C function <code>sprintf</code>,
        but has two important differences.
        First, you do not have to allocate space for the result; the result
        is a CScript string and CScript takes care of memory allocation
        (and deallocation, through garbage collection).
        Second, the conversion specifiers are quite restricted.
        There are no flags, widths, or precisions.
        <br/>
        The conversion specifiers can only be:
        <ul>
            <li>
                '<code>%%</code>' (inserts the character '<code>%</code>'),
            </li>
            <li>
                '<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
            </li>
            <li>
                '<code>%f</code>' (inserts a <a href="#cs_Number"><code>cs_Number</code></a>),
            </li>
            <li>
                '<code>%I</code>' (inserts a <a href="#cs_Integer"><code>cs_Integer</code></a>),
            </li>
            <li>
                '<code>%p</code>' (inserts a pointer),
            </li>
            <li>
                '<code>%d</code>' (inserts an <code>int</code>),
            </li>
            <li>
                '<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
            </li>
            <li>
                '<code>%U</code>' (inserts a <code>long int</code> as a UTF-8 byte sequence).
            </li>
        </ul>
        This function may raise errors due to memory overflow
        or an invalid conversion specifier.
        </p>

        <!-- cs_push_vfstring -->
        <hr><h3><a name="cs_push_vfstring"><code>cs_push_vfstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_push_vfstring (cs_State *C, const char *fmt, va_list argp);</pre>
        <p>
        Equivalent to
        <a href="#cs_push_fstring"><code>cs_push_fstring</code></a>,
        except that it receives a <code>va_list</code> instead of a variable
        number of arguments.
        </p>

        <!-- cs_push_cclosure -->
        <hr><h3><a name="cs_push_cclosure"><code>cs_push_cclosure</code></a></h3>
        <span class="apii">[-n, +1, <em>m</em>]</span>
        <pre>void cs_push_cclosure (cs_State *C, cs_CFunction f, int upvals);</pre>
        <p>
        Pushes a new C&nbsp;closure onto the stack.
        This function receives a pointer to a C&nbsp;function and pushes onto
        the stack a CScript value of type <code>function</code> that, when
        called, invokes the corresponding C&nbsp;function.
        The parameter <code>n</code> tells how many upvalues this function
        will have (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Any function to be callable by CScript must follow the correct protocol
        to receive its parameters and return its results
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        When a C&nbsp;function is created, it is possible to associate some
        values with it, the so called upvalues; these upvalues are then
        accessible to the function whenever it is called.
        This association is called a C&nbsp;closure
        (see <a href="#4.2">&sect;4.2</a>).
        To create a C&nbsp;closure, first the initial values for its upvalues
        must be pushed onto the stack.
        (When there are multiple upvalues, the first value is pushed first.)
        Then <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a>
        is called to create and push the C&nbsp;function onto the stack,
        with the argument <code>n</code> telling how many values will be
        associated with the function.
        <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a> also
        pops these values from the stack.
        <br/><br/>
        When <code>n</code> is zero, this function creates a
        <em>light C&nbsp;function</em>, which is just a pointer to the
        C&nbsp;function.
        In that case, it never raises a memory error.
        </p>

        <!-- cs_push_bool -->
        <hr><h3><a name="cs_push_bool"><code>cs_push_bool</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_bool (cs_State *C, int b);</pre>
        <p>
        Pushes a boolean value with value <code>b</code> onto the stack.
        </p>

        <!-- cs_push_lightuserdata -->
        <hr><h3><a name="cs_push_lightuserdata"><code>cs_push_lightuserdata</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_lightuserdata (cs_State *C, void *p);</pre>
        <p>
        Pushes a light userdata onto the stack.
        <br/><br/>
        Userdata represent C&nbsp;values in CScript.
        A <em>light userdata</em> represents a pointer, a <code>void*</code>.
        It is a value (like a number): you do not create it and it is not
        collected (as it was never created).
        A light userdata is equal to "any" light userdata with the same
        C&nbsp;address.
        </p>

        <!-- cs_push_array -->
        <hr><h3><a name="cs_push_array"><code>cs_push_array</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void cs_push_array (cs_State *C, int size);</pre>
        <p>
        Creates a new empty array and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many elements the
        array will have.
        CScript may use these hints to preallocate memory for the new
        array.
        This preallocation may help performance when you know in advance how
        many elements the array will have.
        </p>

        <!-- cs_push_table -->
        <hr><h3><a name="cs_push_table"><code>cs_push_table</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void cs_push_table (cs_State *C, int size);</pre>
        <p>
        Creates a new empty table and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many elements the
        table will have.
        CScript may use these hints to preallocate memory for the new
        table.
        This preallocation may help performance when you know in advance how
        many elements the table will have.
        </p>

        <!-- cs_push_thread -->
        <hr><h3><a name="cs_push_thread"><code>cs_push_thread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_push_thread (cs_State *C);</pre>
        <p>
        Pushes the thread represented by <code>C</code> onto the stack.
        Returns 1 if this thread is the main thread of its state.
        </p>

        <!-- cs_push_instance -->
        <hr><h3><a name="cs_push_instance"><code>cs_push_instance</code></a></h3>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void cs_push_instance (cs_State *C, int clsobj);</pre>
        <p>
        Creates a new instance from class object at index <code>clsobj</code>
        and pushes it on top of the stack. <code>clsobj</code> must be a
        valid index of the class object.
        <br/>
        This function may call <code>__call</code> metamethod if the class
        implements it.
        <br/>
        (In which case the returned value might not necessarily be the
        instance.)
        </p>

        <!-- cs_push_class -->
        <hr><h3><a name="cs_push_class"><code>cs_push_class</code></a></h3>
        <span class="apii">[-nup, +1, <em>m</em>]</span>
        <pre>void cs_push_class (cs_State *C,
                    const cs_VMT *vmt,
                    int abscls,
                    int nup,
                    const cs_Entry *list);</pre>
        <p>
        Creates a new class and pushes it on top of the stack.
        <a href="#cs_VMT"><code>vmt</code></a> structure holds metamethod
        entries that class should implement.
        <code>abscls</code> is the absolute index to the <em>superclass</em>
        the class is inheriting, if set to negative value (e.g. -1) the class
        will not inherit and the value is ignored.
        <code>nup</code> is the number of values on top of the stack
        associated with the class methods in <code>list</code>.
        <a href="#cs_Entry"><code>list</code></a> is the list of the class
        methods; in cases where the class has a <em>superclass</em>
        (<code>abscls</code> >= 0) and function name in the <code>list</code>
        collides with the <em>superclass</em> method, then the
        <em>superclass</em> method gets overwritten, meaning <code>list</code>
        methods have priority.
        <br/><br/>
        Every method entry in the <code>list</code> with a non-NULL name must
        have a C&nbsp;function associated with it.
        </p>

        <!-- cs_get_global -->
        <hr><h3><a name="cs_get_global"><code>cs_get_global</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_global (cs_State *C, const char *name);</pre>
        <p>
        Pushes onto the stack the value of the global <code>name</code>.
        Returns the type of that value.
        </p>

        <!-- cs_get -->
        <hr><h3><a name="cs_get"><code>cs_get</code></a></h3>
        <span class="apii">[-1, +1, <em>e</em>]</span>
        <pre>int cs_get (cs_State *C, int index);</pre>
        <p>
        Pushes on the stack the value <code>obj[k]</code>, where
        <code>obj</code> is the value at the given index and <code>k</code>
        is the value on top of the stack.
        <br/><br/>
        This function pops the key from the stack, pushing the resulting
        value in its place.
        As in CScript, this function may trigger a metamethod
        for the "getidx" event (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_raw -->
        <hr><h3><a name="cs_get_raw"><code>cs_get_raw</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int cs_get_raw (cs_State *C, int index);</pre>
        <p>
        Similar to <a href="#cs_get"><code>cs_get</code></a>, but does a raw
        access (i.e., without metamethods).
        The value at <code>index</code> must be a table, array or instance.
        </p>

        <!-- cs_get_index -->
        <hr><h3><a name="cs_get_index"><code>cs_get_index</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Pushes onto the stack the value <code>a[i]</code>,
        where <code>a</code> is the array at the given index.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_nilindex -->
        <hr><h3><a name="cs_get_nilindex"><code>cs_get_nilindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_get_nilindex (cs_State *C, int index, int begin, int end);</pre>
        <p>
        Returns the first index with <b>nil</b> value inside the array at
        the given index starting from <code>begin</code> index up to
        <code>end</code> index (inclusive).
        If <code>begin</code> is greater than <code>end</code> or the
        <code>end</code> is greater than the length of the array at the
        given index, then the <code>end</code> will be set as the last
        index of the array, and the whole array will be searched starting
        from the <code>begin</code> index.
        If there is no such index this returns -1.
        </p>

        <!-- cs_get_field -->
        <hr><h3><a name="cs_get_field"><code>cs_get_field</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int cs_get_field (cs_State *C, int index);</pre>
        <p>
        Identical to <a href="#cs_get_raw"><code>cs_get_raw</code></a> the only
        difference being that value at <code>index</code> must only be a
        table or instance (array is not allowed as arrays do not have fields).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldstr -->
        <hr><h3><a name="cs_get_fieldstr"><code>cs_get_fieldstr</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int cs_get_fieldstr (cs_State *C, int index, const char *field);</pre>
        <p>
        Similar to <a href="#cs_get_field"><code>cs_get_fieldstr</code></a>
        but instead of using the value on top of the stack as key, it instead
        uses the argument <code>field</code> which is a null-terminated string
        (i.e., <code>obj[field]</code>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldptr -->
        <hr><h3><a name="cs_get_fieldptr"><code>cs_get_fieldptr</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldptr (cs_State *C, int index, const void *field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is the pointer.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldint -->
        <hr><h3><a name="cs_get_fieldint"><code>cs_get_fieldint</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldint (cs_State *C, int index, cs_Integer field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is CScript <a href="#cs_Integer"><code>integer</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_fieldflt -->
        <hr><h3><a name="cs_get_fieldflt"><code>cs_get_fieldflt</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_fieldflt (cs_State *C, int index, cs_Number field);</pre>
        <p>
        Identical to <a href="cs_get_fieldstr"><code>cs_get_fieldstr</code></a>
        except the key is CScript <a href="#cs_Number"><code>float</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_class -->
        <hr><h3><a name="cs_get_class"><code>cs_get_class</code></a></h3>
        <span class="apii">[-0, +0|1, &ndash;]</span>
        <pre>int cs_get_class (cs_State *C, int index);</pre>
        <p>
        Pushes the class of the object at the <code>index</code> on top of
        the stack.
        <br/>
        Returns <code>CS_TCLASS</code> if the object at <code>index</code>
        is instance, otherwise nothing is pushed and this returns 
        <code>CS_TNONE</code>.
        </p>

        <!-- cs_get_method -->
        <hr><h3><a name="cs_get_method"><code>cs_get_method</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_method (cs_State *C, int index);</pre>
        <p>
        Pushes onto the stack a method of the value <code>ins[k]</code> where
        <code>ins</code> is the value at the given index and <code>k</code>
        is the value on top of the stack.
        This performs raw access on the method table of the instance and as
        such can't invoke a metamethod.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- cs_get_metamethod -->
        <hr><h3><a name="cs_get_metamethod"><code>cs_get_metamethod</code></a></h3>
        <span class="apii">[-0, +0|1, &ndash;]</span>
        <pre>int cs_get_metamethod (cs_State *C, int index, cs_MM mm);</pre>
        <p>
        Pushes onto the stack a metamethod <code>mm</code> of the value at
        <code>index</code>. Values that can have metamethods are fulluserdata
        and classes (and instances by proxy).
        <br/><br/>
        If the value has <a href="#cs_VMT"><code>virtual method table</code></a>
        then this returns <code>CS_TFUNCTION</code> if <code>mm</code> is set;
        else <code>CS_TNIL</code>.
        Otherwise returns <code>CS_TNONE</code> and nothing is pushed on the
        stack.
        </p>

        <!-- cs_newuserdata -->
        <hr><h3><a name="cs_newuserdata"><code>cs_newuserdata</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void *cs_newuserdata (cs_State *C, size_t size, int nuv);</pre>
        <p>
        This function creates and pushes on the stack a new full userdata,
        with <code>nuv</code> associated CScript values, called
        <code>user values</code>, plus an associated block of raw memory with
        <code>size</code> bytes.
        (The user values can be set and read with the functions
        <a href="#cs_set_uservalue"><code>cs_set_uservalue</code></a> and
        <a href="#cs_get_uservalue"><code>cs_get_uservalue</code></a>.)
        <br/><br/>
        The function returns the address of the block of memory.
        CScript ensures that this address is valid as long as the corresponding
        userdata is alive (see <a href="#2.5">&sect;2.5</a>).
        Moreover, if the userdata is marked for finalization
        (see <a href="#2.5.3">&sect;2.5.3</a>), its address is valid at least
        until the call to its finalizer.
        </p>

        <!-- cs_get_uservalue -->
        <hr><h3><a name="cs_get_uservalue"><code>cs_get_uservalue</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int cs_get_uservalue (cs_State *C, int index, int n);</pre>
        <p>
        Pushes onto the stack the <code>n</code>-th user value associated with
        the full userdata at the given index and returns the type of the
        pushed value.
        <br/><br/>
        If the userdata does not have that value, pushes <b>nil</b> and
        returns <a href="CS_TNONE"><code>CS_TNONE</code></a>.
        </p>

        <!-- cs_set_global -->
        <hr><h3><a name="cs_set_global"><code>cs_set_global</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void cs_set_global (cs_State *C, const char *name);</pre>
        <p>
        Pops a value from the stack and sets it as the new value of global
        <code>name</code>.
        </p>

        <!-- cs_set -->
        <hr><h3><a name="cs_set"><code>cs_set</code></a></h3>
        <span class="apii">[-2, +0, <em>e</em>]</span>
        <pre>void cs_set (cs_State *C, int index);</pre>
        <p>
        Does the equivalent to <code>obj[k] = v</code>, where <code>obj</code>
        is the value at the given index, <code>v</code> is the value on top of
        the stack and <code>k</code> is the value on stack below the
        <code>v</code>.
        <br/><br/>
        This function pops both the key and value off the stack.
        As in CScript, this function may trigger a metamethod
        for the "setidx" event (see <a href="#2.4">&sect;2.4</a>).
        </p>

        <!-- cs_set_raw -->
        <hr><h3><a name="cs_set_raw"><code>cs_set_raw</code></a></h3>
        <span class="apii">[-2, +0, <em>v</em>]</span>
        <pre>void cs_set_raw (cs_State *C, int index);</pre>
        <p>
        Similar to <a href="#cs_set"><code>cs_set</code></a> except that it
        performs a raw set, meaning it wont invoke a metamethod.
        <br/>
        Value at the given index must be a table, array or instance, otherwise
        this function errors as the value can't be indexed.
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- cs_set_index -->
        <hr><h3><a name="cs_set_index"><code>cs_set_index</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void cs_set_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Does the equivalent of <code>a[i] = v</code>, where <code>a</code>
        is the array at the given index, <code>i</code> is index into the
        array and <code>v</code> is element value on top of the stack.
        <br/>
        As in CScript, the array grows in order to ensure that index fits,
        so if the index into the array is not in positive bounds of the array,
        then the array will try to grow in order to fit the index.
        Additionally all the "holes" will be set as <b>nil</b> and length
        updated to the <code>i + 1</code> (assuming that <code>i</code> is
        positive and in bounds of <code>int</code>).
        <br/><br/>
        This function pops the element value off the stack.
        </p>

        <!-- cs_set_field -->
        <hr><h3><a name="cs_set_field"><code>cs_set_field</code></a></h3>
        <span class="apii">[-2, +0, <em>m</em>]</span>
        <pre>void cs_set_field (cs_State *C, int index);</pre>
        <p>
        Identical to <a href="#cs_set_raw"><code>cs_set_raw</code></a> the only
        difference being that value at <code>index</code> must only be a table
        or instance (array is not allowed as arrays do not have fields).
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- cs_set_fieldstr -->
        <hr><h3><a name="cs_set_fieldstr"><code>cs_set_fieldstr</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_set_fieldstr (cs_State *C, int index, const char *field);</pre>
        <p>
        Similar to <a href="#cs_set_field"><code>cs_set_field</code></a>
        but instead of using the value on stack as the key, it instead uses
        the argument <code>field</code> which is null-terminated string
        (i.e., <code>obj[field]&nbsp;=&nbsp;v</code>).
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldptr -->
        <hr><h3><a name="cs_set_fieldptr"><code>cs_set_fieldptr</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_set_fieldptr (cs_State *C, int index, const void *field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the pointer.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldint -->
        <hr><h3><a name="cs_set_fieldint"><code>cs_set_fieldint</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_set_fieldint (cs_State *C, int index, cs_Integer field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the CScript
        <a href="#cs_Integer">integer</a>.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_fieldflt -->
        <hr><h3><a name="cs_set_fieldflt"><code>cs_set_fieldflt</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_set_fieldflt (cs_State *C, int index, cs_Number field);</pre>
        <p>
        Identical to <a href="#cs_set_field"><code>cs_set_field</code></a>
        except that the key argument is the CScript
        <a href="#cs_Number">float</a>.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- cs_set_uservmt -->
        <hr><h3><a name="cs_set_uservmt"><code>cs_set_uservmt</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void cs_set_uservmt (cs_State *C, int index, const cs_VMT *vmt);</pre>
        <p>
        Sets the <a href="#cs_VMT">virtual method table</a> of the full
        userdata at the given index.
        <br/>
        If <code>vmt</code> is NULL then the full userdata
        <a href="#cs_VMT">virtual method table</a>
        entries will be all set to <b>nil</b>, otherwise <code>vmt</code> will
        now be the <a href="#cs_VMT">virtual method table</a> of the full
        userdata at the given index.
        </p>

        <!-- cs_set_uservalue -->
        <hr><h3><a name="cs_set_uservalue"><code>cs_set_uservalue</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>int cs_set_uservalue (cs_State *C, int index, int n);</pre>
        <p>
        Pops a value from the stack and sets it as the new <code>n</code>-th
        user value associated to the full userdata at the given index.
        Returns 0 if the userdata does not have that value.
        </p>

        <!-- cs_set_usermm -->
        <hr><h3><a name="cs_set_usermm"><code>cs_set_usermm</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void cs_set_usermm (cs_State *C, int index, cs_MM mm);</pre>
        <p>
        Pops a value from the stack and sets it as the <code>mm</code> entry
        in the <a href="#cs_VMT">virtual method table</a> of the full userdata
        at the given index.
        </p>

        <!-- cs_status -->
        <hr><h3><a name="cs_status"><code>cs_status</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_status (cs_State *C);</pre>
        <p>
        Returns the status of the thread <code>C</code>.
        <br/><br/>
        The status can be <a href="#CS_OK"><code>CS_OK</code></a> for a normal
        thread.
        <br/>
        (This function is here only for when the coroutines get implemented,
        currently it offers nothing helpful.)
        <br/><br/>
        You can call functions only in threads with status
        <a href="#CS_OK"><code>CS_OK</code></a>.
        </p>

        <!-- cs_error -->
        <hr><h3><a name="cs_error"><code>cs_error</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_error (cs_State *C);</pre>
        <p>
        Raises a CScript error, using the value on the top of the stack as
        the error object.
        This function does a long jump, and therefore never returns
        (see <a href="#csL_error"><code>csL_error</code></a>).
        </p>

        <!-- cs_call -->
        <hr><h3><a name="cs_call"><code>cs_call</code></a></h3>
        <span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
        <pre>void cs_call (cs_State *C, int nargs, int nresults);</pre>
        <p>
        Calls a function.
        Like regular CScript calls, <code>cs_call</code> respects the
        <code>__call</code> metamethod.
        So, here the word "function" means any callable value.
        <br/><br/>
        To do a call you must use the following protocol:
        first, the function to be called is pushed onto the stack;
        then, the arguments to the call are pushed in direct order;
        that is, the first argument is pushed first.
        Finally you call <a href="#cs_call"><code>cs_call</code></a>;
        <code>nargs</code> is the number of arguments that you pushed onto
        the stack.
        When the function returns, all arguments and the function value are
        popped and the call results are pushed onto the stack.
        The number of results is adjusted to <code>nresults</code>,
        unless <code>nresults</code> is
        <a name="CS_MULRET"><code>CS_MULRET</code></a>.
        In this case, all results from the function are pushed;
        CScript takes care that the returned values fit into the stack space,
        but it does not ensure any extra space in the stack.
        The function results are pushed onto the stack in direct order
        (the first result is pushed first), so that after the call the last
        result is on the top of the stack.
        <br/><br/>
        Any error while calling and running the function is propagated upwards
        (with a <code>longjmp</code>).
        <br/><br/>
        The following example shows how the host program can do the
        equivalent to this CScript code:
        <pre>
    a = f("how", t.x, 14)</pre>
        Here it is in&nbsp;C:
        <pre>
    cs_get_global(C, "f");                 /* function to be called */
    cs_push_literal(C, "how");                      /* 1st argument */
    cs_get_global(C, "t");                   /* table to be indexed */
    cs_get_fieldstr(C, -1, "x");    /* push result of t.x (2nd arg) */
    cs_remove(C, -2);                  /* remove 't' from the stack */
    cs_push_integer(C, 14);                         /* 3rd argument */
    cs_call(C, 3, 1);     /* call 'f' with 3 arguments and 1 result */
    cs_set_global(C, "a");                        /* set global 'a' */</pre>
        Note that the code above is <em>balanced</em>:
        at its end, the stack is back to its original configuration.
        This is considered good programming practice.
        </p>

        <!-- cs_pcall -->
        <hr><h3><a name="cs_pcall"><code>cs_pcall</code></a></h3>
        <span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
        <pre>int cs_pcall (cs_State *C, int nargs, int nresults, int msgh);</pre>
        <p>
        Calls a function (or a callable object) in protected mode.
        <br/><br/>
        Both <code>nargs</code> and <code>nresults</code> have the same
        meaning as in <a href="#cs_call"><code>cs_call</code></a>.
        If there are no errors during the call,
        <a href="#cs_pcall"><code>cs_pcall</code></a> behaves exactly like
        <a href="#cs_call"><code>cs_call</code></a>.
        However, if there is any error,
        <a href="#cs_pcall"><code>cs_pcall</code></a> catches it, pushes a
        single value on the stack (the error object), and returns an error code.
        Like <a href="#cs_call"><code>cs_call</code></a>,
        <a href="#cs_pcall"><code>cs_pcall</code></a> always removes the
        function and its arguments from the stack.
        <br/><br/>
        If <code>absmsgh</code> is less than 0, then the error object returned
        on the stack is exactly the original error object.
        Otherwise, <code>absmsgh</code> is the absolute stack index of a
        <em>message handler</em>.
        (This index cannot be a pseudo-index.)
        In case of runtime errors, this handler will be called with the error
        object and its return value will be the object returned on the stack
        by <a href="#cs_pcall"><code>cs_pcall</code></a>.
        <br/><br/>
        Typically, the message handler is used to add more debug information
        to the error object, such as a stack traceback.
        Such information cannot be gathered after the return of
        <a href="#cs_pcall"><code>cs_pcall</code></a>, since by then the stack
        has unwound.
        <br/><br/>
        The <a href="#cs_pcall"><code>cs_pcall</code></a> function returns one
        of the following status codes:
        <a href="#CS_OK"><code>CS_OK</code></a>,
        <a href="#CS_ERRRUNTIME"><code>CS_ERRRUNTIME</code></a>,
        <a href="#CS_ERRMEM"><code>CS_ERRMEM</code></a> or
        <a href="#CS_ERRERROR"><code>CS_ERRERROR</code></a>.
        </p>

        <!-- cs_load -->
        <hr><h3><a name="cs_load"><code>cs_load</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_load (cs_State *C,
             cs_Reader reader,
             void *userdata,
             const char *chunkname);</pre>
        <p>
        Loads a CScript chunk without running it.
        If there are no errors, <code>cs_load</code> pushes the compiled chunk
        as a CScript function on top of the stack.
        Otherwise, it pushes an error message.
        <br/><br/>
        The <code>cs_load</code> function uses a user-supplied
        <code>reader</code> function to read the chunk
        (see <a href="#cs_Reader"><code>cs_Reader</code></a>).
        The <code>userdata</code> argument is an opaque value passed to the
        reader function.
        <br/><br/>
        The <code>chunkname</code> argument gives a name to the chunk, which
        is used for error messages and in debug information
        (see <a href="#4.7">&sect;4.7</a>).
        <br/><br/>
        <code>cs_load</code> uses the stack internally, so the reader function
        must always leave the stack unmodified when returning.
        <br/><br/>
        <code>cs_load</code> can return
        <a href="#CS_OK"><code>CS_OK</code></a>,
        <a href="#CS_ERRSYNTAX"><code>CS_ERRSYNTAX</code></a>, or
        <a href="#CS_ERRMEM"><code>CS_ERRMEM</code></a>.
        The function may also return other values corresponding to errors
        raised by the read function (see <a href="#4.4.1">&sect;4.4.1</a>).
        </p>

        <!-- cs_gc -->
        <hr><h3><a name="cs_gc"><code>cs_gc</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_gc (cs_State *C, int what, ...);</pre>
        <p>
        Controls the garbage collector.
        <br/><br/>
        This function performs several tasks, according to the value of the
        parameter <code>what</code>.
        For options that need extra arguments, they are listed after the
        option.
        <ul>
            <li>
                <b><code>CS_GCSTOP</code>: </b>
                Stops the garbage collector.
            </li>
            <li>
                <b><code>CS_GCRESTART</code>: </b>
                Restarts the garbage collector.
            </li>
            <li>
                <b><code>CS_GCCOLLECT</code>: </b>
                Performs a full garbage-collection cycle.
            </li>
            <li>
                <b><code>CS_GCCOUNT</code>: </b>
                Returns the current amount of memory (in Kbytes) in use by
                CScript.
            </li>
            <li>
                <b><code>CS_GCCOUNTBYTES</code>: </b>
                Returns the remainder of dividing the current amount of bytes
                of memory in use by CScript by 1024.
            </li>
            <li>
                <b><code>CS_GCSTEP</code> (int stepsize): </b>
                Performs an incremental step of garbage collection,
                corresponding to the allocation of <code>stepsize</code> Kbytes.
            </li>
            <li>
                <b><code>CS_GCISRUNNING</code>: </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
            <li>
                <b><code>CS_GCINC</code> (int pause, int stepmul, stepsize): </b>
                Changes the collector to incremental mode with the given
                parameters (see <a href="#2.5.1">&sect;2.5.1</a>).
                Returns the previous mode (which is always <code>CS_GCINC</code>).
            </li>
        </ul>
        For more details about these options,
        see <a href="#gc"><code>gc</code></a>.
        <br/><br/>
        This function should not be called by a finalizer.
        </p>

        <!-- cs_setwarnf -->
        <hr><h3><a name="cs_setwarnf"><code>cs_setwarnf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_setwarnf (cs_State *C, cs_WarnFunction fwarn, void *ud);</pre>
        <p>
        Sets the warning function to be used by CScript to emit warnings
        (see <a href="#cs_WarnFunction"><code>cs_WarnFunction</code></a>).
        The <code>ud</code> parameter sets the value <code>ud</code> passed to
        the warning function.
        </p>

        <!-- cs_warning -->
        <hr><h3><a name="cs_warning"><code>cs_warning</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_warning (cs_State *C, const char *msg, int cont);</pre>
        <p>
        Emits a warning with the given message.
        A message in a call with <code>tocont</code> true should be continued
        in another call to this function.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about warnings.
        </p>

        <!-- cs_hasvmt -->
        <hr><h3><a name="cs_hasvmt"><code>cs_hasvmt</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_hasvmt (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index has a
        <a href="#cs_VMT">vritual method table</a>, otherwise it returns 0.
        <br/>
        Note that this function would return 0 even for the types at the
        given index that usually have a
        <a href="#cs_VMT">virtual method table</a>;
        this is because the value might never have been assigned one.
        This function is useful as a quick test to see if the
        <a href="#cs_VMT">virtual method table</a> is present, otherwise use
        <a href="#cs_hasmetamethod"><code>cs_hasmetamethod</code></a> to check
        for presence of specific metamethod.
        </p>

        <!-- cs_hasmetamethod -->
        <hr><h3><a name="cs_hasmetamethod"><code>cs_hasmetamethod</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_hasmetamethod (cs_State *C, int index, cs_MM mm);</pre>
        <p>
        Returns 1 if value at the given index has a <code>mm</code> metamethod.
        Otherwise this returns 0 if the <code>mm</code> entry is <b>nil</b> or
        the value does not have a <a href="cs_VMT">virtual method table</a>.
        </p>

        <!-- cs_len -->
        <hr><h3><a name="cs_len"><code>cs_len</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Unsigned cs_len (cs_State *C, int index);</pre>
        <p>
        Returns the "length" of the value at the given index.
        For strings, this is the string length;
        for arrays, this is the array length;
        for tables, this is the number of non <b>nil</b> key values;
        for classes, this is the number of methods;
        for instances, this is the number of non <b>nil</b> fields;
        for userdata, this is the size of the block of memory allocated
        for the userdata.
        For other values, this call returns&nbsp;0.
        </p>

        <!-- cs_next -->
        <hr><h3><a name="cs_next"><code>cs_next</code></a></h3>
        <span class="apii">[-1, +(2|0), <em>v</em>]</span>
        <pre>int cs_next (cs_State *C, int index);</pre>
        <p>
        Pops a key from the stack, and pushes a key&ndash;value pair from the
        table or instance at the given index, the "next" pair
        after the given key.
        If there are no more elements in the table or no more fields in the
        instances, then <a href="#cs_next"><code>cs_next</code></a>
        returns&nbsp;0 and pushes nothing.
        <br/><br/>
        A typical table traversal looks like this:
        <pre>
    /* table is in the stack at index 't' */
    cs_push_nil(C);  /* first key */
    while (cs_next(C, t) != 0) {
        /* uses 'key' (at index -2) and 'value' (at index -1) */
        printf("%s - %s\n",
               cs_typename(C, cs_type(C, -2)),
               cs_typename(C, cs_type(C, -1)));
        /* removes 'value'; keeps 'key' for next iteration */
        cs_pop(C, 1);
    }</pre>
        This function may raise an error if the given key is neither
        <b>nil</b> nor present in the table or instance.
        See function <a href="#next"><code>next</code></a> for the caveats of
        modifying the table or instance fields during its traversal.
        </p>

        <!-- cs_concat -->
        <hr><h3><a name="cs_concat"><code>cs_concat</code></a></h3>
        <span class="apii">[-n, +1, <em>e</em>]</span>
        <pre>void cs_concat (cs_State *C,  int n);</pre>
        <p>
        Concatenates the <code>n</code> values at the top of the stack,
        pops them, and leaves the result on the top.
        If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on
        the stack (that is, the function does nothing);
        if <code>n</code> is 0, the result is the empty string.
        Concatenation is performed following the usual semantics of CScript
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        </p>

        <!-- cs_stringtonumber -->
        <hr><h3><a name="cs_stringtonumber"><code>cs_stringtonumber</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>size_t cs_stringtonumber (cs_State *C, const char *s, int *f);</pre>
        <p>
        Converts the zero-terminated string <code>s</code> to a number,
        pushes that number into the stack, and returns the total size of
        the string, that is, its length plus one.
        The conversion can result in an integer or a float,
        according to the lexical conventions of CScript
        (see <a href="#3.1">&sect;3.1</a>).
        The string may have leading and trailing whitespaces and a sign.
        If the string is not a valid numeral, returns 0 and pushes nothing.
        (Note that the result can be used as a boolean, true if the conversion
        succeeds.)
        If <code>f</code> is provided then it will be set to -1 in case the
        underflow occurred, 1 if overflow occurred or 0 if conversion
        was performed without underflow and overflow occurring.
        </p>

        <!-- cs_getallocf -->
        <hr><h3><a name="cs_getallocf"><code>cs_getallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Alloc cs_getallocf (cs_State *C, void **ud);</pre>
        <p>
        Returns the memory-allocation function of a given state.
        If <code>ud</code> is not <code>NULL</code>, CScript stores in
        <code>*ud</code> the opaque pointer given when the memory-allocator
        function was set.
        </p>

        <!-- cs_setallocf -->
        <hr><h3><a name="cs_setallocf"><code>cs_setallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void cs_setallocf (cs_State *C, cs_Alloc f, void *ud);</pre>
        <p>
        Changes the allocator function of a given state to <code>f</code>
        with user data <code>ud</code>.
        </p>

        <!-- cs_toclose -->
        <hr><h3><a name="cs_toclose"><code>cs_toclose</code></a></h3>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void cs_toclose (cs_State *C, int index);</pre>
        <p>
        Marks the given index in the stack as a to-be-closed slot
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        Like a to-be-closed variable in CScript, the value at that slot in
        the stack will be closed when it goes out of scope.
        Here, in the context of a C function, to go out of scope means that
        the running function returns to CScript, or there is an error,
        or the slot is removed from the stack through
        <a href="#cs_setntop"><code>cs_setntop</code></a> or
        <a href="#cs_pop"><code>cs_pop</code></a>,
        or there is a call to
        <a href="#cs_closeslot"><code>cs_closeslot</code></a>.
        A slot marked as to-be-closed should not be removed from the stack
        by any other function in the API except
        <a href="#cs_setntop"><code>cs_setntop</code></a> or
        <a href="#cs_pop"><code>cs_pop</code></a>,
        unless previously deactivated by
        <a href="#cs_closeslot"><code>cs_closeslot</code></a>.
        <br/><br/>
        This function raises an error if the value at the given slot
        neither has a <code>__close</code> metamethod nor is a false value.
        <br/><br/>
        This function should not be called for an index that is equal to
        or below an active to-be-closed slot.
        <br/><br/>
        Note that, both in case of errors and of a regular return,
        by the time the <code>__close</code> metamethod runs,
        the C&nbsp;stack was already unwound, so that any automatic
        C&nbsp;variable declared in the calling function
        (e.g., a buffer) will be out of scope.
        </p>

        <!-- cs_closeslot -->
        <hr><h3><a name="cs_closeslot"><code>cs_closeslot</code></a></h3>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>void cs_closeslot (cs_State *C, int index);</pre>
        <p>
        Close the to-be-closed slot at the given index and set its value to
        <b>nil</b>.
        The index must be the last index previously marked to be closed
        (see <a href="#cs_toclose"><code>cs_toclose</code></a>) that is still
        active (that is, not closed yet).
        </p>

        <!-- cs_getextraspace -->
        <hr><h3><a name="cs_getextraspace"><code>cs_getextraspace</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *cs_getextraspace (cs_State *C);</pre>
        <p>
        Returns a pointer to a raw memory area associated with the
        given CScript state.
        The application can use this area for any purpose;
        CScript does not use it for anything.
        <br/><br/>
        Each new thread has this area initialized with a copy of the area
        of the main thread.
        <br/><br/>
        By default, this area has the size of a pointer to void, but you can
        recompile CScript with a different size for this area.
        (See <code>CS_EXTRASPACE</code> in <code>csconf.h</code>.)
        </p>

        <!-- cs_nvalues -->
        <hr><h3><a name="cs_nvalues"><code>cs_nvalues</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_nvalues (cs_State *C);</pre>
        <p>
        Similar to <a href="#cs_gettop"><code>cs_gettop</code></a> except
        this returns the actual number of the values on the stack.
        So the return value of 0 means an empty stack.
        (This is equivalent to
        <a href="#cs_gettop"><code>cs_gettop</code></a><code>&nbsp;+&nbsp;1</code>.)
        </p>

        <!-- cs_to_number -->
        <hr><h3><a name="cs_to_number"><code>cs_to_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Number cs_to_number (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_numberx"><code>cs_to_numberx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_to_integer -->
        <hr><h3><a name="cs_to_integer"><code>cs_to_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer cs_to_integer (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_integerx"><code>cs_to_integerx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_pop -->
        <hr><h3><a name="cs_pop"><code>cs_pop</code></a></h3>
        <span class="apii">[-n, +0, &ndash;]</span>
        <pre>void cs_pop (cs_State *C, int n);</pre>
        <p>
        Pops <code>n</code> elements from the stack.
        It is implemented as a macro over
        <a href="#cs_setntop"><code>cs_setntop</code></a>.
        </p>

        <!-- cs_push_cfunction -->
        <hr><h3><a name="cs_push_cfunction"><code>cs_push_cfunction</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_cfunction (cs_State *C, cs_CFunction f);</pre>
        <p>
        Pushes a C&nbsp;function onto the stack.
        This function is equivalent to
        <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a> with
        no upvalues.
        </p>

        <!-- cs_register -->
        <hr><h3><a name="cs_register"><code>cs_register</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void cs_register (cs_State *C, const char *name, cs_CFunction f);</pre>
        <p>
        Sets the C&nbsp;function <code>f</code> as the new value of global
        <code>name</code>.
        It is defined as a macro:
        <pre>
    #define cs_register(C,n,f) \
            (cs_push_cfunction(C, f), cs_set_global(C, n))</pre>
        </p>

        <!-- cs_is_cfunction -->
        <hr><h3><a name="cs_is_cfunction"><code>cs_is_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_cfunction (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a C&nbsp;function,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_array -->
        <hr><h3><a name="cs_is_array"><code>cs_is_array</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_array (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is the array,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_table -->
        <hr><h3><a name="cs_is_table"><code>cs_is_table</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_table (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a table,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_class -->
        <hr><h3><a name="cs_is_class"><code>cs_is_class</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_class (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a class,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_instance -->
        <hr><h3><a name="cs_is_instance"><code>cs_is_instance</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_instance (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a instance,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_lightuserdata -->
        <hr><h3><a name="cs_is_lightuserdata"><code>cs_is_lightuserdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_lightuserdata (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a light userdata,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_nil -->
        <hr><h3><a name="cs_is_nil"><code>cs_is_nil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_nil (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is <b>nil</b>,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_boolean -->
        <hr><h3><a name="cs_is_bool"><code>cs_is_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_bool (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a boolean,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_thread -->
        <hr><h3><a name="cs_is_thread"><code>cs_is_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_thread (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the value at the given index is a thread,
        and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_none -->
        <hr><h3><a name="cs_is_none"><code>cs_is_none</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_none (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the given index is not valid, and 0&nbsp;otherwise.
        </p>

        <!-- cs_is_noneornil -->
        <hr><h3><a name="cs_is_noneornil"><code>cs_is_noneornil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_is_noneornil (cs_State *C, int index);</pre>
        <p>
        Returns 1 if the given index is not valid or if the value at this
        index is <b>nil</b>, and 0&nbsp;otherwise.
        </p>

        <!-- cs_push_literal -->
        <hr><h3><a name="cs_push_literal"><code>cs_push_literal</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>const char *cs_push_literal (cs_State *C, const char *s);</pre>
        <p>
        This macro is equivalent to
        <a href="#cs_push_string"><code>cs_push_string</code></a>, but should
        be used only when <code>s</code> is a literal string.
        (CScript may optimize this case.)
        </p>

        <!-- cs_push_globaltable -->
        <hr><h3><a name="cs_push_globaltable"><code>cs_push_globaltable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void cs_push_globaltable (cs_State *C);</pre>
        <p>
        Pushes the global table onto the stack.
        </p>

        <!-- cs_to_string -->
        <hr><h3><a name="cs_to_string"><code>cs_to_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *cs_to_string (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_to_lstring"><code>cs_to_lstring</code></a>
        with <code>len</code> equal to <code>NULL</code>.
        </p>

        <!-- cs_insert -->
        <hr><h3><a name="cs_insert"><code>cs_insert</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>void cs_insert (cs_State *C, int index);</pre>
        <p>
        Moves the top element into the given valid index, shifting up the
        elements above this index to open space.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_remove -->
        <hr><h3><a name="cs_remove"><code>cs_remove</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_remove (cs_State *C, int index);</pre>
        <p>
        Removes the element at the given valid index, shifting down the
        elements above this index to fill the gap.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- cs_replace -->
        <hr><h3><a name="cs_replace"><code>cs_replace</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void cs_replace (cs_State *C, int index);</pre>
        <p>
        Moves the top element into the given valid index without shifting any
        element (therefore replacing the value at that given index), and then
        pops the top element.
        </p>

        <!-- cs_getstack -->
        <hr><h3><a name="cs_getstack"><code>cs_getstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int cs_getstack (cs_State *C, int level, cs_Debug *ar);</pre>
        <p>
        Gets information about the interpreter runtime stack.
        <br/><br/>
        This function fills parts of a
        <a href="#cs_Debug"><code>cs_Debug</code></a> structure with an
        identification of the <em>activation record</em> of the function
        executing at a given level.
        Level&nbsp;0 is the current running function, whereas level
        <em>n+1</em> is the function that has called level <em>n</em>.
        When called with a level greater than the stack depth,
        <a href="#cs_getstack"><code>cs_getstack</code></a> returns 0;
        otherwise it returns 1.
        </p>

        <!-- cs_getinfo -->
        <hr><h3><a name="cs_getinfo"><code>cs_getinfo</code></a></h3>
        <span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
        <pre>int cs_getinfo (cs_State *C, const char *what, cs_Debug *ar);</pre>
        <p>
        Gets information about a specific function or function invocation.
        <br/><br/>
        To get information about a function invocation, the parameter
        <code>ar</code> must be a valid activation record that was filled by
        a previous call to <a href="#cs_getstack"><code>cs_getstack</code></a>.
        <br/><br/>
        To get information about a function, you push it onto the stack and
        start the <code>what</code> string with the character
        '<code>&gt;</code>'.
        (In that case, <code>cs_getinfo</code> pops the function from the top
        of the stack.)
        For instance, to know in which line a function <code>f</code> was defined,
        you can write the following code:
        <pre>
    cs_Debug ar;
    cs_get_global(C, "f");  /* get global 'f' */
    cs_getinfo(C, "&gt;s", &amp;ar);
    printf("%d\n", ar.defline);</pre>
        Each character in the string <code>what</code> selects some fields of
        the structure <code>ar</code> to be filled or a value to be pushed on
        the stack.
        (These characters are also documented in the declaration of the
        structure <a href="#cs_Debug"><code>cs_Debug</code></a>, between
        parentheses in the comments following each field.)
        <ul>
            <li>
                <b>'<code>f</code>': </b>
                pushes onto the stack the function that is running at the
                given level;
            </li>
            <li>
                <b>'<code>l</code>': </b>
                fills in the field <code>currline</code>;
            </li>
            <li>
                <b>'<code>n</code>': </b>
                fills in the fields <code>name</code> and
                <code>namewhat</code>;
            </li>
            <li>
                <b>'<code>s</code>': </b>
                fills in the fields <code>source</code>,
                <code>shortsrc</code>, <code>defline</code>,
                <code>lastdefline</code> and <code>what</code>;
            </li>
            <li>
                <b>'<code>u</code>': </b>
                fills in the fields <code>nupvals</code>, <code>nparams</code>
                and <code>isvararg</code>;
            </li>
        </ul>
        This function returns 0 to signal an invalid option in
        <code>what</code>; even then the valid options are handled correctly.
        </p>

        <!-- cs_getlocal -->
        <hr><h3><a name="cs_getlocal"><code>cs_getlocal</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *cs_getlocal (cs_State *C, const cs_Debug *ar, int n);</pre>
        <p>
        Gets information about a local variable or a temporary value of a
        given activation record or a given function.
        <br/><br/>
        In the first case, the parameter <code>ar</code> must be a valid
        activation record that was filled by a previous call to
        <a href="#cs_getstack"><code>cs_getstack</code></a>.
        The index <code>n</code> selects which local variable to inspect.
        <br/><br/>
        <a href="#cs_getlocal"><code>cs_getlocal</code></a> pushes the
        variable's value onto the stack and returns its name.
        <br/><br/>
        In the second case, <code>ar</code> must be <code>NULL</code> and the
        function to be inspected must be on the top of the stack.
        In this case, only parameters of CScript functions are visible
        (as there is no information about what variables are active)
        and no values are pushed onto the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pushes nothing) when the index is
        greater than the number of active local variables.
        </p>

        <!-- cs_setlocal -->
        <hr><h3><a name="cs_setlocal"><code>cs_setlocal</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *cs_setlocal (cs_State *C, const cs_Debug *ar, int n);</pre>
        <p>
        Sets the value of a local variable of a given activation record.
        It assigns the value on the top of the stack to the variable and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index is
        greater than the number of active local variables.
        <br/><br/>
        Parameters <code>ar</code> and <code>n</code> are as in the function
        <a href="#cs_getlocal"><code>cs_getlocal</code></a>.
        </p>

        <!-- cs_getupvalue -->
        <hr><h3><a name="cs_getupvalue"><code>cs_getupvalue</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *cs_getupvalue (cs_State *C, int index, int n);</pre>
        <p>
        Gets information about the <code>n</code>-th upvalue of the closure
        at the given index.
        It pushes the upvalue's value onto the stack and returns its name.
        Returns <code>NULL</code> (and pushes nothing) when the index
        <code>n</code> is greater than the number of upvalues.
        </p>

        <!-- cs_setupvalue -->
        <hr><h3><a name="cs_setupvalue"><code>cs_setupvalue</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *cs_setupvalue (cs_State *C, int index, int n);</pre>
        <p>
        Sets the value of a closure's upvalue.
        It assigns the value on the top of the stack to the upvalue and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index
        <code>n</code> is greater than the number of upvalues.
        <br/><br/>
        Parameters <code>funcindex</code> and <code>n</code> are as in
        the function <a href="#cs_getupvalue"><code>cs_getupvalue</code></a>.
        </p>




        <h1>5 &ndash; <a name="5">The Auxiliary Library</h1>
        <p>
        The <em>auxiliary library</em> provides several convenient functions
        to interface C with CScript.
        While the basic API provides the primitive functions for all
        interactions between C and CScript, the auxiliary library provides
        higher-level functions for some common tasks.
        <br/><br/>
        All functions and types from the auxiliary library are defined in
        header file <code>cauxlib.h</code> and have a prefix <code>csL_</code>.
        <br/><br/>
        All functions in the auxiliary library are built on top of the basic
        API, and so they provide nothing that cannot be done with that API.
        Nevertheless, the use of the auxiliary library ensures more
        consistency to your code.
        <br/><br/>
        Several functions in the auxiliary library use internally some
        extra stack slots.
        When a function in the auxiliary library uses less than five slots,
        it does not check the stack size; it simply assumes that there are
        enough slots.
        <br/><br/>
        Several functions in the auxiliary library are used to check
        C&nbsp;function arguments.
        Because the error message is formatted for arguments
        (e.g., "<code>bad argument #1</code>"), you should not use these
        functions for other stack values.
        <br/><br/>
        Functions called <code>csL_check*</code> always raise an error if
        the check is not satisfied.
        </p>


        <h2>5.1 &ndash; <a name="5.1">Functions and Types</a></h2>
        <p>Here we list all functions and types from the auxiliary library:</p>

        <hr><h3><a name="csL_error"><code>csL_error</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error (cs_State *C, const char *fmt, ...);</pre>
        <p>
        Raises an error.
        The error message format is given by <code>fmt</code> plus any extra
        arguments, following the same rules of
        <a href="#cs_push_fstring"><code>cs_push_fstring</code></a>.
        It also adds at the beginning of the message the file name and
        the line number where the error occurred, if this information is
        available.
        <br/><br/>
        This function never returns, but it is an idiom to use it in
        C&nbsp;functions as <code>return csL_error(<em>args</em>)</code>.
        </p>

        <hr><h3><a name="csL_error_arg"><code>csL_error_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error_arg (cs_State *C, int arg, const char *extra);</pre>
        <p>
        Raises an error reporting a problem with argument <code>arg</code>
        of the C&nbsp;function that called it, using a standard message
        that includes <code>extra</code> as a comment:
        <pre>
    bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extra</em>)</pre>
        This function never returns.
        </p>

        <hr><h3><a name="csL_error_type"><code>csL_error_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int csL_error_type (cs_State *C, int arg, const char *tname);</pre>
        <p>
        Raises a type error for the argument <code>arg</code> of the
        C&nbsp;function that called it, using a standard message;
        <code>tname</code> is a "name" for the expected type.
        This function never returns.
        </p>

        <hr><h3><a name="csL_check_number"><code>csL_check_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Number csL_check_number (cs_State *C, int arg);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a number
        and returns this number converted to a <code>cs_Number</code>.
        </p>

        <hr><h3><a name="csL_check_integer"><code>csL_check_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Integer csL_check_integer (cs_State *C);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is an integer
        and returns this integer.
        </p>

        <hr><h3><a name="csL_check_lstring"><code>csL_check_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_check_lstring (cs_State *C, int arg, size_t *l);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a string
        and returns this string;
        if <code>l</code> is not <code>NULL</code> fills its referent
        with the string's length.
        <br/><br/>
        This function uses
        <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_check_type"><code>csL_check_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_type (cs_State *C, int arg, int t);</pre>
        <p>
        Checks whether the function argument <code>arg</code> has type
        <code>t</code>.
        See <a href="#cs_type"><code>cs_type</code></a> for the encoding of
        types for <code>t</code>.
        </p>

        <hr><h3><a name="csL_check_any"><code>csL_check_any</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_any (cs_State *C, int arg);</pre>
        <p>
        Checks whether the function has an argument of any type
        (including <b>nil</b>) at position <code>arg</code>.
        </p>

        <hr><h3><a name="csL_check_stack"><code>csL_check_stack</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_stack (cs_State *C, int sz, const char *msg);</pre>
        <p>
        Grows the stack size to <code>top + sz</code> elements,
        raising an error if the stack cannot grow to that size.
        <code>msg</code> is an additional text to go into the error message
        (or <code>NULL</code> for no additional text).
        </p>

        <hr><h3><a name="csL_check_userdata"><code>csL_check_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_userdata (cs_State *C, int arg, const char *tname);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a userdata
        of the type <code>tname</code> and returns the userdata's memory-block
        address (see <a href="#cs_to_userdata"><code>cs_to_userdata</code></a>).
        </p>

        <hr><h3><a name="csL_check_option"><code>csL_check_option</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_option (cs_State *C
                       int arg,
                       const char *dfl,
                       const char *const opts[]);</pre>
        <p>
        Checks whether the function argument <code>arg</code> is a string and
        searches for this string in the array <code>opts</code>
        (which must be NULL-terminated).
        Returns the index in the array where the string was found.
        Raises an error if the argument is not a string or if the string
        cannot be found.
        <br/><br/>
        If <code>dfl</code> is not <code>NULL</code>, the function uses
        <code>dfl</code> as a default value when there is no argument
        <code>arg</code> or when this argument is <b>nil</b>.
        <br/><br/>
        This is a useful function for mapping strings to C&nbsp;enums.
        (The usual convention in CScript libraries is to use strings instead of
        numbers to select options.)
        </p>

        <hr><h3><a name="csL_opt_number"><code>csL_opt_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Number csL_opt_number (cs_State *C, int arg, cs_Number dfl);</pre>
        <p>
        If the function argument <code>arg</code> is a number, returns this
        number as a <code>cs_Number</code>.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt_integer"><code>csL_opt_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>cs_Integer csL_opt_integer (cs_State *C, int arg, cs_Integer dfl);</pre>
        <p>
        If the function argument <code>arg</code> is an integer, returns this
        integer.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt_lstring"><code>csL_opt_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_opt_lstring (cs_State *C,
                             int arg,
                             const char *dfl,
                             size_t *l);</pre>
        <p>
        If the function argument <code>arg</code> is a string, returns this
        string.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        <br/><br/>
        If <code>l</code> is not <code>NULL</code>, fills its referent with
        the result's length.
        If the result is <code>NULL</code> (only possible when returning
        <code>dfl</code> and <code>dfl == NULL</code>), its length is
        considered zero.
        <br/><br/>
        This function uses
        <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_loadfile"><code>csL_loadfile</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int csL_loadfile (cs_State *C, const char *filename);</pre>
        <p>
        Loads a file as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to
        load the chunk in the file named <code>filename</code>.
        If <code>filename</code> is <code>NULL</code>, then it loads from
        the standard input.
        <br/><br/>
        This function returns the same results as
        <a href="#cs_load"><code>cs_load</code></a> or
        <a href="#CS_ERRFILE"><code>CS_ERRFILE</code></a> for file-related
        errors.
        <br/><br/>
        As <a href="#cs_load"><code>cs_load</code></a>, this function only
        loads the chunk; it does not run it.
        </p>

        <hr><h3><a name="csL_loadstring"><code>csL_loadstring</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_loadstring (cs_State *C, const char *s);</pre>
        <p>
        Loads a string as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to
        load the chunk in the zero-terminated string <code>s</code>.
        </p>

        <hr><h3><a name="csL_loadbuffer"><code>csL_loadbuffer</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_loadbuffer (cs_State *C,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>
        <p>
        Loads a buffer as a CScript chunk.
        This function uses <a href="#cs_load"><code>cs_load</code></a> to load
        the chunk in the buffer pointed to by <code>buff</code> with size
        <code>sz</code>.
        <br/><br/>
        This function returns the same results as
        <a href="#cs_load"><code>cs_load</code></a>.
        <code>name</code> is the chunk name, used for debug information and
        error messages.
        </p>

        <hr><h3><a name="csL_to_lstring"><code>csL_to_lstring</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_to_lstring (cs_State *C, int index, size_t *len);</pre>
        <p>
        Converts any CScript value at the given index to a C&nbsp;string
        in a reasonable format.
        The resulting string is pushed onto the stack and also
        returned by the function (see <a href="#4.1.3">&sect;4.1.3</a>).
        If <code>len</code> is not <code>NULL</code>, the function also sets
        <code>*len</code> with the string length.
        </p>

        <hr><h3><a name="csL_where"><code>csL_where</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_where (cs_State *C, int level);</pre>
        <p>
        Pushes onto the stack a string identifying the current position
        of the control at level <code>lvl</code> in the call stack.
        Typically this string has the following format:
        <pre>
    <em>chunkname</em>:<em>currentline</em>:</pre>
        Level&nbsp;0 is the running function, level&nbsp;1 is the function
        that called the running function, etc.
        <br/><br/>
        This function is used to build a prefix for error messages.
        </p>

        <hr><h3><a name="csL_fileresult"><code>csL_fileresult</code></a></h3><p>
        <span class="apii">[-0, +(1|3), <em>m</em>]</span>
        <pre>void csL_fileresult (cs_State *C, int ok, const char *fname);</pre>
        <p>
        This function produces the return values for file-related functions
        in the standard library.
        </p>

        <hr><h3><a name="csL_get_property"><code>csL_get_property</code></a></h3><p>
        <span class="apii">[-1, +1, <em>m</em>]</span>
        <pre>int csL_get_property (cs_State *C, int index);</pre>
        <p>
        Equivalent to <a href="#cs_get_field"><code>cs_get_field</code></a>
        except if the field is <b>nil</b> then it will try and get the method
        under the same key
        (via <a href="#cs_get_class"><code>cs_get_class</code></a>
        and <a href="#cs_get_method"><code>cs_get_method</code></a>).
        <br/><br/>
        This function returns the type of the field or method (aka property),
        and replaces the key on top of the stack with the value of the
        property.
        <br/>
        (Note that if the function returned
        <a href="#CS_TNIL"><code>CS_TNIL</code></a>, it means that both the
        field and method are <b>nil</b>).
        </p>

        <hr><h3><a name="csL_set_index"><code>csL_set_index</code></a></h3><p>
        <span class="apii">[-1, +0, <em>v</em>]</span>
        <pre>void csL_set_index (cs_State *C, int index, cs_Integer i);</pre>
        <p>
        Equivalent to <a href="#cs_set_index"><code>cs_set_index</code></a>
        but this invokes error if the index <code>i</code> is negative.
        </p>

        <hr><h3><a name="csL_newstate"><code>csL_newstate</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_State *csL_newstate (void);</pre>
        <p>
        Creates a new CScript state.
        It calls <a href="#cs_newstate"><code>cs_newstate</code></a> with an
        allocator based on the ISO&nbsp;C allocation functions and then
        sets a warning function and a panic function
        (see <a href="#4.4">&sect;4.4</a>) that print messages to standard
        error output.
        <br/><br/>
        Returns the new state or <code>NULL</code> if there is a memory
        allocation error.
        </p>

        <hr><h3><a name="csL_get_subtable"><code>csL_get_subtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>int csL_get_subfield (cs_State *C, int index, const char *field);</pre>
        <p>
        Ensures that the value <code>obj[field]</code>, where <code>obj</code>
        is the value at the given index, is a table, and pushes that table
        onto the stack.
        Returns true if it finds a previous table there and false if it
        creates a new table.
        </p>

        <hr><h3><a name="csL_include"><code>csL_include</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void csL_includef (cs_State *C, const char *modname,
                   cs_CFunction openf, int global);</pre>
        <p>
        If <code>package.loaded[modname]</code> is not true,
        calls the function <code>openf</code> with the string
        <code>modname</code> as an argument and sets the call result to
        <code>package.loaded[modname]</code>, as if that function has been
        called through <a href="#include"><code>include</code></a>.
        <br/><br/>
        If <code>global</code> is true, also stores the module into the
        global <code>modname</code>.
        <br/><br/>
        Leaves a copy of the module on the stack.
        </p>

        <hr><h3><a name="csL_test_userdata"><code>csL_test_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void csL_test_userdata (cs_State *C, int index, const char *name);</pre>
        <p>
        This function works like
        <a href="#csL_check_userdata"><code>csL_checkuserdata</code></a>,
        except that, when the test fails, it returns <code>NULL</code>
        instead of raising an error.
        </p>

        <hr><h3><a name="csL_traceback"><code>csL_traceback</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_traceback (cs_State *C, cs_State *C1,
                    int level, const char *msg);</pre>
        <p>
        Creates and pushes a traceback of the stack <code>C1</code>.
        If <code>msg</code> is not <code>NULL</code>, it is appended
        at the beginning of the traceback.
        The <code>level</code> parameter tells at which level to start the
        traceback.
        </p>

        <hr><h3><a name="csL_setfuncs"><code>csL_setfuncs</code></a></h3><p>
        <span class="apii">[-nup, +0, <em>m</em>]</span>
        <pre>void csL_setfuncs (cs_State *C, const cs_Entry *l, int nup);</pre>
        <p>
        Registers all functions in the array <code>l</code>
        (see <a href="#cs_Entry"><code>cs_Entry</code></a>) into the table or
        instance on the top of the stack (below optional upvalues, see next).
        <br/><br/>
        When <code>nup</code> is not zero, all functions are created with
        <code>nup</code> upvalues, initialized with copies of the
        <code>nup</code> values previously pushed on the stack on top of
        the table or instance.
        These values are popped from the stack after the registration.
        <br/><br/>
        A function with a <code>NULL</code> value represents a placeholder,
        which is filled with <b>false</b>.
        </p>

        <hr><h3><a name="csL_gsub"><code>csL_gsub</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_gsub (cs_State *C, const char *s,
               const char *p, const char *r);</pre>
        <p>
        Creates a copy of string <code>s</code>, replacing any occurrence of
        the string <code>p</code> with the string <code>r</code>.
        Pushes the resulting string on the stack and returns it.
        Think of it as string substitution <code>s/{p}/{r}/g</code>, the input
        being the function argument <code>s</code>.
        </p>

        <hr><h3><a name="csL_ref"><code>csL_ref</code></a></h3><p>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void csL_ref (cs_State *C, int a);</pre>
        <p>
        Creates and returns a <em>reference</em>, in the array at index
        <code>a</code>, for the object on the top of the stack
        (and pops the object).
        <br/><br/>
        A reference is a unique integer index into that array.
        As long as you do not manually add entries into the array
        <code>a</code>, <a href="#csL_ref"><code>csL_ref</code></a> ensures
        the uniqueness of the index it returns.
        You can retrieve an object referred by the reference <code>r</code>
        by calling <code>cs_get_index(C, a, r)</code>.
        The function <a href="#csL_unref"><code>csL_unref</code></a> frees
        a reference.
        <br/><br/>
        If the object on the top of the stack is <b>nil</b>,
        <a href="#csL_ref"><code>csL_ref</code></a> returns the constant
        <a name="CS_REFNIL"><code>CS_REFNIL</code></a>.
        The constant <a name="CS_NOREF"><code>CS_NOREF</code></a> is
        guaranteed to be different from any reference returned by
        <a href="#csL_ref"><code>csL_ref</code></a>.
        </p>

        <hr><h3><a name="csL_unref"><code>csL_unref</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void csL_unref (cs_State *C, int a, int ref);</pre>
        <p>
        Releases the reference <code>ref</code> from the array at index
        <code>a</code> (see <a href="#csL_ref"><code>csL_ref</code></a>).
        The entry is removed from the array, so that the referred object
        can be collected.
        The reference <code>ref</code> is also freed to be used again.
        <br/><br/>
        If <code>ref</code> is <a href="#CS_NOREF"><code>CS_NOREF</code></a>
        or <a href="#CS_REFNIL"><code>CS_REFNIL</code></a>,
        <a href="#csL_unref"><code>csL_unref</code></a> does nothing.
        </p>

        <hr><h3><a name="csL_checkversion"><code>csL_checkversion</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_checkversion (cs_State *C);</pre>
        <p>
        Checks whether the code making the call and the CScript library being
        called are using the same version of CScript.
        </p>

        <hr><h3><a name="csL_typename"><code>csL_typename</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *csL_typename (cs_State *C, int index);</pre>
        <p>
        Returns the name of the type of the value at the given index.
        </p>

        <hr><h3><a name="csL_check_string"><code>csL_check_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *csL_check_string (cs_State *C, int index);</pre>
        <p>
        Checks whether the function argument <code>index</code> is a string
        and returns this string.
        <br/><br/>
        This function uses <a href="#cs_to_lstring"><code>cs_to_lstring</code></a> to get its result,
        so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="csL_opt_string"><code>csL_opt_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_opt_string (cs_State *C, int index, const char *dflt);</pre>
        <p>
        If the function argument <code>index</code> is a string, returns
        this string.
        If this argument is absent or is <b>nil</b>, returns <code>dflt</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="csL_opt"><code>csL_opt</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>T csL_opt (C, func, index, dflt);</pre>
        <p>
        This macro is defined as follows:
        <pre>
    (cs_is_noneornil(C, index) ? (dfl) : fn(C, index))</pre>
        In words, if the argument <code>index</code> is <b>nil</b> or absent,
        the macro results in the default <code>dflt</code>.
        Otherwise, it results in the result of calling <code>func</code>
        with the state <code>C</code> and the argument index <code>index</code>
        as arguments.
        Note that it evaluates the expression <code>dflt</code> only if
        needed.
        </p>

        <hr><h3><a name="csL_check_arg"><code>csL_check_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_check_arg (cs_State *C,
                    int cond,
                    int index,
                    const char *extramsg);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error with a standard message
        (see <a href="#csL_error_arg"><code>csL_error_arg</code></a>).
        </p>

        <hr><h3><a name="csL_expect_arg"><code>csL_expect_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void csL_expect_arg (cs_State *C
                    int cond,
                    int index,
                    const char *tname);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error about the type of the argument
        at <code>index</code> with a standard message
        (see <a href="#csL_error_type"><code>csL_error_type</code></a>).
        </p>

        <hr><h3><a name="csL_push_fail"><code>csL_push_fail</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void csL_push_fail (cs_State *C);</pre>
        <p>
        Pushes the <b>fail</b> value onto the stack
        (see <a href="#6">&sect;6</a>).
        </p>

        <hr><h3><a name="csL_newlibtable"><code>csL_newlibtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_newlibtable (cs_State *C, const cs_Entry l[]);</pre>
        <p>
        Creates a new table with a size optimized to store all entries in
        the array <code>l</code> (but does not actually store them).
        It is intended to be used in conjunction with
        <a href="#csL_setfuncs"><code>csL_setfuncs</code></a>
        (see <a href="#csL_newlib"><code>csL_newlib</code></a>).
        <br/><br/>
        It is implemented as a macro.
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="csL_newlib"><code>csL_newlib</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_newlib (cs_State *C, const cs_Entry l[]);</pre>
        <p>
        Creates a new table and registers there
        the functions in the list <code>l</code>.
        <br/><br/>
        It is implemented as the following macro:
        <pre>
    (csL_newlibtable(C,l), csL_setfuncs(C,l,0))</pre>
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="csL_get_gsubtable"><code>csL_get_gsubtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void csL_get_gsubtable (cs_State *C, const char *name);</pre>
        <p>
        Equivalent to
        <a href="#csL_get_subtable"><code>csL_get_subtable</code></a>, except
        here the object being indexed is the global table which is pushed
        on top of the stack, and later removed after the operation.
        </p>

        <hr><h3><a name="csL_intop"><code>csL_intop</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>cs_Integer csL_intop (op, x, y);</pre>
        <p>
        Perform arithmetic operation <code>op</code> on
        <a href="#cs_Integer"><code>cs_Integer</code></a> values
        <code>x</code> and <code>y</code> with wrap-around semantics,
        as the CScript core does.
        <br/><br/>
        This is implemented as the following macro:
        <pre>
    ((cs_Integer)((cs_Unsigned)(x) op (cs_Unsigned)(y)))</pre>
        </p>

        <hr><h3><a name="csL_Buffer"><code>csL_Buffer</code></a></h3><p>
        <pre>typedef struct csL_Buffer csL_Buffer;</pre>
        <p>
        Type for a <em>string buffer</em>.
        <br/><br/>
        A string buffer allows C&nbsp;code to build CScript strings piecemeal.
        Its pattern of use is as follows:
        <ul>
            <li>
                First declare a variable <code>b</code> of type
                <a href="#csL_Buffer"><code>csL_Buffer</code></a>.
            </li>
            <li>
                Then initialize it with a call
                <code>csL_buff_init(C, &amp;b)</code>.
            </li>
            <li>
                Then add string pieces to the buffer calling any of
                the <code>csL_buff_push*</code> functions.
            </li>
            <li>
                Finish by calling <code>csL_buff_end(&amp;b)</code>.
                This call leaves the final string on the top of the stack.
            </li>
        </ul>
        If you know beforehand the maximum size of the resulting string,
        you can initialize the buffer by preallocate the its size with
        <a href="#csL_buff_initsz"><code>csL_buff_initsz</code></a>.
        <br/><br/>
        During its normal operation, a string buffer uses a variable number
        of stack slots.
        So, while using a buffer, you cannot assume that you know where
        the top of the stack is.
        You can use the stack between successive calls to buffer operations
        as long as that use is balanced;
        that is, when you call a buffer operation, the stack is at the same
        level it was immediately after the previous buffer operation.
        (The only exception to this rule is
        <a href="#csL_buff_push_stack"><code>csL_buff_push_stack</code></a>.)
        After calling <a href="#csL_buff_end"><code>csL_buff_end</code></a>,
        the stack is back to its level when the buffer was initialized,
        plus the final string on its top.
        </p>

        <hr><h3><a name="csL_buffptr"><code>csL_buffptr</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>char *csL_buffptr (csL_Buffer *B);</pre>
        <p>
        Returns the address of the current content of buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        Note that any addition to the buffer may invalidate this address.
        </p>

        <hr><h3><a name="csL_bufflen"><code>csL_bufflen</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>size_t csL_bufflen (csL_Buffer *B);</pre>
        <p>
        Returns the length of the current content of buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buffadd"><code>csL_buffadd</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void csL_buffadd (csL_Buffer *B, size_t n);</pre>
        <p>
        Adds to the buffer <code>B</code> a string of length <code>n</code>
        previously copied to the buffer area
        (see <a href="#csL_buff_initsz"><code>csL_buff_initsz</code></a>).
        </p>

        <hr><h3><a name="csL_buffsub"><code>csL_buffsub</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void csL_buffsub (csL_Buffer *B, int n);</pre>
        <p>
        Removes <code>n</code> bytes from the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        The buffer must have at least that many bytes.
        </p>

        <hr><h3><a name="csL_buff_push"><code>csL_buff_push</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push (csL_Buffer *B, char c);</pre>
        <p>
        Adds the byte <code>c</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buff_init"><code>csL_buff_init</code></a></h3><p>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>void csL_buff_init (cs_State *C, csL_Buffer *B);</pre>
        <p>
        Initializes a buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        This function does not allocate any space;
        the buffer must be declared as a variable.
        </p>

        <hr><h3><a name="csL_buff_initsz"><code>csL_buff_initsz</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *csL_buff_initsz (cs_State *C, csL_Buffer *B, size_t sz);</pre>
        <p>
        Equivalent to the sequence
        <a href="#csL_buff_init"><code>csL_buff_init</code></a>,
        <a href="#csL_buff_ensure"><code>csL_buff_ensure</code></a>.
        </p>

        <hr><h3><a name="csL_buff_ensure"><code>csL_buff_ensure</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *csL_buff_ensure (csL_Buffer *B, size_t sz);</pre>
        <p>
        Returns an address to a space of size <code>sz</code>
        where you can copy a string to be added to buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        After copying the string into this space you must call
        <a href="#csL_buffadd"><code>csL_buffadd</code></a> with the size
        of the string to actually add it to the buffer.
        </p>

        <hr><h3><a name="csL_buff_push_lstring"><code>csL_buff_push_lstring</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_lstring (csL_Buffer *B, const char *s, size_t l);</pre>
        <p>
        Adds the string pointed to by <code>s</code> with length
        <code>l</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        The string can contain embedded zeros.
        </p>

        <hr><h3><a name="csL_buff_push_string"><code>csL_buff_push_string</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_string (csL_Buffer *B, const char *s);</pre>
        <p>
        Adds the zero-terminated string pointed to by <code>s</code>
        to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        </p>

        <hr><h3><a name="csL_buff_push_stack"><code>csL_buff_push_stack</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_stack (csL_Buffer *B);</pre>
        <p>
        Adds the value on the top of the stack to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>).
        Pops the value.
        <br/><br/>
        This is the only function on string buffers that can (and must)
        be called with an extra element on the stack, which is the value
        to be added to the buffer.
        </p>

        <hr><h3><a name="csL_buff_push_gsub"><code>csL_buff_push_gsub</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void csL_buff_push_gsub (csL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre>
        <p>
        Adds a copy of the string <code>s</code> to the buffer <code>B</code>
        (see <a href="#csL_Buffer"><code>csL_Buffer</code></a>),
        replacing any occurrence of the string <code>p</code> with the
        string <code>r</code>.
        </p>

        <hr><h3><a name="csL_buff_end"><code>csL_buff_end</code></a></h3><p>
        <span class="apii">[-?, +1, <em>m</em>]</span>
        <pre>void csL_buff_end (csL_Buffer *B);</pre>
        <p>
        Finishes the use of buffer <code>B</code> leaving the final string
        on the top of the stack.
        </p>




        <hr><h1>6 &ndash; <a name="6">The Standard Libraries</h1>
        <p>
        The standard CScript libraries provide useful functions that are
        implemented in&nbsp;C through the C&nbsp;API.
        Most of these functions provide essential service to the
        language that is not express via the language syntax and others
        provide access to outside services (e.g., I/O).
        <br/><br/>
        All libraries are implemented through the official C&nbsp;API and are
        provided as separate C&nbsp;modules.
        <br/><br/>
        The notation <b>fail</b> means a false value representing some kind of
        failure (the recommendation is to always test the success of these
        functions with <code>(!status)</code>, instead of
        <code>(status == nil)</code>).
        <br/><br/>
        Currently, CScript has the following standard libraries:
        <ul>
            <li>basic library (<a href="#6.1">&sect;6.1</a>);</li>
            <li>package library(<a href="#6.2">&sect;6.2</a>);</li>
            <li>math library (<a href="#6.3">&sect;6.3</a>);</li>
            <li>string library (<a href="#6.4">&sect;6.4</a>);</li>
            <li>input-output library (<a href="#6.5">&sect;6.5</a>);</li>
            <li>operating system library (<a href="#6.6">&sect;6.6</a>);</li>
        </ul>
        To have access to these libraries, the C&nbsp;host program should
        call the <a href="#csL_openlibs"><code>csL_openlibs</code></a>
        function, which opens all standard libraries.
        Alternatively, the host program can open them individually by using
        <a href="#csL_include"><code>csL_include</code></a> to call
        <a name="csopen_base"><code>csopen_base</code></a> (for the basic library),
        <a name="csopen_package"><code>csopen_package</code></a> (for the package library),
        <a name="csopen_string"><code>csopen_string</code></a> (for the string library),
        <a name="csopen_math"><code>csopen_math</code></a> (for the math library),
        <a name="csopen_io"><code>csopen_io</code></a> (for the I/O library),
        <a name="csopen_os"><code>csopen_os</code></a> (for the operating system library),
        These functions are declared in <a name="cslib.h"><code>cslib.h</code></a>
        </p>


        <h2>6.1 &ndash; <a name="6.1">Basic Library</a></h2>
        <p>
        The basic library provides core functions to CScript.
        <br/><br/>

        <!-- error -->
        <hr/><h3><a name="error"><code>error (message [, level])</code></a></h3>
        Raises an error with <code>message</code> as the error object.
        This function never returns.
        <br/> <br/>
        Usually, <code>error</code> adds some information about the error position
        at the beginning of the message, if the message is a string.
        The <code>level</code> argument specifies how to get the error position.
        With level&nbsp;0 (the default), the error position is where the
        <code>error</code> function was called.
        Level&nbsp;1 points the error to where the function
        that called <code>error</code> was called; and so on.
        Passing a negative level (e.g., <code>-1</code>) avoids the addition
        of error position information to the message.
        <br/><br/>

        <!-- assert -->
        <hr/><h3><a name="assert"><code>assert (v [, message])</code></a></h3>
        Raises an error if the value of its argument <code>v</code> is false
        (i.e., <b>nil</b> or <b>false</b>); otherwise, returns all its arguments.
        <br/><br/>
        In case of error, <code>message</code> is the error object;
        when absent, it defaults to "<code>assertion failed!</code>"
        <br/><br/>

        <!-- gc -->
        <hr/><h3><a name="gc"><code>gc ([opt [, arg]])</code></a></h3>
        This function is a generic interface to the garbage collector.
        It performs different functions according to its first argument,
        <code>opt</code>:
        <ul>
            <li>
                <b>"<code>collect</code>": </b>
                Performs a full garbage-collection cycle.
                This is the default option.
            </li>
            <li>
                <b>"<code>stop</code>": </b>
                Stops automatic execution of the garbage collector.
                The collector will run only when explicitly invoked,
                until a call to restart it.
            </li>
            <li>
                <b>"<code>restart</code>": </b>
                Restarts automatic execution of the garbage collector.
            </li>
            <li>
                <b>"<code>count</code>": </b>
                Returns the total memory in use by CScript in Kbytes.
                The value has a fractional part, so that it multiplied by
                1024 gives the exact number of bytes in use by CScript.
            </li>
            <li>
                <b>"<code>step</code>": </b>
                Performs a garbage-collection step.
                The step "size" is controlled by <code>arg</code>.
                With a zero value, the collector will perform one basic
                (indivisible) step.
                For non-zero values, the collector will perform as if that
                amount of memory (in Kbytes) had been allocated by CScript.
                Returns <b>true</b> if the step finished a collection cycle.
            </li>
            <li>
                <b>"<code>isrunning</code>": </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
            <li>
                <b>"<code>incremental</code>": </b>
                Change the collector mode to incremental.
                This option can be followed by three numbers:
                the garbage-collector pause, the step multiplier,
                and the step size. A zero means to not change that value.
                Returns the previous collector mode as a string (which
                is always "incremental").
            </li>
        </ul>
        This function should not be called by a finalizer (<code>__gc</code>).
        <br/><br/>

        <!-- load -->
        <hr/><h3><a name="load"><code>load (chunk [, chunkname])</code></a></h3>
        Loads a chunk.
        <br/><br/>
        If <code>chunk</code> is a string, the chunk is this string.
        If <code>chunk</code> is a function, <code>load</code> calls it
        repeatedly to get the chunk pieces. Each call to <code>chunk</code>
        must return a string that concatenates with previous results.
        A return of an empty string, <b>nil</b>, or no value signals the end
        of the chunk.
        If there are no syntactic errors, <code>load</code> returns the
        compiled chunk as a function; otherwise, it returns <b>fail</b> plus
        the error message.
        <br/> <br/>
        <code>chunkname</code> is used as the name of the chunk for error
        messages and debug information.
        When absent, it defaults to <code>chunk</code>, if <code>chunk</code>
        is a string, or to "<code>=(load)</code>" otherwise.
        <br/><br/>

        <!-- loadfile -->
        <hr/><h3><a name="loadfile"><code>loadfile ([filename])</code></a></h3>
        Similar to <a href="#load"><code>load</code></a>,
        but gets the chunk from file <code>filename</code> or from the
        standard input, if no file name is given.
        <br/><br/>

        <!-- runfile -->
        <hr/><h3><a name="runfile"><code>runfile ([filename])</code></a></h3>
        Opens the named file and executes its content as a CScript chunk.
        When called without arguments, <code>runfile</code> executes the
        content of the standard input (<code>stdin</code>).
        Returns all values returned by the chunk.
        In case of errors, <code>runfile</code> propagates the error to its
        caller (that is, <code>runfile</code> does not run in protected mode).
        <br/><br/>

        <!-- getmetamethod -->
        <hr/><h3><a name="getmetamethod"><code>getmetamethod (v, name)</code></a></h3>
        Returns the metamethod of the given <code>v</code> or <b>nil</b>
        if <code>v</code> does not have virtual method table and/or the
        <code>v</code> does not implement the metamethod <code>name</code>.
        <br/><br/>

        <!-- next -->
        <hr/><h3><a name="next"><code>next (v [, index])</code></a></h3>
        Allows a program to traverse of all keys or fields of <code>v</code>.
        Its first argument is a table or instance and its second argument
        is an index into this table or instance.
        A call to <code>next</code> returns the next index of the
        <code>v</code> and its associated value.
        When called with <b>nil</b> as its second argument, <code>next</code>
        returns an initial index and its associated value.
        When called with the last index, or with <b>nil</b> in an empty
        table or instance without fields, <code>next</code> returns <b>nil</b>.
        If the second argument is absent, then it is interpreted as <b>nil</b>.
        In particular, you can use <code>next(v)</code> to check whether a
        table is empty or if the instance has no fields.
        <br/><br/>
        The order in which the indices are enumerated is not specified.
        <br/><br/>
        You should not assign any value to a non-existent field in a table
        during its traversal. You may however modify existing fields.
        In particular, you may set existing fields to <b>nil</b>.
        <br/><br/>

        <!-- pairs -->
        <hr/><h3><a name="pairs"><code>pairs (v)</code></a></h3>
        Returns three values: the <a href="#next"><code>next</code></a>
        function, <code>v</code>, and <b>nil</b>, so that the construction

        <pre>   foreach k,v in pairs(v) <em>body</em></pre>

        will iterate over all key&ndash;value pairs of <code>v</code>;
        <code>v</code> should be either a <em>table</em> or <em>instance</em>.
        <br/><br/>
        See function <a href="next"><code>next</code></a> for the caveats
        of modifying the table or instance fields during its traversal.
        <br/><br/>

        <!-- ipairs -->
        <hr/><h3><a name="ipairs"><code>ipairs (a)</code></a></h3>
        Returns three values (an iterator function, the array <code>a</code>,
        and -1)
        so that the construction

        <pre>   foreach i,v in ipairs(a) <em>body</em></pre>

        will iterate over the index&ndash;value pairs
        (<code>0,a[0]</code>), (<code>1,a[1]</code>), ...,
        up to the <em>length</em> of the array <code>a</code>.
        <br/><br/>

        <!-- pcall -->
        <hr/><h3><a name="pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>
        Calls the function <code>f</code> with the given arguments in
        <em>protected mode</em>.
        This means that any error inside&nbsp;<code>f</code> is not propagated;
        instead, <code>pcall</code> catches the error and returns a status code.
        Its first result is the status code (a boolean), which is <b>true</b>
        if the call succeeds without errors.
        In such case, <code>pcall</code> also returns all results from the call,
        after this first result.
        <br/><br/>
        In case of any error, <code>pcall</code> returns <b>false</b> plus the error object.
        Note that errors caught by <code>pcall</code> do not call a message handler.
        <br/><br/>

        <!-- xpcall -->
        <hr/><h3><a name="xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>
        This function is similar to <a href="#pcall"><code>pcall</code></a>,
        except that it sets a new message handler <code>msgh</code>.
        <br/><br/>

        <!-- print -->
        <hr/><h3><a name="print"><code>print (&middot;&middot;&middot;)</code></a></h3>
        Receives any number of arguments and prints their values to
        <code>stdout</code>, converting each argument to a string
        following the same rules of <a href="#tostring"><code>tostring</code></a>.
        <br/><br/>
        The function <code>print</code> is not intended for formatted output,
        but only as a quick way to show a value, for instance for debugging.
        For complete control over the output, use
        <a href="#io.printf"><code>io.printf</code></a> and
        <a href="#io.write"><code>io.write</code></a>.
        <br/><br/>

        <!-- warn -->
        <hr/><h3><a name="warn"><code>warn (msg1, &middot;&middot;&middot;)</code></a></h3>
        Emits a warning with a message composed by the concatenation
        of all its arguments (which should be strings).
        <br/><br/>
        By convention, a one-piece message starting with '<code>@</code>'
        is intended to be a <em>control message</em>,
        which is a message to the warning system itself.
        In particular, the standard warning function in CScript
        recognizes the control messages "<code>@off</code>",
        to stop the emission of warnings, and "<code>@on</code>", to
        (re)start the emission; it ignores unknown control messages.
        <br/><br/>

        <!-- len -->
        <hr/><h3><a name="len"><code>len (v)</code></a></h3>
        Returns the length of the object <code>v</code>, which must be
        array, table, instance or a string.
        <br/> <br/>
        <em>Array</em> length is total number of elements in use (one index
        above the biggest index that was set);
        <em>table</em> length is total number of keys with non-<b>nil</b>
        values; <em>instance</em> length is total number of fields with
        non-<b>nil</b> values; <em>string</em> length is size of string in
        bytes.
        <br/><br/>
        Returns an integer.
        <br/><br/>

        <!-- rawequal -->
        <hr/><h3><a name="rawequal"><code>rawequal (v1, v2)</code></a></h3>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        <br/><br/>
        Returns a boolean.
        <br/><br/>

        <!-- rawget -->
        <hr/><h3><a name=rawget""><code>rawget (v, index)</code></a></h3>
        Gets the real value of <code>v[index]</code>,
        without calling the <code>__getidx</code> metamethod.
        <code>v</code> must be a array, table or instance;
        <code>index</code> may be any value if <code>v</code> is instance or a
        table; if <code>v</code> is array, <code>index</code> should be
        positive integer or 0.
        <br/><br/>

        <!-- rawset -->
        <hr/><h3><a name="rawset"><code>rawset (v, index, value)</code></a></h3>
        Sets the real value of <code>v[index]</code> to <code>value</code>,
        without using the <code>__setidx</code> metamethod.
        <code>v</code> must be an array, table or instance;
        <code>index</code> any value different from <b>nil</b> and NaN if the
        <code>v</code> is a table or instance, otherwise <code>index</code>
        should be a positive integer or 0; <code>value</code> any CScript value.
        <br/><br/>
        This function returns <code>v</code>.
        <br/><br/>

        <!-- getargs -->
        <hr/><h3><a name="getargs"><code>getargs (index, &middot;&middot;&middot;)</code></a></h3>
        If <code>index</code> is a number, returns all arguments after
        argument number <code>index</code>; a negative number indexes from
        the end (-1 is the last argument).
        Otherwise, <code>index</code> must be one of these strings:
        <code>"array"</code>, <code>"table"</code> or <code>"len"</code>.
        <br/><br/>
        In case <code>index</code> is <code>"array"</code> or
        <code>"table"</code> string then <code>getargs</code> returns
        the total number of extra arguments it received; <code>"array"</code>
        returns the extra arguments inside the array, <code>"table"</code>
        returns the extra arguments inside the table where each argument is
        a key with <b>true</b> value.
        <br/><br/>
        However if <code>index</code> is 
        <code>"len"</code> string, then <code>getargs</code> returns integer
        corresponding to total number of extra arguments.
        <br/><br/>

        <!-- tonumber -->
        <hr/><h3><a name="tonumber"><code>tonumber (v, [, base])</code></a></h3>
        When called with no <code>base</code>,
        <code>tonumber</code> tries to convert its argument to a number.
        If the argument <code>v</code> is already a number or a string
        convertible to a number, then <code>tonumber</code> returns this
        number and overflow flag; otherwise, it returns <b>fail</b>.
        <br/><br/>
        The conversion of strings can result in integers or floats.
        The string may have leading and trailing spaces and a sign.
        The conversion mimics C standard library functions <code>strtod</code>
        and <code>strtol</code>.
        <br/><br/>
        When called with <code>base</code>, then <code>v</code> must be a
        string to be interpreted as an integer numeral in that base.
        The base may be any integer between 2 and 36, inclusive.
        In bases above&nbsp;10, the letter '<code>A</code>' (in either upper
        or lower case) represents&nbsp;10, '<code>B</code>' represents&nbsp;11,
        and so forth, with '<code>Z</code>' representing 35.
        If the string <code>v</code> is not a valid numeral in the given base,
        the function returns <b>fail</b>.
        <br/><br/>

        <!-- tostring -->
        <hr/><h3><a name="tostring"><code>tostring (v)</code></a></h3>
        Receives a value of any type and converts it to a string in a
        human-readable format.
        <br/><br/>

        <!-- typeof -->
        <hr/><h3><a name="typeof"><code>typeof (v)</code></a></h3>
        Returns the type of its only argument, coded as a string.
        The possible results of this function are
        "<code>nil</code>" (a string, not the value <b>nil</b>),
        "<code>number</code>",
        "<code>string</code>",
        "<code>boolean</code>",
        "<code>array</code>",
        "<code>table</code>",
        "<code>function</code>",
        "<code>class</code>",
        "<code>instance</code>",
        "<code>thread</code>",
        and "<code>userdata</code>".
        <br/><br/>

        <!-- __G -->
        <hr/><h3><a name="__G"><code>__G</code></a></h3>
        A global variable (not a function) that holds the global table
        (see <a href="#2.2">&sect;2.2</a>).
        </p>

        <!-- __VERSION -->
        <hr/><h3><a name="__VERSION"><code>__VERSION</code></a></h3>
        A global variable (not a function) that holds a string containing
        the running CScript version.
        <br/>
        The current value of this variable is "<code>CScript 1.0</code>".
        </p>


        <h2>6.2 &ndash; <a name="6.2">Package Library</a></h2>
        <p>
        </p>


        <h2>6.3 &ndash; <a name="6.3">String Library</a></h2>
        <p>
        This library provides generic functions for string manipulation,
        such as finding and extracting substrings and other common operations.
        All of the functionality is provided in the global table 
        <a name="string"><code>string</code></a>.
        When indexing strings in CScript, the first character is at position
        &nbsp;0 (same as in C).
        Indices are allowed to be negative and are interpreted as indexing
        backwards, from the end of the string.
        Thus, the last character is at position -1, and so on.
        <br/>
        The string library assumes one-byte character encodings.
        </p>


        <h2>6.4 &ndash; <a name="6.4">Math Library</a></h2>
        <p>
        </p>


        <h2>6.5 &ndash; <a name="6.5">I/O Library</a></h2>
        <p>
        </p>


        <h2>6.6 &ndash; <a name="6.6">OS Library</a></h2>
        <p>
        </p>
    </body>
</html>
