<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width"/>
        <title>CScript 1.0 Reference Manual</title>
        <link rel="stylesheet" type="text/css" href="cscript.css">
        <link rel="stylesheet" type="text/css" href="index.css">
    </head>
    <body>
        <h1>CScript 1.0 Reference Manual</h1>
        <small>
            <p>
            Copyright &copy; 2020&ndash;2024 Lua.org, PUC-Rio;
            2024&ndash;2025 Jure BagiÄ‡.
            </p>
        </small>
        <div class="menubar">
            <a href="contents.html#contents">contents</a>
            &middot;
            <a href="contents.html#index">index</a>
        </div>




        <h1>1 &ndash; <a name="1">Introduction</a></h1>
        <p>
        CScript is a lightweight embeddable scripting language.
        C in CScript refers to the C programming language as it mimics its
        syntax (as much as possible).
        It's syntax supports various types of programming styles and it does
        not enforce any type/style upon the user (it has all the tools and the
        user chooses the tool for the job).
        <br/><br/>
        CScript is dynamically typed, it runs by interpreting bytecode with
        a stack-based virtual machine, and it's memory is automatically
        managed by the incremental garbage collection.
        <br/><br/>
        CScript is implemented as a library fully written in C, and to be
        compiled with any standard C/C++ compiler implementing C99 standard.
        CScript distribution includes a host program called
        <code>cscript</code>, which is the interpreter that uses CScript
        library.
        CScript is intended to be primarily used as lightweight embeddable
        scripting language but also as a stand-alone language that is easy
        to learn as it shares most of its syntax with the C programming
        language and <a href="https://www.lua.org/">Lua</a>.
        <br/><br/>
        CScript is free software, and is provided with no guarantees,
        as stated in its license.
        <br/><br/>
        This manual is subject to changes, as the language itself changes.
        However the reference manual is always valid for the same version of
        CScript distribution. If you spot the mistake or you think the manual
        is lacking in various places, please let me know
        (<a href="https://github.com/b-jure/cscript">link</a> to the official
        git[hub] repository).
        </p>




        <h1>2 &ndash; <a name="2">Basic Concepts</a></h1>
        <p>
        This section describes the basic concepts of the language.
        </p>


        <h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>
        <p>
        CScript is a dynamically types language.
        This means that variables do not have types; only values do.
        There are no type definitions in the language instead all values
        carry their own type.
        <br/><br/>
        All values in CScript are first-class values, meaning all values
        can be stored in variables (as is expected), passed as arguments
        to other functions and returned as results.
        <br/><br/>
        There are eleven basic types in CScript:
        <em>nil</em>, <em>boolean</em>, <em>number</em>, <em>string</em>, 
        <em>function</em>, <em>userdata</em>, <em>thread</em>, <em>table</em>, 
        <em>array</em>, <em>class</em> and <em>instance</em>.
        <br/><br/>
        <!-- nil -->
        The type <em>nil</em> has one single value, <b>nil</b>, and is
        intended to represent absence of value.
        <br/><br/>
        <!-- boolean -->
        The type <em>boolean</em> has two values, <b>true</b> and <b>false</b>.
        Both <b>nil</b> and <b>false</b> make a condition false; they are
        collectively called <em>false values</em>
        (for example in C, we would consider <b>0</b> value as the
        <em>false value</em>).
        Any other value makes a condition true.
        So what is the difference between the <b>false</b> and <b>nil</b>?
        Here is a simple example, if we were to index a table with <b>nil</b>
        it would raise a runtime error; as said, use <b>nil</b> to indicate
        absence of value.
        <br/><br/>
        <!-- number -->
        The type <em>number</em> represents both integer and real
        (floating-point) numbers, using two subtypes: <em>integer</em> and
        <em>float</em> (as is indicated in the C&nbsp;API header).
        <br/>
        Standard CScript uses 64-bit integers and double-precision (64-bit)
        floats. Configuration header can be tinkered to allow 32-bit integers
        and/or single-precision (32-bit) floats, but this but would probably
        require internal patches (see <code>csconf.h</code> if interested).
        <br/>
        Any overflow when manipulating integer values <em>wrap around</em>,
        according to the usual rules of two-complement arithmetics.
        This holds both for negative (signed) and positive (unsigned) integers.
        <br/>
        The conversion between the two subtypes mimics C standard.
        For example, if we were to do a mathematical operation between the two
        numbers, one of them is <em>integer</em> and the other is
        <em>float</em>, before the operation <em>integer</em> would be
        converted to a <em>float</em>.
        Additionally before the operation if the both numbers are of type
        <em>float</em> but both have <em>integer</em> representation, then
        they would be converted to <em>integers</em> before the operation
        (this would result in a slower operation on processors that support
        float division but this behaviour can also be configured in CScript
        internals quite easily, check <code>cvm.c</code>).
        <br/><br/>
        <!-- string -->
        The type <em>string</em> represents immutable sequence of bytes.
        Strings can contain any 8-bit value, including embedded zeros
        ('<code>\0</code>').
        Internally CScript is encoding-agnostic; it makes no assumptions
        about the contents of a string.
        The length of any string in CScript must fit in a CScript integer.
        <br/><br/>
        <!-- function -->
        The type <em>function</em> can be a function written in CScript or
        C, both of which can be manipulated and called.
        <br/><br/>
        <!-- userdata -->
        The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data
        to be stored in a variable.
        A userdata value represents a block of raw memory.
        There are two kinds of userdata:
        <em>full userdata</em>, which is an object with a block of memory
        managed by CScript, and <em>light userdata</em>,
        which is simply a C&nbsp;pointer value.
        Userdata has no predefined operations in CScript except assignment
        and identity test (<code>==</code>).
        By using <em>VMTs</em> (virtual method tables), the programmer can
        define operations for full userdata values.
        Userdata values cannot be created or modified in CScript, only
        through the C&nbsp;API.
        This guarantees the integrity of data owned by the host program
        and C&nbsp;libraries.
        <br/><br/>
        <!-- table -->
        The type <em>table</em> implements associative arrays,
        that is, arrays that can have as indices not only numbers,
        but any CScript value except <b>nil</b> and NaN
        (<em>Not a Number</em> is a special floating-point value
        used by the IEEE 754 standard to represent undefined numerical
        results, such as <code>0/0</code>).
        <br/>
        Tables can be contain values of all types (except <b>nil</b>).
        Any key associated to the value <b>nil</b> is not considered part of
        the table. Conversely, any key that is not part of a table has
        an associated value <b>nil</b>.
        <br/>
        Tables can be indexed two different ways, given the key
        <code>name</code> we index the table <code>t</code> either as
        <code>t.name</code> or <code>t["name"]</code>.
        The array-like indexing is useful when we want to index the table
        with the value of the variable.
        <br/><br/>
        <!-- array -->
        The type <em>array</em> is a linear collection of values each
        identified by an <b>index</b>. Each <b>index</b> is positive integer
        value or 0 which is used to index the <em>array</em> in order to
        retrieve the value (variable values can also be used in place of literal
        integers). Negative integer indices are not allowed.
        <br/><br/>
        <!-- class -->
        The type <em>class</em> is useful for object-oriented programming.
        Class can contain <em>methods</em> which are defined upon class
        creation and can not be changed after.
        The reason why they can't be changed is because how inheritance is
        implemented internally, which in turn makes code much more manageable.
        <em>class</em> can inherit from another class, the name of the
        <em>class</em> from which we inherit is called a <em>superclass</em>.
        When inheriting all of the <em>superclass methods</em> are copied over
        to the <em>class</em> being created.
        <br/>
        When constructing a <em>class</em> programmer can define
        <em>metamethods</em> which are special functions that provide
        meta-programming functionality.
        <br/><br/>
        <!-- instance -->
        The type <em>instance</em> is similar to <em>table</em>; it can be
        indexed and indexed values are the values of the <em>instance</em>
        <em>fields</em>. Each <em>instance</em> is constructed from a
        <em>class</em>.
        The <em>class</em> methods of the <em>instance</em> can't be changed
        but can be shadowed by creating a non <b>nil</b> <em>field</em> with
        the same key.
        <br/><br/>
        <!-- thread -->
        The type <em>thread</em> represents independent threads of execution.
        CScript threads are not related to operating-system threads.
        <br/><br/>
        The library function <a href=#typeof><code>typeof</code></a> returns a
        string describing the type of a given value.
        </p>


        <h2>2.2 &ndash; <a name="2.2">Global Table</a></h2>
        <p>To do...</p>


        <h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>
        <p>To do...</p>


        <h2>2.4 &ndash; <a name="2.4">Metamethods</a></h2>
        <p>To do...</p>


        <h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>
        <p>To do...</p>




        <h1>3 &ndash; <a name="3">The Language</h1>
        <p>To do...</p>




        <h1>4 &ndash; <a name="4">The Application Programming Interface</h1>
        <p>
        This section describes the C&nbsp;API for CScript, that is,
        the set of C&nbsp;functions available to the host program to
        communicate with CScript.
        All API functions and related types and constants are declared in
        the header file <a name="cscript.h"><code>cscript.h</code></a>.
        </br></br>
        Even when we use the term "function", any facility in the API may be
        provided as a macro instead.
        Except where stated otherwise, all such macros use each of their
        arguments exactly once (except for the first argument, which is always
        a CScript state), and so do not generate any hidden side-effects.
        </br></br>
        As in most C&nbsp;libraries, the CScript API functions do not check
        their arguments for validity or consistency.
        However, you can change this behavior by compiling CScript with the
        macro <a name="CS_USE_APICHECK"><code>CS_USE_APICHECK</code></a> defined.
        </br></br>
        The CScript library is fully reentrant: it has no global variables.
        It keeps all information it needs in a dynamic structure, called
        the <em>CScript state</em>.
        </br></br>
        Each CScript state has one or more threads, which correspond to
        independent, cooperative lines of execution.
        The type <a href="#cs_State"><code>cs_State</code></a> (despite its
        name) refers to a thread.
        (Indirectly, through the thread, it also refers to the CScript state
        associated to the thread.)
        </br></br>
        A pointer to a thread must be passed as the first argument to every
        function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates
        a CScript state from scratch and returns a pointer to the
        <em>main thread</em> in the new state.
        </p>


        <h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>
        <p>
        CScript uses a <em>virtual stack</em> to pass values to and from C.
        Each element in this stack represents a CScript value (<b>nil</b>,
        number, string, etc.).
        Functions in the API can access this stack through the CScript state
        parameter that they receive.
        <br/><br/>
        Whenever CScript calls C, the called function gets a new stack,
        which is independent of previous stacks and of stacks of
        C&nbsp;functions that are still active.
        This stack initially contains any arguments to the C&nbsp;function
        and it is where the C&nbsp;function can store temporary CScript
        values and must push its results to be returned to the caller
        (see <a href="#cs_CFunction"><code>cs_CFunction</code></a>).
        <br/><br/>
        For convenience, most query operations in the API do not follow a
        strict stack discipline.
        Instead, they can refer to any element in the stack by using an
        <em>index</em>:
        A positive index represents an absolute stack position, starting
        at&nbsp;0 as the bottom of the stack;
        a negative index represents an offset relative to the top of the stack.
        More specifically, if the stack has <em>n</em> elements, then
        index&nbsp;0 represents the first element
        (that is, the element that was pushed onto the stack first)
        and index&nbsp;<em>n-1</em> represents the last element;
        index&nbsp;-1 also represents the last element
        (that is, the element at the&nbsp;top)
        and index <em>-n</em> represents the first element.
        </p>


        <h3>4.1.1 &ndash; <a name="4.1.1">Stack Size</a></h3>
        <p>
        When you interact with the CScript API, you are responsible for
        ensuring consistency.
        In particular,
        <em>you are responsible for controlling stack overflow</em>.
        When you call any API function, you must ensure the stack has enough
        room to accommodate the results.
        <br/><br/>
        There is one exception to the above rule:
        When you call a CScript function without a fixed number of results
        (see <a href="#cs_call"><code>cs_call</code></a>),
        CScript ensures that the stack has enough space for all results.
        However, it does not ensure any extra space.
        So, before pushing anything on the stack after such a call
        you should use <a href="#cs_checkstack"><code>cs_checkstack</code></a>.
        <br/><br/>
        Whenever CScript calls C, it ensures that the stack has space for at
        least <a name="CS_MINSTACK"><code>CS_MINSTACK</code></a> extra elements;
        that is, you can safely push up to <code>CS_MINSTACK</code> values into it.
        <code>CS_MINSTACK</code> is defined as 20, so that usually you do
        not have to worry about stack space unless your code has loops pushing
        elements onto the stack.
        Whenever necessary, you can use the function
        <a href="#cs_checkstack"><code>cs_checkstack</code></a> to ensure
        that the stack has enough space for pushing new elements.
        </p>


        <h3>4.1.2 &ndash; <a name="4.1.2">Valid and Acceptable Indices</a></h3>
        <p>
        Any function in the API that receives stack indices works only with
        <em>valid indices</em> or <em>acceptable indices</em>.
        <br/><br/>
        A <em>valid index</em> is an index that refers to a position that
        stores a modifiable CScript value.
        It comprises stack indices between&nbsp;0 and the stack top
        (<code>0 &le; abs(index) &lt; top</code>) plus <em>pseudo-indices</em>,
        which represent some positions that are accessible to C&nbsp;code
        but that are not in the stack.
        Pseudo-indices are used to access the registry (see <a href="#4.3">&sect;4.3</a>)
        and the upvalues of a C&nbsp;function (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Functions that do not need a specific mutable position, but only a
        value (e.g., query functions), can be called with acceptable indices.
        An <em>acceptable index</em> can be any valid index, but it also can
        be any positive index after the stack top within the space allocated
        for the stack, that is, indices up to the stack size (not inclusive).
        Indices to upvalues (see <a href="#4.2">&sect;4.2</a>) greater than
        the real number of upvalues in the current C&nbsp;function are also
        acceptable (but invalid).
        Except when noted otherwise, functions in the API work with acceptable
        indices.
        <br/><br/>
        Acceptable indices serve to avoid extra tests against the stack top
        when querying the stack.
        For instance, a C&nbsp;function can query its third argument without
        the need to check whether there is a third argument, that is, without
        the need to check whether 2 is a valid index.
        <br/><br/>
        For functions that can be called with acceptable indices, any
        non-valid index is treated as if it contains a value of a virtual
        type <a name="CS_TNONE"><code>CS_TNONE</code></a>, which behaves
        like a nil value.
        </p>


        <h3>4.1.3 &ndash; <a name="4.1.3">Pointers to strings</a></h3>
        <p>
        Several functions in the API return pointers (<code>const char*</code>)
        to CScript strings in the stack.
        (See <a href="#cs_pushfstring"><code>cs_push_fstring</code></a>,
        <a href="#cs_push_lstring"><code>cs_push_lstring</code></a>,
        <a href="#cs_push_string"><code>cs_push_string</code></a>,
        and <a href="#cs_to_lstring"><code>cs_to_lstring</code></a>.
        See also <a href="#csL_check_lstring"><code>csL_check_lstring</code></a>,
        <a href="#csL_check_string"><code>csL_check_string</code></a>,
        and <a href="#csL_to_lstring"><code>csL_to_lstring</code></a> in the
        auxiliary library.)
        <br/><br/>
        In general, CScript's garbage collection can free or move internal
        memory and then invalidate pointers to internal strings.
        To allow a safe use of these pointers, the API guarantees that any
        pointer to a string in a stack index is valid while the string value
        at that index is not removed from the stack.
        (It can be moved to another index, though.)
        When the index is a pseudo-index (referring to an upvalue), the
        pointer is valid while the corresponding call is active and the
        corresponding upvalue is not modified.
        <br/><br/>
        Some functions in the debug interface also return pointers to strings,
        namely <a href="#cs_getlocal"><code>cs_getlocal</code></a>,
        <a href="#cs_getupvalue"><code>cs_getupvalue</code></a>,
        <a href="#cs_setlocal"><code>cs_setlocal</code></a>,
        and <a href="#cs_setupvalue"><code>cs_setupvalue</code></a>.
        For these functions, the pointer is guaranteed to be valid while the
        caller function is active and the given closure (if one was given)
        is in the stack.
        <br/><br/>
        Except for these guarantees, the garbage collector is free to
        invalidate any pointer to internal strings.
        </p>


        <h2>4.2 &ndash; <a name="4.2">C Closures</a></h2>
        <p>
        When a C&nbsp;function is created, it is possible to associate
        some values with it, thus creating a <em>C&nbsp;closure</em>
        (see <a href="#cs_push_cclosure"><code>cs_push_cclosure</code></a>);
        these values are called <em>upvalues</em> and are accessible to the
        function whenever it is called.
        <br/><br/>
        Whenever a C&nbsp;function is called, its upvalues are located at
        specific pseudo-indices.
        These pseudo-indices are produced by the macro
        <a href="#cs_upvalueindex"><code>cs_upvalueindex</code></a>.
        The first upvalue associated with a function is at index
        <code>cs_upvalueindex(0)</code>, and so on.
        Any access to <code>cs_upvalueindex(<em>n</em>)</code>,
        where <em>n</em> is greater than the number of upvalues of the
        current function, produces an acceptable but invalid index.
        <br/><br/>
        A C&nbsp;closure can also change the values of its corresponding
        upvalues.
        </p>


        <h2>4.3 &ndash; <a name="4.3">Registry</a></h2>
        <p>
        CScript provides a <em>registry</em>, a predefined array that can be
        used by any C&nbsp;code to store whatever CScript values it needs to
        store.
        The registry array is always accessible at pseudo-index
        <a name="CS_REGISTRYINDEX"><code>CS_REGISTRYINDEX</code></a>.
        Any C&nbsp;library can store data into this array, but it must take
        care to choose indices that are different from those used by other
        libraries, to avoid collisions.
        Typically, you would use
        <a href="#cs_getfreereg"><code>cs_getfreereg</code></a> in order to
        obtain free registry index.
        As with variable names, string keys starting with an two consecutive
        underscore followed by uppercase letters are reserved for CScript.
        <br/><br/>
        When you create a new CScript state, its registry comes with some
        predefined values.
        These predefined values are indexed with indices defined as constants
        in <code>cscript.h</code>.
        The following constants are defined:
        <ul>
            <li>
                <b><a name="CS_RINDEX_MAINTHREAD"><code>CS_RINDEX_MAINTHREAD</code></a>:</b>
                At this index the registry has the main thread of the state.
                (The main thread is the one created together with the state.)
            </li>
            <li>
                <b><a name="CS_RINDEX_GLOBALS"><code>CS_RINDEX_GLOBALS</code></a>:</b>
                At this index the registry has the global table.
            </li>
        </ul>
        </p>


        <h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>
        <p>
        Internally, CScript uses the C <code>longjmp</code> facility to handle
        errors.
        When CScript faces any error, such as a memory allocation error or a
        type error, it <em>raises</em> an error; that is, it does a long jump.
        A <em>protected environment</em> uses <code>setjmp</code>
        to set a recovery point; any error jumps to the most recent active
        recovery point.
        <br/><br/>
        Inside a C&nbsp;function you can raise an error explicitly
        by calling <a href="#cs_error"><code>cs_error</code></a>.
        <br/><br/>
        Most functions in the API can raise an error, for instance due to
        a memory allocation error.
        The documentation for each function indicates whether it can raise
        errors.
        <br/><br/>
        If an error happens outside any protected environment, CScript calls
        a <em>panic function</em>
        (see <a href="#cs_atpanic"><code>cs_atpanic</code></a>)
        and then calls <code>abort</code>, thus exiting the host application.
        Your panic function can avoid this exit by never returning
        (e.g., doing a long jump to your own recovery point outside CScript).
        <br/><br/>
        The panic function, as its name implies, is a mechanism of last resort.
        Programs should avoid it.
        As a general rule, when a C&nbsp;function is called by CScript with a
        CScript state, it can do whatever it wants on that CScript state,
        as it should be already protected.
        However, when C code operates on other CScript states
        (e.g., a CScript-state argument to the function, a CScript state
        stored in the registry, or the result of
        <a href="#cs_newthread"><code>cs_newthread</code></a>),
        it should use them only in API calls that cannot raise errors.
        <br/><br/>
        The panic function runs as if it were a message handler
        (see <a href="#2.3">&sect;2.3</a>); in particular, the error object
        is on the top of the stack.
        However, there is no guarantee about stack space.
        To push anything on the stack, the panic function must first check
        the available space (see <a href="#4.1.1">&sect;4.1.1</a>).
        </p>


        <h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>
        <p>
        Several functions that report errors in the API use the following
        status codes to indicate different kinds of errors or other conditions:
        <ul>
            <li><b><a name="pdf-CS_OK"><code>CS_OK</code></a> (0):</b>
                no errors.
            </li>
            <li><b><a name="pdf-CS_ERRRUN"><code>CS_ERRRUNTIME</code></a>:</b>
                a runtime error.
            </li>
            <li><b><a name="pdf-CS_ERRMEM"><code>CS_ERRMEM</code></a>: </b>
                memory allocation error.
                For such errors, CScript does not call the message handler.
            </li>
            <li><b><a name="pdf-CS_ERRERR"><code>CS_ERRERROR</code></a>: </b>
                error while running the message handler.
            </li>
            <li><b><a name="pdf-CS_ERRSYNTAX"><code>CS_ERRSYNTAX</code></a>:</b>
                syntax error during precompilation.</li>
            <li><b><a name="pdf-CS_ERRFILE"><code>CS_ERRFILE</code></a>:</b>
                a file-related error;
                e.g., it cannot open or read the file.</li>
        </ul><p>
        These constants are defined in the header file <code>cscript.h</code>.
        </p>


        <h2>4.5 &ndash; <a name="4.5">Functions and Types</a></h2>
        <p>
        Here we list all functions and types from the C&nbsp;API in
        alphabetical order.
        Each function has an indicator like this:
        <span class="apii">[-o, +p, <em>x</em>]</span>
        <br/><br/>
        The first field, <code>o</code>, is how many elements the function
        pops from the stack.
        The second field, <code>p</code>, is how many elements the function
        pushes onto the stack.
        (Any function always pushes its results after popping its arguments.)
        A field in the form <code>x|y</code> means the function can push
        (or pop) <code>x</code> or <code>y</code> elements, depending on
        the situation; an interrogation mark '<code>?</code>' means that
        we cannot know how many elements the function pops/pushes by looking
        only at its arguments.
        (For instance, they may depend on what is in the stack.)
        The third field, <code>x</code>, tells whether the function may raise errors:
        '<code>-</code>' means the function never raises any error;
        '<code>m</code>' means the function may raise only out-of-memory errors;
        '<code>v</code>' means the function may raise the errors explained in the text;
        '<code>e</code>' means the function can run arbitrary CScript code,
        either directly or through metamethods, and therefore may raise any
        errors.
        </p>

        <!-- cs_State -->
        <hr><h3><a name="cs_State"><code>cs_State</code></a></h3>
        <pre>typedef struct cs_State cs_State;</pre>
        <p>
        An opaque structure that points to a thread and indirectly
        (through the thread) to the whole state of a CScript interpreter.
        The CScript library is fully reentrant: it has no global variables.
        All information about a state is accessible through this structure.
        <br/><br/>
        A pointer to this structure must be passed as the first argument to
        every function in the library, except to
        <a href="#cs_newstate"><code>cs_newstate</code></a>, which creates a
        CScript state from scratch.
        </p>

        <!-- cs_Integer -->
        <hr><h3><a name="cs_Integer"><code>cs_Integer</code></a></h3>
        <pre>typedef ... cs_Integer;</pre>
        <p>
        The type of integers in CScript.
        <br/><br/>
        By default this type is <code>long long</code>,
        (usually a 64-bit two-complement integer),
        (See <code>CS_INT_TYPE</code> in <code>csconf.h</code>.)
        <br/><br/>
        CScript also defines the constants
        <a name="CS_INTEGER_MIN"><code>CS_INTEGER_MIN</code></a> and
        <a name="CS_INTEGER_MAX"><code>CS_INTEGER_MAX</code></a>,
        with the minimum and the maximum values that fit in this type.
        </p>

        <!-- cs_Unsigned -->
        <hr><h3><a name="cs_Unsigned"><code>cs_Unsigned</code></a></h3>
        <pre>typedef ... cs_Unsigned;</pre>
        <p>
        The unsigned version of <a href="#cs_Integer"><code>cs_Integer</code></a>.
        </p>

        <!-- cs_Number -->
        <hr><h3><a name="cs_Number"><code>cs_Number</code></a></h3>
        <pre>typedef ... cs_Number;</pre>
        <p>
        The type of floats in CScript.
        <br/><br/>
        By default this type is double, but that can be changed to a single
        float or a long double.
        (See <code>CS_FLOAT_TYPE</code> in <code>csconf.h</code>.)
        </p>

        <!-- cs_CFunction -->
        <hr><h3><a name="cs_CFunction"><code>cs_CFunction</code></a></h3>
        <pre>typedef int (*cs_CFunction) (cs_State *C);</pre>
        <p>
        Type for C&nbsp;functions.
        <br/><br/>
        In order to communicate properly with CScript, a C&nbsp;function
        must use the following protocol, which defines the way parameters and
        results are passed: a C&nbsp;function receives its arguments from
        CScript in its stack in direct order (the first argument is pushed first).
        So, when the function starts, <code>cs_nvalues(C)</code> returns the
        number of arguments received by the function.
        The first argument (if any) is at index 0 and its last argument is at
        index <code>cs_gettop(C)</code>.
        To return values to CScript, a C&nbsp;function just pushes them onto
        the stack, in direct order (the first result is pushed first), and
        returns in C the number of results.
        Any other value in the stack below the results will be properly
        discarded by CScript.
        Like a CScript function, a C&nbsp;function called by CScript can also
        return many results.
        <br/><br/>
        As an example, the following function receives a variable number
        of numeric arguments and returns their average and their sum:
        <pre>
    static int foo (cs_State *C) {
        int n = cs_gettop(C);   /* index of last argument (or cs_nvalues(C)-1) */
        cs_Number sum = 0.0;
        int i;
        for (i = 0; i &lt;= n; i++) {
            if (!cs_is_number(C, i)) {
                cs_push_literal(C, "incorrect argument");
                cs_error(C);
            }
            sum += cs_to_number(C, i);
        }
        cs_push_number(C, sum/n);       /* first result */
        cs_push_number(C, sum);         /* second result */
        return 2;                   /* number of results */
    }</pre>
        </p>

        <!-- cs_Alloc -->
        <hr><h3><a name="cs_Alloc"><code>cs_Alloc</code></a></h3>
        <pre>typedef void *(*cs_Alloc) (void *ptr,
                           size_t osz,
                           size_t nsz,
                           void *ud);</pre>
        <p>
        The type of the memory-allocation function used by CScript states.
        The allocator function must provide a functionality similar to
        <code>realloc</code>, but not exactly the same.
        Its arguments are <code>ud</code>, last argument that is an opaque
        pointer passed to <a href="#cs_newstate"><code>cs_newstate</code></a>;
        <code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
        <code>osz</code>, the original size of the block or some code about
        what is being allocated (such as a <a href="#cs_type">type</a> tag);
        and <code>nsz</code>, the new size of the block.
        <br/><br/>
        When <code>ptr</code> is not <code>NULL</code>, <code>osz</code> is
        the size of the block pointed by <code>ptr</code>, that is, the size
        given when it was allocated or reallocated.
        <br/><br/>
        When <code>ptr</code> is <code>NULL</code>, <code>osz</code> encodes
        the kind of object that CScript is allocating.
        <code>osz</code> is any of
        <a href="#pdf-CS_TUSERDATA"><code>CS_TUSERDATA</code></a>,
        <a href="#pdf-CS_TSTRING"><code>CS_TSTRING</code></a>,
        <a href="#pdf-CS_TARRAY"><code>CS_TARRAY</code></a>,
        <a href="#pdf-CS_TTABLE"><code>CS_TTABLE</code></a>,
        <a href="#pdf-CS_TFUNCTION"><code>CS_TFUNCTION</code></a>,
        <a href="#pdf-CS_TCLASS"><code>CS_TCLASS</code></a>,
        <a href="#pdf-CS_TINSTANCE"><code>CS_TINSTANCE</code></a>, or
        <a href="#pdf-CS_TTHREAD"><code>CS_TTHREAD</code></a> when
        (and only when) CScript is creating a new object of that type.
        When <code>osz</code> is some other value, CScript is allocating
        memory for something else.
        <br/><br/>
        CScript assumes the following behavior from the allocator function:
        <br/><br/>
        When <code>nsz</code> is zero, the allocator must behave like
        <code>free</code> and then return <code>NULL</code>.
        <br/><br/>
        When <code>nsz</code> is not zero, the allocator must behave like
        <code>realloc</code>.
        In particular, the allocator returns <code>NULL</code> if and only if
        it cannot fulfill the request.
        <br/><br/>
        Here is a simple implementation for the allocator function.
        It is used in the auxiliary library by
        <a href="#csL_newstate"><code>csL_newstate</code></a>.
        <pre>
    static void *allocator (void *ptr, size_t osz, size_t nsz, void *ud) {
        (void)ud;  (void)osz;  /* not used */
        if (nsz == 0) {
            free(ptr);
            return NULL;
        } else
            return realloc(ptr, nsz);
    }</pre>
        Note that ISO&nbsp;C ensures that <code>free(NULL)</code> has no
        effect and that <code>realloc(NULL,size)</code> is equivalent to
        <code>malloc(size)</code>.
        </p>

        <!-- cs_Reader -->
        <hr><h3><a name="cs_Reader"><code>cs_Reader</code></a></h3>
        <pre>typedef const char *(*cs_Reader) (cs_State *C,
                                  void *data,
                                  size_t *size);</pre>
        <p>
        The reader function used by <a href="#cs_load"><code>cs_load</code></a>.
        Every time <a href="#cs_load"><code>cs_load</code></a> needs another
        piece of the chunk, it calls the reader, passing along its
        <code>data</code> parameter.
        The reader must return a pointer to a block of memory with a new piece
        of the chunk and set <code>size</code> to the block size.
        The block must exist until the reader function is called again.
        To signal the end of the chunk, the reader must return
        <code>NULL</code> or set <code>size</code> to zero.
        The reader function may return pieces of any size greater than zero.
        </p>

        <!-- cs_WarnFunction -->
        <hr><h3><a name="cs_WarnFunction"><code>cs_WarnFunction</code></a></h3>
        <pre>typedef void (*cs_WarnFunction) (void *ud, const char *msg, int tocont);</pre>
        <p>
        The type of warning functions, called by CScript to emit warnings.
        The first parameter is an opaque pointer set by
        <a href="#cs_setwarnf"><code>cs_setwarnf</code></a>.
        The second parameter is the warning message.
        The third parameter is a boolean that indicates whether the message is
        to be continued by the message in the next call.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about
        warnings.
        </p>

        <!-- cs_VMT -->
        <hr><h3><a name="cs_VMT"><code>cs_VMT</code></a></h3>
        <pre>typedef struct cs_VMT cs_VMT;</pre>
        <p>
        Type for Virtual Method Table used as an argument when creating a
        class with <a href="#cs_push_class"><code>cs_push_class</code></a> or
        when setting Virtual Method Table for <em>fulluserdata</em> with
        <a href="#cs_set_uservmt"><code>cs_set_uservmt</code></a>.
        <br/><br/>
        It holds an array <code>func</code> of size
        <a href="#CS_MM_N"><code>CS_MM_N</code></a> and each entry holds a
        <a href="#cs_CFunction"><code>cs_CFunction</code></a>.
        Programmer should set all entries in <code>func</code>; the metamethod
        entries that are not being used should be set as <em>NULL</em>; used
        entries should contain a valid
        <a href="#cs_CFunction"><code>cs_CFunction</code></a>.
        Here is an example of setting the <code>cs_VMT</code> before
        calling the <a href="#cs_push_class"><code>cs_push_class</code></a>:
        <pre>
    /*
    ** Suppose we are creating a Vec2 class and we wish to overload
    ** addition ("__add") operator and initializer ("__init").
    */

    static int initvec2 (cs_State *C) {
        cs_push_number(C, 0.0);
        cs_set_fieldstr(C, 0, "x");     /* set "x" field */

        cs_push_number(C, 0.0);
        cs_set_fieldstr(C, 0, "y");     /* set "y" field */

        return 1;       /* return the instance */
    }

    static int addvec2 (cs_State *C) {
        /* index 0 and 1 hold Vec2 instances */
        cs_get_class(C, 0); 
        cs_push_instance(C, 2);     /* create new Vec2 instance */

        cs_get_fieldstr(C, 0, "x");
        cs_get_fieldstr(C, 1, "x");
        cs_arith(C, OP_ADD);            /* add the "x" */
        cs_set_fieldstr(C, 2, "x");     /* set the "x" field */

        cs_get_fieldstr(C, 0, "y");
        cs_get_fieldstr(C, 1, "y");
        cs_arith(C, OP_ADD);            /* add the "y" */
        cs_set_fieldstr(C, 2, "y");     /* set the "y" field */

        return 1;       /* return only the new instance */
    }

    static void pushclass_vec2 (cs_State *C) {
        cs_VMT vmt = {0};       /* zero initialize the whole array */
        vmt.func[CS_MM_INIT] = initvec2;    /* set CS_MM_INIT entry */
        vmt.func[CS_MM_ADD] = addvec2;      /* set CS_MM_ADD entry */

        /*
        ** Finally create (and push) the class with 'vmt', no superclass (-1),
        ** no upvalues (0) and no methods (NULL).
        */
        cs_push_class(C, &vmt, -1, 0, NULL);
    }</pre>
        For more information about what each metamethod function expects
        see <a href="#2.4"><code>&sect;2.4</code></a>.
        </p>

        <!-- cs_Entry -->
        <hr><h3><a name="cs_Entry"><code>cs_Entry</code></a></h3>
        <pre>
    typedef struct cs_Entry {
        const char *name;
        cs_CFunction func;
    } cs_Entry;</pre>
        <p>
        Type for arrays of functions or methods to be set by
        <a href="#cs_push_class"><code>cs_push_class</code></a> or
        <a href="#csL_set_funcs"><code>csL_set_funcs</code></a>.
        <code>name</code> is the function name and <code>func</code> is a
        pointer to the function.
        Any array of <a href="#csL_Entry"><code>csL_Entry</code></a> must end
        with a sentinel entry in which both <code>name</code> and
        <code>func</code> are <code>NULL</code>.
        </p>

        <!-- cs_DebugInfo -->
        <hr><h3><a name="cs_DebugInfo"><code>cs_DebugInfo</code></a></h3>
        <pre>
    typedef struct cs_Debug {
        const char *name;           /* (n) */
        const char *namewhat;       /* (n) */
        const char *what;           /* (s) */
        const char *source;         /* (s) */
        size_t srclen;              /* (s) */
        int currline;               /* (l) */
        int defline;                /* (s) */
        int lastdefline;            /* (s) */
        int nupvals;                /* (u) number of upvalues */
        int nparams;                /* (u) number of parameters */
        char isvararg;              /* (u) */
        char shortsrc[CS_MAXSRC];   /* (s) */
        /* private part */
        <em>other fields</em>
    } cs_Debug;</pre>
        <p>
        A structure used to carry different pieces of information about a
        function or an activation record.
        <a href="#cs_getstack"><code>cs_getstack</code></a> fills only the
        private part of this structure, for later use.
        To fill the other fields of
        <a href="#cs_Debug"><code>cs_Debug</code></a> with useful information,
        you must call <a href="#cs_getinfo"><code>cs_getinfo</code></a> with
        an appropriate parameter. (Specifically, to get a field, you must add
        the letter between parentheses in the field's comment to the parameter
        <code>what</code> of <a href="#cs_getinfo"><code>cs_getinfo</code></a>.)
        <br/><br/>
        The fields of <a href="#cs_Debug"><code>cs_Debug</code></a> have the
        following meaning:
        <ul>
            <li>
                <b><code>source</code>: </b>
                the source of the chunk that created the function.
            </li>
            <li>
                <b><code>srclen</code>: </b>
                The length of the string <code>source</code>.
            </li>
            <li>
                <b><code>shortsrc</code>: </b>
                a "printable" version of <code>source</code>, to be used in
                error messages.
            </li>
            <li>
                <b><code>defline</code>: </b>
                the line number where the definition of the function starts.
            </li>
            <li>
                <b><code>lastdefline</code>: </b>
                the line number where the definition of the function ends.
            </li>
            <li>
                <b><code>what</code>: </b>
                the string <code>"CScript"</code> if the function is a CScript
                function, <code>"C"</code> if it is a C&nbsp;function,
                <code>"main"</code> if it is the main part of a chunk.
            </li>
            <li>
                <b><code>currline</code>: </b>
                the current line where the given function is executing.
            </li>
            <li>
                <b><code>name</code>: </b>
                a reasonable name for the given function.
                Because functions in CScript are first-class values, they do
                not have a fixed name: some functions can be the value of
                multiple global variables, while others can be stored only
                in a table field.
                The <code>cs_getinfo</code> function checks how the function
                was called to find a suitable name.
                If it cannot find a name, then <code>name</code> is set to
                <code>NULL</code>.
            </li>
            <li>
                <b><code>namewhat</code>: </b>
                explains the <code>name</code> field.
                The value of <code>namewhat</code> can be
                <code>"global"</code>, <code>"local"</code>,
                <code>"method"</code>, <code>"field"</code>,
                <code>"upvalue"</code>, or <code>""</code> (the empty string),
                according to how the function was called. (CScript uses the
                empty string when no other option seems to apply.)
                <br/>
                <b>NOTE:</b> only <code>"method"</code> works for now, this
                is until symbolic execution is implemented internally.
            </li>
            <li>
                <b><code>nupvals</code>: </b>
                the number of upvalues of the function.
            </li>
            <li>
                <b><code>nparams</code>: </b>
                the number of parameters of the function
                (always 0&nbsp;for C&nbsp;functions).
            </li>
            <li>
                <b><code>isvararg</code>: </b>
                true if the function is a variadic function
                (always true for C&nbsp;functions).
            </li>
        </ul>
        </p>

        <!-- cs_MM -->
        <hr><h3><a name="cs_MM"><code>cs_MM</code></a></h3>
        <p>
        <pre>
    typedef enum cs_MM {
        CS_MM_INIT = 0,
        CS_MM_GETIDX,
        CS_MM_SETIDX,
        CS_MM_GC,
        CS_MM_CLOSE,
        CS_MM_CALL,
        CS_MM_CONCAT,
        CS_MM_ADD, 
        CS_MM_SUB,
        CS_MM_MUL,
        CS_MM_DIV,
        CS_MM_MOD,
        CS_MM_POW,
        CS_MM_BSHL,
        CS_MM_BSHR,
        CS_MM_BAND,
        CS_MM_BOR,
        CS_MM_BXOR,
        CS_MM_UNM,
        CS_MM_BNOT,
        CS_MM_EQ,
        CS_MM_LT,
        CS_MM_LE,
        CS_MM_N, /* number of mm */
    } cs_MM;</pre>
        These values correspond to each <a href="#Metamethods">metamethod</a>.
        They are used for setting <em>fulluserdata</em> metamethods with
        <a href="#cs_set_usermm"><code>cs_set_usermm</code></a>, testing
        if object has a metamethod defined with 
        <a href="#cs_hasmetamethod"><code>cs_hasmetamethod</code></a>, getting
        a metamethod with
        <a href="#cs_get_metamethod"><code>cs_get_metamethod</code></a> and in
        setting the <a href="#cs_VMT"><code>cs_VMT</code></a>.
        Total number of metamethods is denoted by <code>CS_MM_N</code>.
        <br/><br/>
        For more information on metamethods see
        <a href="#2.4">&sect;2.4</a>.
        </p>




        <h1>5 &ndash; <a name="5">The Auxiliary Library</h1>
        <p>To do...</p>




        <h1>6 &ndash; <a name="6">The Standard Libraries</h1>
        <p>
        The standard CScript libraries provide useful functions that are
        implemented in&nbsp;C through the C&nbsp;API.
        Most of these functions provide essential service to the
        language that is not express via the language syntax and others
        provide access to outside services (e.g., I/O).
        <br/><br/>
        All libraries are implemented through the official C&nbsp;API and are
        provided as separate C&nbsp;modules.
        <br/><br/>
        The notation <b>fail</b> means a false value representing some kind of
        failure (the recommendation is to always test the success of these
        functions with <code>(!status)</code>, instead of
        <code>(status == nil)</code>).
        <br/><br/>
        Currently, CScript has the following standard libraries:
        <ul>
            <li>basic library (<a href="#6.1">&sect;6.1</a>);</li>
            <li>string library (<a href="#6.2">&sect;6.2</a>);</li>
            <li>math library (<a href="#6.3">&sect;6.3</a>);</li>
            <li>utf-8 library (<a href="#6.4">&sect;6.4</a>);</li>
            <li>input-output library (<a href="#6.5">&sect;6.5</a>);</li>
            <li>operating system library (<a href="#6.6">&sect;6.6</a>);</li>
        </ul>
        To have access to these libraries, the C&nbsp;host program should
        call the <a href="#csL_open_libs"><code>csL_openlibs</code></a>
        function, which opens all standard libraries.
        Alternatively, the host program can open them individually by using
        <a href="#csL_include"><code>csL_include</code></a> to call
        <a name="csL_open_base"><code>csL_open_base</code></a> (for the basic library),
        <a name="csL_open_string"><code>csL_open_string</code></a> (for the string library),
        <a name="csL_open_utf8"><code>csL_open_utf8</code></a> (for the UTF-8 library),
        <a name="csL_open_math"><code>csL_open_math</code></a> (for the math library),
        <a name="csL_open_io"><code>csL_open_io</code></a> (for the I/O library),
        <a name="csL_open_os"><code>csL_open_os</code></a> (for the operating system library),
        These functions are declared in <a name="cslib.h"><code>cslib.h</code></a>
        </p>


        <h2>6.1 &ndash; <a name="6.1">Basic Library</a></h2>
        <p>
        The basic library provides core functions to CScript.
        <br/><br/>

        <!-- error -->
        <hr/><h3><a name="error"><code>error (message [, level])</code></a></h3>
        Raises an error with <code>message</code> as the error object.
        This function never returns.
        <br/> <br/>
        Usually, <code>error</code> adds some information about the error position
        at the beginning of the message, if the message is a string.
        The <code>level</code> argument specifies how to get the error position.
        With level&nbsp;0 (the default), the error position is where the
        <code>error</code> function was called.
        Level&nbsp;1 points the error to where the function
        that called <code>error</code> was called; and so on.
        Passing a negative level (e.g., <code>-1</code>) avoids the addition
        of error position information to the message.
        <br/><br/>

        <!-- assert -->
        <hr/><h3><a name="assert"><code>assert (v [, message])</code></a></h3>
        Raises an error if the value of its argument <code>v</code> is false
        (i.e., <b>nil</b> or <b>false</b>); otherwise, returns all its arguments.
        <br/><br/>
        In case of error, <code>message</code> is the error object;
        when absent, it defaults to "<code>assertion failed!</code>"
        <br/><br/>

        <!-- gc -->
        <hr/><h3><a name="gc"><code>gc ([opt [, arg]])</code></a></h3>
        This function is a generic interface to the garbage collector.
        It performs different functions according to its first argument,
        <code>opt</code>:
        <ul>
            <li>
                <b>"<code>collect</code>": </b>
                Performs a full garbage-collection cycle.
                This is the default option.
            </li>
            <li>
                <b>"<code>stop</code>": </b>
                Stops automatic execution of the garbage collector.
                The collector will run only when explicitly invoked,
                until a call to restart it.
            </li>
            <li>
                <b>"<code>restart</code>": </b>
                Restarts automatic execution of the garbage collector.
            </li>
            <li>
                <b>"<code>count</code>": </b>
                Returns the total memory in use by CScript in Kbytes.
                The value has a fractional part, so that it multiplied by
                1024 gives the exact number of bytes in use by CScript.
            </li>
            <li>
                <b>"<code>step</code>": </b>
                Performs a garbage-collection step.
                The step "size" is controlled by <code>arg</code>.
                With a zero value, the collector will perform one basic
                (indivisible) step.
                For non-zero values, the collector will perform as if that
                amount of memory (in Kbytes) had been allocated by CScript.
                Returns <b>true</b> if the step finished a collection cycle.
            </li>
            <li>
                <b>"<code>isrunning</code>": </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
            <li>
                <b>"<code>incremental</code>": </b>
                Change the collector mode to incremental.
                This option can be followed by three numbers:
                the garbage-collector pause, the step multiplier,
                and the step size. A zero means to not change that value.
            </li>
        </ul>
        This function should not be called by a finalizer (<code>__gc</code>).
        <br/><br/>

        <!-- load -->
        <hr/><h3><a name="load"><code>load (chunk [, chunkname])</code></a></h3>
        Loads a chunk.
        <br/><br/>
        If <code>chunk</code> is a string, the chunk is this string.
        If <code>chunk</code> is a function, <code>load</code> calls it
        repeatedly to get the chunk pieces. Each call to <code>chunk</code>
        must return a string that concatenates with previous results.
        A return of an empty string, <b>nil</b>, or no value signals the end
        of the chunk.
        If there are no syntactic errors, <code>load</code> returns the
        compiled chunk as a function; otherwise, it returns <b>fail</b> plus
        the error message.
        <br/> <br/>
        <code>chunkname</code> is used as the name of the chunk for error
        messages and debug information.
        When absent, it defaults to <code>chunk</code>, if <code>chunk</code>
        is a string, or to "<code>=(load)</code>" otherwise.
        <br/><br/>

        <!-- loadfile -->
        <hr/><h3><a name="loadfile"><code>loadfile ([filename])</code></a></h3>
        Similar to <a href="#load"><code>load</code></a>,
        but gets the chunk from file <code>filename</code> or from the
        standard input, if no file name is given.
        <br/><br/>

        <!-- runfile -->
        <hr/><h3><a name="runfile"><code>runfile ([filename])</code></a></h3>
        Opens the named file and executes its content as a CScript chunk.
        When called without arguments, <code>runfile</code> executes the
        content of the standard input (<code>stdin</code>).
        Returns all values returned by the chunk.
        In case of errors, <code>runfile</code> propagates the error to its
        caller (that is, <code>runfile</code> does not run in protected mode).
        <br/><br/>

        <!-- getmetamethod -->
        <hr/><h3><a name="getmetamethod"><code>getmetamethod (v, name)</code></a></h3>
        Returns the metamethod of the given <code>v</code> or <b>nil</b>
        if <code>v</code> does not have virtual method table and/or the
        <code>v</code> does not implement the metamethod <code>name</code>.
        <br/><br/>

        <!-- next -->
        <hr/><h3><a name="next"><code>next (v [, index])</code></a></h3>
        Allows a program to traverse of all fields of <code>v</code>.
        Its first argument is a table or instance and its second argument
        is an index into this table/instance.
        A call to <code>next</code> returns the next index of the
        <code>v</code> and its associated value.
        When called with <b>nil</b> as its second argument, <code>next</code>
        returns an initial index and its associated value.
        When called with the last index, or with <b>nil</b> in an empty
        table or instance without fields, <code>next</code> returns <b>nil</b>.
        If the second argument is absent, then it is interpreted as <b>nil</b>.
        In particular, you can use <code>next(v)</code> to check whether a
        table is empty or if the instance has no fields.
        <br/><br/>
        The order in which the indices are enumerated is not specified.
        <br/><br/>
        You should not assign any value to a non-existent field in a table
        during its traversal. You may however modify existing fields.
        In particular, you may set existing fields to <b>nil</b>.
        <br/><br/>

        <!-- pairs -->
        <hr/><h3><a name="pairs"><code>pairs (v)</code></a></h3>
        Returns three values: the <a href="#next"><code>next</code></a>
        function, <code>v</code>, and <b>nil</b>, so that the construction
        <pre>   foreach k,v in pairs(v) <em>body</em></pre>
        will iterate over all key&ndash;value pairs of <code>v</code>;
        <code>v</code> should be either a <em>table</em> or <em>instance</em>.
        <br/><br/>
        See function <a href="next"><code>next</code></a> for the caveats
        of modifying the table or instance fields during its traversal.
        <br/><br/>

        <!-- ipairs -->
        <hr/><h3><a name="ipairs"><code>ipairs (a)</code></a></h3>
        Returns three values (an iterator function, the array <code>a</code>,
        and -1)
        so that the construction
        <pre>   foreach i,v in ipairs(a) <em>body</em></pre>
        will iterate over the index&ndash;value pairs
        (<code>0,a[0]</code>), (<code>1,a[1]</code>), ...,
        up to the <em>length</em> of the array <code>a</code>.
        <br/><br/>

        <!-- pcall -->
        <hr/><h3><a name="pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>
        Calls the function <code>f</code> with the given arguments in
        <em>protected mode</em>.
        This means that any error inside&nbsp;<code>f</code> is not propagated;
        instead, <code>pcall</code> catches the error and returns a status code.
        Its first result is the status code (a boolean), which is <b>true</b>
        if the call succeeds without errors.
        In such case, <code>pcall</code> also returns all results from the call,
        after this first result.
        <br/><br/>
        In case of any error, <code>pcall</code> returns <b>false</b> plus the error object.
        Note that errors caught by <code>pcall</code> do not call a message handler.
        <br/><br/>

        <!-- xpcall -->
        <hr/><h3><a name="xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>
        This function is similar to <a href="#pcall"><code>pcall</code></a>,
        except that it sets a new message handler <code>msgh</code>.
        <br/><br/>

        <!-- print -->
        <hr/><h3><a name="print"><code>print (&middot;&middot;&middot;)</code></a></h3>
        Receives any number of arguments and prints their values to
        <code>stdout</code>, converting each argument to a string
        following the same rules of <a href="#tostring"><code>tostring</code></a>.
        <br/><br/>
        The function <code>print</code> is not intended for formatted output,
        but only as a quick way to show a value, for instance for debugging.
        For complete control over the output, use
        <a href="#io.printf"><code>io.printf</code></a> and
        <a href="#io.write"><code>io.write</code></a>.
        <br/><br/>

        <!-- warn -->
        <hr/><h3><a name="warn"><code>warn (msg1, &middot;&middot;&middot;)</code></a></h3>
        Emits a warning with a message composed by the concatenation
        of all its arguments (which should be strings).
        <br/><br/>
        By convention, a one-piece message starting with '<code>@</code>'
        is intended to be a <em>control message</em>,
        which is a message to the warning system itself.
        In particular, the standard warning function in CScript
        recognizes the control messages "<code>@off</code>",
        to stop the emission of warnings, and "<code>@on</code>", to
        (re)start the emission; it ignores unknown control messages.
        <br/><br/>

        <!-- len -->
        <hr/><h3><a name="len"><code>len (v)</code></a></h3>
        Returns the length of the object <code>v</code>, which must be
        array, table, instance or a string.
        <br/> <br/>
        <em>Array</em> length is total number of elements in use (one index
        above the biggest index that was set);
        <em>table</em> length is total number of keys with non-<b>nil</b>
        values; <em>instance</em> length is total number of fields with
        non-<b>nil</b> values; <em>string</em> length is size of string in
        bytes.
        <br/><br/>
        Returns an integer.
        <br/><br/>

        <!-- rawequal -->
        <hr/><h3><a name="rawequal"><code>rawequal (v1, v2)</code></a></h3>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        <br/><br/>
        Returns a boolean.
        <br/><br/>

        <!-- rawget -->
        <hr/><h3><a name=rawget""><code>rawget (v, index)</code></a></h3>
        Gets the real value of <code>v[index]</code>,
        without calling the <code>__getidx</code> metamethod.
        <code>v</code> must be a array, table or instance;
        <code>index</code> may be any value if <code>v</code> is instance or a
        table; if <code>v</code> is array, <code>index</code> should be
        positive integer or 0.
        <br/><br/>

        <!-- rawset -->
        <hr/><h3><a name="rawset"><code>rawset (v, index, value)</code></a></h3>
        Sets the real value of <code>v[index]</code> to <code>value</code>,
        without using the <code>__setidx</code> metamethod.
        <code>v</code> must be an array, table or instance;
        <code>index</code> any value different from <b>nil</b> and NaN if the
        <code>v</code> is a table or instance, otherwise <code>index</code>
        should be a positive integer or 0; <code>value</code> any CScript value.
        <br/><br/>
        This function returns <code>v</code>.
        <br/><br/>

        <!-- getargs -->
        <hr/><h3><a name="getargs"><code>getargs (index, &middot;&middot;&middot;)</code></a></h3>
        If <code>index</code> is a number, returns all arguments after
        argument number <code>index</code>; a negative number indexes from
        the end (-1 is the last argument).
        Otherwise, <code>index</code> must be one of these strings:
        <code>"array"</code>, <code>"table"</code> or <code>"len"</code>.
        <br/><br/>
        In case <code>index</code> is <code>"array"</code> or
        <code>"table"</code> string then <code>getargs</code> returns
        the total number of extra arguments it received; <code>"array"</code>
        returns the extra arguments inside the array, <code>"table"</code>
        returns the extra arguments inside the table where each argument is
        a key with <b>true</b> value.
        <br/><br/>
        However if <code>index</code> is 
        <code>"len"</code> string, then <code>getargs</code> returns integer
        corresponding to total number of extra arguments.
        <br/><br/>

        <!-- tonumber -->
        <hr/><h3><a name="tonumber"><code>tonumber (v, [, base])</code></a></h3>
        When called with no <code>base</code>,
        <code>tonumber</code> tries to convert its argument to a number.
        If the argument <code>v</code> is already a number or a string
        convertible to a number, then <code>tonumber</code> returns this
        number and overflow flag; otherwise, it returns <b>fail</b>.
        <br/><br/>
        The conversion of strings can result in integers or floats.
        The string may have leading and trailing spaces and a sign.
        The conversion mimics C standard library functions <code>strtod</code>
        and <code>strtol</code>.
        <br/><br/>
        When called with <code>base</code>, then <code>v</code> must be a
        string to be interpreted as an integer numeral in that base.
        The base may be any integer between 2 and 36, inclusive.
        In bases above&nbsp;10, the letter '<code>A</code>' (in either upper
        or lower case) represents&nbsp;10, '<code>B</code>' represents&nbsp;11,
        and so forth, with '<code>Z</code>' representing 35.
        If the string <code>v</code> is not a valid numeral in the given base,
        the function returns <b>fail</b>.
        <br/><br/>

        <!-- tostring -->
        <hr/><h3><a name="tostring"><code>tostring (v)</code></a></h3>
        Receives a value of any type and converts it to a string in a
        human-readable format.
        <br/><br/>

        <!-- typeof -->
        <hr/><h3><a name="typeof"><code>typeof (v)</code></a></h3>
        Returns the type of its only argument, coded as a string.
        The possible results of this function are
        "<code>nil</code>" (a string, not the value <b>nil</b>),
        "<code>number</code>",
        "<code>string</code>",
        "<code>boolean</code>",
        "<code>array</code>",
        "<code>table</code>",
        "<code>function</code>",
        "<code>class</code>",
        "<code>instance</code>",
        "<code>thread</code>",
        and "<code>userdata</code>".
        <br/><br/>

        <!-- __G -->
        <hr/><h3><a name="__G"><code>__G</code></a></h3>
        A global variable (not a function) that holds the global table
        (see <a href="#2.2">&sect;2.2</a>).
        <br/>
        CScript itself does not use this variable;
        changing its value does not affect any environment, nor vice versa.
        <br/><br/>

        <!-- __VERSION -->
        <hr/><h3><a name="__VERSION"><code>__VERSION</code></a></h3>
        A global variable (not a function) that holds a string containing
        the running CScript version.
        <br/>
        The current value of this variable is "<code>CScript 1.0</code>".
        </p>



        <h2>6.2 &ndash; <a name="6.2">String Library</a></h2>
        <p>
        This library provides generic functions for string manipulation,
        such as finding and extracting substrings and other common operations.
        All of the functionality is provided in the global class 
        <a name="String"><code>String</code></a>.
        When indexing <code>String</code> instance in CScript, the first
        character is at position &nbsp;0 (same as in C).
        Indices are allowed to be negative and are interpreted as indexing
        backwards, from the end of the <code>String</code>.
        Thus, the last character is at position -1, and so on.
        <br/>
        The string library assumes one-byte character encodings.
        </p>



        <h2>6.3 &ndash; <a name="6.3">UTF-8 Library</a></h2>
        <p>
        </p>



        <h2>6.4 &ndash; <a name="6.4">Math Library</a></h2>
        <p>
        </p>



        <h2>6.5 &ndash; <a name="6.5">I/O Library</a></h2>
        <p>
        </p>



        <h2>6.6 &ndash; <a name="6.6">OS Library</a></h2>
        <p>
        </p>
    </body>
</html>
